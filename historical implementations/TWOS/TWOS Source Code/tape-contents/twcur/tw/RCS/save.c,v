head     1.4;
branch   ;
access   ;
symbols  TW2_7:1.4 TW2_6:1.4 TW2_5_1:1.3 TW2_5:1.2 TW2_4_2:1.1 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.4
date     91.11.01.10.06.24;  author pls;  state Rel;
branches ;
next     1.3;

1.3
date     91.07.17.15.12.02;  author judy;  state Rel;
branches ;
next     1.2;

1.2
date     91.06.03.12.26.33;  author configtw;  state Rel;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.52;  author configtw;  state Rel;
branches ;
next     ;


desc
@state saving routines
@


1.4
log
@1.  Change ifdef's, version id.
2.  Set up check_stack_and_state() for use (SCR 200).
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	save.c,v $
 * Revision 1.3  91/07/17  15:12:02  judy
 * New copyright notice.
 * 
 * Revision 1.2  91/06/03  12:26:33  configtw
 * Tab conversion.
 * 
 * Revision 1.1  90/08/07  15:40:52  configtw
 * Initial revision
 * 
*/
char save_id [] = "@@(#)save.c   $Revision$\t$Date$\tTIMEWARP";


#include "twcommon.h"
#include "twsys.h"

FUNCTION save_state ( ocb )

	Ocb * ocb;
{
  Debug

#if PARANOID
	check_stack_and_state ( ocb );
#endif

	if ( ocb->stk )
	{
		l_destroy ( ocb->stk );
		ocb->stk = NULL;
	}

	l_insert ( ocb->cs, ocb->sb );

	ocb->cs = ocb->sb;

	ocb->sb = NULL;

	ocb->stats.nssave++;
}

FUNCTION void check_stack_and_state ( ocb )

	Ocb * ocb;
{
	if ( strcmp ( ocb->stk, "stack limit" ) != 0 )
	{
		_pprintf ( "%s stack overflow at time %f\n", ocb->name, ocb->svt.simtime );
		tester ();
	}

	if ( strcmp ( ((Byte *)(ocb->sb+1)) + ocb->pvz_len, "state limit" ) )
	{
		_pprintf ( "%s state overflow at time %f\n", ocb->name, ocb->svt.simtime );
		tester ();
	}
}
@


1.3
log
@New copyright notice.
@
text
@d7 3
d17 1
a17 1
char save_id [] = "@@(#)save.c   1.19\t7/27/89\t11:35:01\tTIMEWARP";
d29 1
a29 1
#ifdef PARANOID
d48 1
a48 2
#ifdef PARANOID
check_stack_and_state ( ocb )
a63 1
#endif
@


1.2
log
@Tab conversion.
@
text
@d1 4
d6 4
a9 1
 * $Log:        save.c,v $
a15 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d7 1
a7 1
char save_id [] = "@@(#)save.c	1.19\t7/27/89\t11:35:01\tTIMEWARP";
d9 3
a11 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d18 1
a18 1
    Ocb * ocb;
d23 1
a23 1
    check_stack_and_state ( ocb );
d26 5
a30 5
    if ( ocb->stk )
    {
	l_destroy ( ocb->stk );
	ocb->stk = NULL;
    }
d32 1
a32 1
    l_insert ( ocb->cs, ocb->sb );
d34 1
a34 1
    ocb->cs = ocb->sb;
d36 1
a36 1
    ocb->sb = NULL;
d38 1
a38 1
    ocb->stats.nssave++;
d44 1
a44 1
    Ocb * ocb;
d46 5
a50 5
    if ( strcmp ( ocb->stk, "stack limit" ) != 0 )
    {
	_pprintf ( "%s stack overflow at time %f\n", ocb->name, ocb->svt.simtime );
	tester ();
    }
d52 5
a56 5
    if ( strcmp ( ((Byte *)(ocb->sb+1)) + ocb->pvz_len, "state limit" ) )
    {
	_pprintf ( "%s state overflow at time %f\n", ocb->name, ocb->svt.simtime );
	tester ();
    }
@
