head     1.6;
branch   ;
access   ;
symbols  TW2_7:1.6 TW2_6:1.5 TW2_5_1:1.5 TW2_5:1.4 TW2_4_2:1.1 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.6
date     91.12.27.08.46.59;  author reiher;  state Rel;
branches ;
next     1.5;

1.5
date     91.07.17.15.11.13;  author judy;  state Rel;
branches ;
next     1.4;

1.4
date     91.06.03.12.25.48;  author configtw;  state Rel;
branches ;
next     1.3;

1.3
date     91.04.01.15.44.11;  author reiher;  state Dev;
branches ;
next     1.2;

1.2
date     91.03.26.09.30.20;  author pls;  state Dev;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.34;  author configtw;  state Rel;
branches ;
next     ;


desc
@handle object completion
@


1.6
log
@Added one line to support event time throttling
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	objend.c,v $
 * Revision 1.5  91/07/17  15:11:13  judy
 * New copyright notice.
 * 
 * Revision 1.4  91/06/03  12:25:48  configtw
 * Tab conversion.
 * 
 * Revision 1.3  91/04/01  15:44:11  reiher
 * Code to support Tapas Som's work.
 * 
 * Revision 1.2  91/03/26  09:30:20  pls
 * Add Steve's RBC code.
 * 
 * Revision 1.1  90/08/07  15:40:34  configtw
 * Initial revision
 * 
*/
char objend_id [] = "@@(#)objend.c       1.42\t9/26/89\t16:44:32\tTIMEWARP";


/*
Purpose:
		
		objend.c contains the code to handle an object's completion
		of whatever it was doing.
		Generally speaking, this action is rather minimal.  It may
		be necessary to search for further work to do at this
		virtual time for this object, or it may be necessary to 
		advance virtual time and, possibly, save a state of this
		object. It will also be necessary to choose a new object
		for execution.

		In addition, objend.c contains a routine that cancels messages
		in the output queue, for purposes of rollback.  It implements
		a lazy cancellation policy.

Functions:

		objend() - handle whatever needs to be done when an object's
						current execution ends.
				Parameters - none
				Return - always returns 0

		cancel_omsgs(o,t1,t2) - lazily cancel any of this object's
						output messages between times t1 and t2
				Parameters - Ocb *o, VTime t1, VTime t2
				Return - always returns 0

Implementation:

		objend() calls savout() to keep track of the amount of time this
		object has spent so far.  Then, the object's type field is checked
		to see what it was doing.  If it was doing an event, the counter for
		number of completed events is incremented.
		dispatch() is called to choose an object to execute next.

		cancel_omsgs() looks for the last output message for the object.
		It then finds the first message in that bundle.  It starts looking
		at the times of each bundle, going backwards, until it finds a 
		bundle that is before the time at which it is to start cancellation.
		The function then runs forward from this bundle, until it runs out
		of messages or finds one later than the last time to be cancelled.
		If the message isn't marked, dqomsg() is called to dequeue it.
		The dequeued message is sent to its destination (if the destination
		object can be found in the world map; if not, destroy the message).  
		This dequeued message is an anti-message,, destined to cause 
		annihilation at the destination site.  If the message being looked
		at was marked, unmark it.  Go on to the next message.  

		cancel_omsgs() implements lazy cancellation.  When a message is
		put in the output queue, a check is made to see if it is already
		there.  If it is, the message is marked.  The meaning of this is
		that, if we have rolled back, and reproduce a message, mark its
		antimessage.  (Marked messages don't actually get sent.)  Messages
		that were rolled back over but not resent don't get marked.  
		At the end of an event, any messages in the output queue that are
		between the time of the event's start and the time of the next
		event's start are checked with cancel_omsgs().  The ones that
		weren't resent weren't marked, so they get sent out as antimessages.
		Marked messages were resent, so they are simply unmarked.  (We may
		roll back over this event again, in which case these messages may
		yet need to be cancelled, so we can't leave them marked.)
*/
		

#include "twcommon.h"
#include "twsys.h"


FUNCTION objend ()
{
	register Ocb * o;
	extern int aggressive;

  Debug

	o = xqting_ocb;

	destroy_message_vector (o);

	if ( o->centry == DCRT || o->centry == DDES )
	{
		unmark_macro ( o->ci );
	}
	else
	{
		register Msgh * n;

		for ( n = fstigb ( o->ci ); n; n = nxtigb ( n ) )
		{
			if ( n->mtype != DYNDSMSG )
				unmark_macro ( n );
		}
	}

	if ( o->centry == INIT || o->centry == DCRT || o->centry == DDES )
	{
#ifdef SOM

	/* Update the phase's highest-seen ept field to the Ept of the event
	  just completed.  Also update the amount of total unrolled back work
	  done by the phase.  */

		o->Ept = o->sb->Ept;

#endif SOM
		save_state (o);
	}

	if ( o->centry == EVENT )
	{
		o->stats.numecomp++;

		o->eventTimePermitted -= o->sb->effectWork;
#ifdef SOM
	/* Update the phase's highest-seen ept field to the Ept of the event
	  just completed.  Also update the amount of total unrolled back work
	  done by the phase.  */

		o->Ept = o->sb->Ept;

#endif SOM

		save_state ( o );
	}
	else
	if ( o->centry == TERM )
	{
#ifdef RBC
		if ( o->uses_rbc )
			l_destroy ( o->sb );
		else
		/* destroy_state and rollback chip don't mix */
#endif
		destroy_state ( o->sb );

		o->sb = NULL;
		l_destroy ( o->stk );
		o->stk = NULL;
#ifdef RBC
		if ( o->uses_rbc && rollback_op ( o, 1, posinfPlus1 ) )
		{
			printf ( "weird error term objend for %s\n", o->name );
			tester();
		}
#endif

		o->ci = NULL;
		o->co = NULL;
		o->control = EDGE;
		o->runstat = BLKINF;
		if ( ! aggressive )
			cancel_omsgs ( o, o->svt, o->phase_end );
		l_remove ( o );
		o->svt = posinfPlus1;
		l_insert ( l_prev_macro ( _prqhd ), o );
 
		dispatch ();
		return;
	}

	go_forward ( o ) ;

	dispatch ();
}


/* Cancel (lazily) output messages from t1 (inclusive) to t2 (exclusive) */

extern int cancellation_penalty;

FUNCTION cancel_omsgs ( o, t1, t2 )

	register Ocb *o;
	VTime t1, t2;
{
	register Msgh  *n, *m, *p;

  Debug

	m = lstomsg_macro ( o );

	if ( m != NULL )
		m = fstomb ( m );

	n = NULL;

	while ( m && geVTime ( m->sndtim, t1 ) )
	{
		n = m;
		m = prvobq ( m );
	}

	while ( n && ltVTime ( n->sndtim, t2 ) )
	{
		m = n;
		n = nxtobq ( n );

		while ( m != NULL )
		{
			p = nxtomb ( m );

			if ( ! ismarked_macro ( m ) )
			{
				dqomsg ( m );

				mark_macro ( m );

				smsg_stat ( o, m );

				deliver ( m );

				o->cancellations += cancellation_penalty;
			}

			m = p;
		}
	}
}
@


1.5
log
@New copyright notice.
@
text
@d7 3
d139 1
@


1.4
log
@Tab conversion.
@
text
@d1 4
d6 4
a9 1
 * $Log:        objend.c,v $
a21 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.3
log
@Code to support Tapas Som's work.
@
text
@d2 4
a5 1
 * $Log:	objend.c,v $
d13 1
a13 1
char objend_id [] = "@@(#)objend.c	1.42\t9/26/89\t16:44:32\tTIMEWARP";
d15 3
a17 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d21 9
a29 9
	
	objend.c contains the code to handle an object's completion
	of whatever it was doing.
	Generally speaking, this action is rather minimal.  It may
	be necessary to search for further work to do at this
	virtual time for this object, or it may be necessary to 
	advance virtual time and, possibly, save a state of this
	object. It will also be necessary to choose a new object
	for execution.
d31 3
a33 3
	In addition, objend.c contains a routine that cancels messages
	in the output queue, for purposes of rollback.  It implements
	a lazy cancellation policy.
d37 4
a40 4
	objend() - handle whatever needs to be done when an object's
			current execution ends.
		Parameters - none
		Return - always returns 0
d42 4
a45 4
	cancel_omsgs(o,t1,t2) - lazily cancel any of this object's
			output messages between times t1 and t2
		Parameters - Ocb *o, VTime t1, VTime t2
		Return - always returns 0
d49 5
a53 5
	objend() calls savout() to keep track of the amount of time this
	object has spent so far.  Then, the object's type field is checked
	to see what it was doing.  If it was doing an event, the counter for
	number of completed events is incremented.
	dispatch() is called to choose an object to execute next.
d55 12
a66 12
	cancel_omsgs() looks for the last output message for the object.
	It then finds the first message in that bundle.  It starts looking
	at the times of each bundle, going backwards, until it finds a 
	bundle that is before the time at which it is to start cancellation.
	The function then runs forward from this bundle, until it runs out
	of messages or finds one later than the last time to be cancelled.
	If the message isn't marked, dqomsg() is called to dequeue it.
	The dequeued message is sent to its destination (if the destination
	object can be found in the world map; if not, destroy the message).  
	This dequeued message is an anti-message,, destined to cause 
	annihilation at the destination site.  If the message being looked
	at was marked, unmark it.  Go on to the next message.  
d68 13
a80 13
	cancel_omsgs() implements lazy cancellation.  When a message is
	put in the output queue, a check is made to see if it is already
	there.  If it is, the message is marked.  The meaning of this is
	that, if we have rolled back, and reproduce a message, mark its
	antimessage.  (Marked messages don't actually get sent.)  Messages
	that were rolled back over but not resent don't get marked.  
	At the end of an event, any messages in the output queue that are
	between the time of the event's start and the time of the next
	event's start are checked with cancel_omsgs().  The ones that
	weren't resent weren't marked, so they get sent out as antimessages.
	Marked messages were resent, so they are simply unmarked.  (We may
	roll back over this event again, in which case these messages may
	yet need to be cancelled, so we can't leave them marked.)
d82 1
a82 1
	
d90 2
a91 2
    register Ocb * o;
    extern int aggressive;
d95 1
a95 1
    o = xqting_ocb;
d97 1
a97 1
    destroy_message_vector (o);
d99 1
a99 9
    if ( o->centry == DCRT || o->centry == DDES )
    {
	unmark_macro ( o->ci );
    }
    else
    {
	register Msgh * n;

	for ( n = fstigb ( o->ci ); n; n = nxtigb ( n ) )
d101 1
a101 2
	    if ( n->mtype != DYNDSMSG )
		unmark_macro ( n );
d103 3
a105 1
    }
d107 9
a115 2
    if ( o->centry == INIT || o->centry == DCRT || o->centry == DDES )
    {
d118 3
a120 3
    /* Update the phase's highest-seen ept field to the Ept of the event
      just completed.  Also update the amount of total unrolled back work
      done by the phase.  */
d122 1
a122 1
	o->Ept = o->sb->Ept;
d125 2
a126 2
	save_state (o);
    }
d128 3
a130 3
    if ( o->centry == EVENT )
    {
	o->stats.numecomp++;
d133 3
a135 3
    /* Update the phase's highest-seen ept field to the Ept of the event
      just completed.  Also update the amount of total unrolled back work
      done by the phase.  */
d137 1
a137 1
	o->Ept = o->sb->Ept;
d141 5
a145 5
	save_state ( o );
    }
    else
    if ( o->centry == TERM )
    {
d147 4
a150 4
	if ( o->uses_rbc )
	    l_destroy ( o->sb );
	else
	/* destroy_state and rollback chip don't mix */
d152 1
a152 1
	destroy_state ( o->sb );
d154 3
a156 3
	o->sb = NULL;
	l_destroy ( o->stk );
	o->stk = NULL;
d158 5
a162 5
	if ( o->uses_rbc && rollback_op ( o, 1, posinfPlus1 ) )
	{
	    printf ( "weird error term objend for %s\n", o->name );
	    tester();
	}
d165 9
a173 9
	o->ci = NULL;
	o->co = NULL;
	o->control = EDGE;
	o->runstat = BLKINF;
	if ( ! aggressive )
	    cancel_omsgs ( o, o->svt, o->phase_end );
	l_remove ( o );
	o->svt = posinfPlus1;
	l_insert ( l_prev_macro ( _prqhd ), o );
d175 3
a177 3
	dispatch ();
	return;
    }
d179 1
a179 1
    go_forward ( o ) ;
d181 1
a181 1
    dispatch ();
d191 2
a192 2
    register Ocb *o;
    VTime t1, t2;
d194 1
a194 1
    register Msgh  *n, *m, *p;
d198 1
a198 1
    m = lstomsg_macro ( o );
d200 2
a201 2
    if ( m != NULL )
	m = fstomb ( m );
d203 1
a203 1
    n = NULL;
d205 5
a209 5
    while ( m && geVTime ( m->sndtim, t1 ) )
    {
	n = m;
	m = prvobq ( m );
    }
d211 1
a211 6
    while ( n && ltVTime ( n->sndtim, t2 ) )
    {
	m = n;
	n = nxtobq ( n );

	while ( m != NULL )
d213 2
a214 1
	    p = nxtomb ( m );
d216 3
a218 3
	    if ( ! ismarked_macro ( m ) )
	    {
		dqomsg ( m );
d220 3
a222 1
		mark_macro ( m );
d224 1
a224 1
		smsg_stat ( o, m );
d226 1
a226 1
		deliver ( m );
d228 1
a228 2
		o->cancellations += cancellation_penalty;
	    }
d230 5
a234 1
	    m = p;
a235 1
    }
@


1.2
log
@Add Steve's RBC code.
@
text
@d3 3
d113 9
d128 9
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d122 6
d129 1
d133 7
@
