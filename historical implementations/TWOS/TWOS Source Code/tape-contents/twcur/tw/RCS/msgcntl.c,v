head     1.12;
branch   ;
access   ;
symbols  TW2_7:1.12 TW2_6:1.12 TW2_5_1:1.10 TW2_5:1.6 TW2_4_2:1.2 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.12
date     91.11.04.10.16.19;  author pls;  state Rel;
branches ;
next     1.11;

1.11
date     91.11.01.09.47.19;  author reiher;  state Dev;
branches ;
next     1.10;

1.10
date     91.07.22.13.17.13;  author configtw;  state Rel;
branches ;
next     1.9;

1.9
date     91.07.17.15.10.48;  author judy;  state Dev;
branches ;
next     1.8;

1.8
date     91.07.11.08.54.57;  author steve;  state Dev;
branches ;
next     1.7;

1.7
date     91.07.09.14.31.18;  author steve;  state Dev;
branches ;
next     1.6;

1.6
date     91.06.04.13.45.21;  author configtw;  state Rel;
branches ;
next     1.5;

1.5
date     91.06.03.12.25.36;  author configtw;  state Dev;
branches ;
next     1.4;

1.4
date     91.05.31.14.45.30;  author pls;  state Dev;
branches ;
next     1.3;

1.3
date     91.04.01.15.42.42;  author reiher;  state Dev;
branches ;
next     1.2;

1.2
date     90.12.10.10.42.13;  author configtw;  state Rel;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.25;  author configtw;  state Rel;
branches ;
next     ;


desc
@low level message sending routines
@


1.12
log
@1.  Remove IH messages from those which are ACK'd.
2.  Allow Sun to print out RMQ.
3.  Error if sending emergbuf on node.
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	msgcntl.c,v $
 * Revision 1.11  91/11/01  09:47:19  reiher
 * debugging code, plus a bug fix (PLR)
 * 
 * Revision 1.10  91/07/22  13:17:13  configtw
 * Fix new bug in Mark3 code.
 * 
 * Revision 1.9  91/07/17  15:10:48  judy
 * New copyright notice.
 * 
 * Revision 1.8  91/07/11  08:54:57  steve
 * Allow sun version to send zero length messages.
 * 
 * Revision 1.7  91/07/09  14:31:18  steve
 * 1. Modified Sun version to support signal driven sockets.
 * 2. Removed mistuff, change d 128 to IH_NODE, other numbers to constants
 * 3. MicroTime support added.
 * 4. Modified Ack_msg a bit.
 * 
 * Revision 1.6  91/06/04  13:45:21  configtw
 * Call tester() if emergbuf goes to rmq.
 * 
 * Revision 1.5  91/06/03  12:25:36  configtw
 * Tab conversion.
 * 
 * Revision 1.4  91/05/31  14:45:30  pls
 * 1.  Add some PARANOID checks.
 * 2.  Add send_e_from_q() for emergbuf.
 * 
 * Revision 1.3  91/04/01  15:42:42  reiher
 * A change to make sure IH messages don't contribute to gvt calculation,
 * and a bug fix to look at the correct flag in a message.
 * 
 * Revision 1.2  90/12/10  10:42:13  configtw
 * use .simtime field as necessary
 * 
 * Revision 1.1  90/08/07  15:40:25  configtw
 * Initial revision
 * 
*/
char msgcntl_id [] = "@@(#)msgcntl.c     1.48\t10/2/89\t15:02:31\tTIMEWARP";


/*

Purpose:

		msgcntl.c contains the low-level message sending routines that get
		messages from the tester output queue to the underlying message
		delivery system.  Acks are also largely handled by routines in this
		module.

Functions:

		rcvmsg(msg,node) - check an incoming message's validity
				Parameters - Msgh * msg, Int node
				Return - Always returns zero

		print_acks() - print the contents of the acks table
				Parameters - none
				Return - Always returns zero

		rcvack(msg,node) - remove an ack from the acks table
				Parameters - Ack_msg  *msg, Int node
				Return - Always returns zero

		queack(msg,node) - list an ack as outstanding
				Parameters - Msgh * msg, Int node
				Return - Always returns zero

		sndack(msg,node) - send an ack
				Parameters - Msgh * msg, Int node
				Return - Always returns zero

		enq_msg(msg) - put an outgoing message in the queue for its
						destination node
				Parameters - Msgh * msg
				Return - Always returns zero

		print_queues() - print the queues of messages going out to other nodes
				Parameters - none
				Return - Always returns zero

		send_from_q() - send out any acks, broadcast messages, or normal 
						messages going to other nodes
				Parameters - none
				Return - Always returns zero

		log_ack_pending(msg,node) - make an entry for a message's outstanding
						ack in the acks table
				Parameters - Msgh * msg, Int node
				Return - zero, or crash

		destroy_msg(msg) - get rid of a message
				Parameters - Msgh *msg
				Return - Always returns zero

		checksum(tw_msg) - compute a checksum for a message
				Parameters - Msgh * tw_msg
				Return - the checksum

Implementation:

		rcvmsg() is  a checking function called by read_the_mail() and
		other routines when they are in PARANOID mode.  It checks the
		validity of certain message fields.

		print_acks() prints the table of outstanding acknowledgements.

		rcvack() removes an ack's entry from the table of outstanding
		acknowledgements.

		queack() puts an entry in the acknowledgement queue.

		sndack() calls send_message() to ship off an acknowledgement.
		The entry in the acknowledgement queue is made by log_ack_pending().

		enq_msg() puts an entry for an outgoing message into a node's 
		list in the pmq[] table.  System messages are put before the first
		non-system message, and regular messages are put in in send time 
		order, after all system messages.  

		print_queues() prints the queue kept for each node in the local
		pmq[] table.  

		send_from_q(), if we're not on a Mark3, first tries to use
		send_message(0 to send out any queued acks.  Whatever machine
		we're on, if there is a message to be broadcast, and this node
		is not the only node participating in the simulation, call 
		send_message() to send it out.  If BRDCST_ABLE is set, indicating
		a low level broadcast ability, just send it out once.  If there is
		no low level broadcast ability, loop, calling send_message() for
		each node.  After broadcast messages are taken care of, call
		send_stdout_msg(), if necessary.  Then run through all entries in
		the pmq[] array.  For each, look at each message in the queue of
		messages to be sent to the entry's node.  If there aren't already
		too many acks outstanding, call send_message() to send it, and
		go on to the next message.  Remove and destroy any message that
		got sent.

		log_ack_pending() finds an unused entry in the ack[] array, and
		fills it with an entry for the message in question.

		destroy_msg() gets rid of a message's storage by calling l_destroy().

		checksum() computes a checksum for a message.

*/


#include <stdio.h>  
#include "twcommon.h"
#include "twsys.h"
#include "tester.h"
#include "machdep.h"

#if PARANOID
VTime MinLvt;
#endif

#ifdef MARK3
extern Msgh * inuse_messages;
#endif

extern char brdcst_flag[];

#ifndef BBN
extern int max_acks;
extern int max_neg_acks;
#endif

FUNCTION rcvmsg ( msg, node )

	Msgh * msg;
	Int node;
{
  Debug

	if ( msg->low.from_node != node
	|| ( msg->low.to_node != tw_node_num && msg->low.to_node != IH_NODE && msg->low.to_node != 0 )
	||   msg->low.type == ACK_MSG )

/*	Note:  this may produce error messages on the Mark3.  The
	low.type field is overwritten by the Mercury send_msg routine which
	stores IN_USE and DONE information there.  See the call to
	send_message_fast() in send_from_q().
*/
	{
		_pprintf ( "Bad Msg from Node %d ", node );
		_pprintf ( "%.8x %.8x\n", *((int *)msg), *(((int*)msg)+1) );
		showmsg(msg);
		tester();
#ifdef SUN
		tester ();
		dump_socket ( node );
		tester ();
#endif
	}
}

print_acks ()
{
#ifdef BBN
	_pprintf ( "messages_to_send = %d\n", messages_to_send );
#else
	int i;

	_pprintf ( "acks_pending = %d, messages_to_send = %d\n",
				acks_pending, messages_to_send );

	for ( i = 0; i < MAX_ACKS; i++ )
		if ( ack[i].busy )
			_pprintf ( "node %d num %d time %f\n",
				ack[i].node, ack[i].num, ack[i].time.simtime );
#endif
}

#ifndef BBN
FUNCTION rcvack ( msg, node )

	Ack_msg * msg;
	Int node;
{
	register int i;

  Debug

	rcvack_cnt++;

	if ( msg->low.to_node == IH_NODE )
		msg->low.to_node = 0;

#ifdef PARANOID
	if ( msg->low.from_node != tw_node_num
	||   msg->low.to_node != node )
	{
		_pprintf ( "Bad Ack from Node %d ", node );
		_pprintf ( "%.8x %.8x\n", *((int *)msg), *(((int*)msg)+1) );

#ifdef SUN
		tester ();
		dump_socket ( node );
		tester ();
#endif
	}
#endif

	for ( i = 0; i < MAX_ACKS; i++ )
	{
		if ( ack[i].busy
		&&   ack[i].node == node
		&&   ack[i].num  == msg->num )
			break;
	}

	if ( i < MAX_ACKS )
	{
		ack[i].busy = FALSE;
		acks_pending--;
	}
	else
	{
		_pprintf ( "ack not found %d %d\n", node, msg->num );
		print_acks ();
		tester ();
	}
}


FUNCTION queack ( msg )

	Msgh * msg;
{
  Debug

	if ( acks_queued < MAX_QACKS )
	{
		acks_queued++;

		qack[ack_q_tail++] = * (Ack_msg *) msg;

		if ( ack_q_tail >= MAX_QACKS )
			ack_q_tail = 0;
	}
	else
	{
		_pprintf ( "Too many qacks\n" );
		tester ();
	}
}

FUNCTION sndack ( msg, node )

	Msgh * msg;
	Int node;
{
	int cc;
	Ack_msg m;

  Debug

	m.low.type = ACK_MSG;
	m.num = msg->gid.num;
	m.low.from_node = tw_node_num;
	m.low.to_node = node;
	m.low.length = sizeof(Ack_msg);

#ifdef MARK3
	cc = ack_q_tail;
	queack ( &m );
	send_message_fast ( &qack[cc], sizeof(Ack_msg), node, ACK_MSG, &qackst[cc]);
#else
	cc = send_message ( (char *) &m, sizeof(Ack_msg), node, ACK_MSG );
	if ( cc == -1 )
		queack ( &m );
	else if ( cc != sizeof(Ack_msg) )
		printf ( "sndack: cc = %d\n", cc );
#endif
}

#endif /* not BBN */

enq_msg ( msg )

	register Msgh * msg;
{
	register Msgh * next, * prev;

	if ( issys_macro ( msg ) )
	{  /* here if system message */
		for ( next = pmq, prev = (Msgh *) l_next_macro ( next );
								! l_ishead_macro ( prev );
			  next = prev, prev = (Msgh *) l_next_macro ( next ) )
		{  /* position to first non system message */
			if ( ! issys_macro ( prev ) )
				break;
		}
	}
	else
	if ( isanti_macro ( msg ) )
	{  /* it's a negative message */
		for ( next = pmq, prev = (Msgh *) l_next_macro ( next );
								! l_ishead_macro ( prev );
			  next = prev, prev = (Msgh *) l_next_macro ( next ) )
		{
			if ( issys_macro ( prev ) )
				continue;       /* bypass system messages */

			if ( isposi_macro ( prev ) )
				break;          /* stop at first regular message */

			if ( ltVTime ( msg->sndtim, prev->sndtim ) )
				break;          /* or when past the q's send time */
		}
	}
	else
	{  /* regular message--go through queue backwards */
		for ( next = (Msgh *) l_prev_macro ( pmq );
				   ! l_ishead_macro ( next );
			  next = (Msgh *) l_prev_macro ( next ) )
		{
			if ( issys_macro ( next ) )
				break;  /* stop at first system message */

			if ( isanti_macro ( next ) )
				break;  /* or first negative message */

			if ( geVTime ( msg->sndtim, next->sndtim ) )
				break;  /* or when past the q's send time */
		}
	}

	l_insert ( next, msg );     /* put this message in the queue */

	messages_to_send++;         /* and increment count */
}

#ifdef DLM
#if BBN || SUN
extern Msgh * rmq;
#endif
#endif DLM

print_queues ()
{
	Msgh * msg;

	dprintf ( "PMQ\n" );

	showmsg_head ();

    if ( ! l_ishead_macro ( pmq ) )
		_pprintf("pmq header %x has been corrupted\n", pmq );
	else
	{
		for ( msg = (Msgh *) l_next_macro ( pmq );
			  ! l_ishead_macro ( msg );
		  		msg = (Msgh *) l_next_macro ( msg ) )
		{
			showmsg ( msg );
		}
	}

#ifdef DLM
#if BBN || SUN
	dprintf ( "RMQ\n" );

	showmsg_head ();

	if ( ! l_ishead_macro ( rmq ) )
		_pprintf("rmq header %x has been corrupted\n", rmq );
	else
	{
		for ( msg = (Msgh *) l_next_macro ( rmq );
			  ! l_ishead_macro ( msg );
		  		msg = (Msgh *) l_next_macro ( msg ) )
		{
			showmsg ( msg );
		}
	}
#endif
#endif DLM

#ifdef MARK3_OR_BBN
	dprintf ( "\n" );
	dprintf ( "STDOUT Q\n" );

	showmsg_head ();

	if ( ! l_ishead_macro ( stdout_q ) )
		_pprintf ( "stdout_q header %x has been corrupted\n", stdout_q );
	else
	{
		for ( msg = (Msgh *) l_next_macro ( stdout_q );
			  ! l_ishead_macro ( msg );
		  		msg = (Msgh *) l_next_macro ( msg ) )
		{
			showmsg ( msg );
		}
	}
#endif
}

FUNCTION send_e_from_q ()
/* send emergbuf out if it's in the pmq */
{
	Msgh        *msg;
	int         len,node,res;

#ifndef MARK3
#ifdef PARANOID
	if  ( ! l_ishead_macro ( pmq ) )
	{	
		twerror ( "pmq header %x is corrupted\n", pmq );
		tester();
	}
#endif PARANOID
	for (msg = (Msgh *) l_next_macro(pmq);
		!l_ishead_macro(msg); msg = (Msgh *) l_next_macro(msg))
		{       /* loop through pmq looking for emergbuf */
		if (msg == emergbuf)
			{   /* found emergbuf here */
#ifdef BBN
			if ( msg->low.to_node == CP )
				node = 0;    /* CP is node 0 */
			else
				node = msg->low.to_node & 127;
#else
			node = msg->low.to_node & 127;
#endif
			len = msg->txtlen + sizeof ( Msgh );
			if (node != tw_node_num)
				{       /* only handle this case for now */
				/* send out the message */
				res = send_message ( msg, len, node, NORMAL_MSG );

				if (res == -1)
					break;      /* send buffs may be full */

				if ( res != len )
					{   /* only partial send */
					_pprintf ( "sysbuf: res %d != len %d\n", res, len );
					tester ();
					}
				l_remove(msg);
				destroy_msg(msg);
				messages_to_send--;
				}       /* if (node != tw_node_num) */
			else
				{	/* sending emergbuf on node */
				_pprintf("send_e_from_q: on node send %x\n",msg);
				tester();
				}
			break;      /* stop looking in pmq */
			}   /* if (msg == emergbuf) */
		}       /* end of pmq--hope something happened */
#endif
}  /* send_e_from_q */

FUNCTION send_from_q ()
{
	register Msgh * msg, * next_msg;
	register int len, node, res;
	int not_done_yet;
	extern int mlog;

  Debug

#ifdef MARK3
	while ( acks_queued )
	{
		if ( qackst[ack_q_head] != DONE )
			break;

		acks_queued--;

		ack_q_head++;
		if ( ack_q_head >= MAX_QACKS )
			ack_q_head = 0;
	}
#else SUN_OR_TRANSPUTER
#ifndef BBN
	while ( acks_queued )
	{
		acks_queued--;
/* it is already reversed now
		node = qack[ack_q_head].from_node;
*/
		node = qack[ack_q_head].low.to_node;
		res = send_message ( (char *) &qack[ack_q_head], sizeof(Ack_msg),
								node, ACK_MSG );
		if ( res == -1 )
		{
			acks_queued++;
			return;
		}
		else
		{
			ack_q_head++;
			if ( ack_q_head >= MAX_QACKS )
				ack_q_head = 0;

			if ( res != (sizeof(Ack_msg)) )
			{
				_pprintf ( "send_from_q: %d = res != (sizeof(Ack_msg))\n",
					res );
				tester ();
			}
		}
	}
#endif
#endif

	if ( brdcst_msg != NULL )
	{  /* handle pending broadcast first */
#ifdef BRDCST_ABLE
		if ( tw_num_nodes == 1 )
		{  /* only one node--don't bother */
			rm_msg = brdcst_msg;
			brdcst_msg = NULL;
			messages_to_send--;
		}
		else
		{
			len = brdcst_msg->txtlen + sizeof ( Msgh );

#ifdef MICROTIME
#ifndef BBN
			if ( mlog )
			{
				MicroTime ();
				msg->msgtimef = node_cputime;
			}
#endif
#else
#ifdef MARK3
			if ( mlog )
			{
				mark3time ();
				brdcst_msg->msgtimef = node_cputime;
			}
#endif
#endif
#ifdef MARK3
			if ( ! islocked_macro ( brdcst_msg ) )
			{
				send_message_fast ( brdcst_msg, len, ALL, NORMAL_MSG,
					 &brdcst_msg->low.type);
				l_insert ( l_prev_macro ( inuse_messages ), brdcst_msg );
				entcpy ( brdcst_buf, brdcst_msg, len );
				lock_macro ( brdcst_buf );
				rm_msg = brdcst_buf;
			}
			else
			{
				send_message ( brdcst_msg, len, ALL, NORMAL_MSG );
				rm_msg = brdcst_msg;
			}
			brdcst_msg = NULL;
			messages_to_send--;
#else
			res = send_message ( brdcst_msg, len, ALL, NORMAL_MSG );     /* send it */

			if ( res != -1 )
			{   /* success */
				rm_msg = brdcst_msg;
				brdcst_msg = NULL;
				messages_to_send--;
			}
#endif
		}
#else   /* not BRDCST_ABLE */
		not_done_yet = FALSE;

		len = brdcst_msg->txtlen + sizeof ( Msgh );

		for ( node = 0; node < tw_num_nodes; node++ )
		{
			if ( brdcst_flag[node] != 0 )
			{
				brdcst_msg->low.to_node = node;

				res = send_message ( brdcst_msg, len, node, NORMAL_MSG );

				if ( res == -1 )
					not_done_yet = TRUE;
				else
				{
					brdcst_flag[node] = 0;

					if ( res != len )
					{
						_pprintf ( "send_from_q: res %d != len %d\n", res, len );
						tester ();
					}
				}
			}
		}
		if ( not_done_yet == FALSE
		&&   rm_msg == NULL )
		{
			rm_msg = brdcst_msg;
			brdcst_msg = NULL;
			messages_to_send--;
		}
#endif
	}  /* if brdcst_msg != NULL */

#ifdef MARK3_OR_BBN
	if ( ! no_stdout )
		send_stdout_msg ();     /* handle stdout msg queue */
#endif

	if ( brdcst_msg != NULL )
		return;

	/* here if no more pending broadcasts */
	for ( msg = (Msgh *) l_next_macro ( pmq );
			  ! l_ishead_macro ( msg );
		  msg = next_msg )
	{
		next_msg = (Msgh *) l_next_macro ( msg );

		len = msg->txtlen + sizeof ( Msgh );
#ifdef BBN
		if ( msg->low.to_node == CP )
		   node = 0;    /* CP is node 0 */
		else
		   node = msg->low.to_node & 127;
#else
		node = msg->low.to_node & 127;
#endif

		if ( node == tw_node_num )
		{  /* message to this node */
			if ( rm_msg != NULL )
				continue;  /* skip this msg if rm_msg full */

			if (msg == emergbuf)
				{  /* uh-oh, emergbuf will end up in rmq */
				_pprintf("Emergbuf going to rmq %x\n",emergbuf);
				tester();
				}
			else
				rm_msg = msg;       /* else short circuit the send process */

#if 0
			if ( ! ( msg->flags & ( SYSMSG | MOVING ) ) &&
				gtVTime ( min_msg_time, msg->sndtim ))
				min_msg_time = msg->sndtim;     /* update min_msg_time */
#endif

			l_remove ((List_hdr *)  msg );
			messages_to_send--;
		}
		else
		{  /* send to remote node */
#ifndef BBN
			if ( isanti_macro ( msg ) && acks_pending < max_neg_acks )
				;
			else
			if ( ! issys_macro ( msg )
			&&   acks_pending >= max_acks )
				break;
#endif
#ifdef MICROTIME
			if ( mlog )
			{
				MicroTime ();
				msg->msgtimef = node_cputime;
			}
#else
#ifdef MARK3
			if ( mlog )
			{
				mark3time ();
				msg->msgtimef = node_cputime;
			}
#endif
#endif
#ifdef MARK3
			if ( ! islocked_macro ( msg ) )
				send_message_fast ( msg, len, node, NORMAL_MSG, &msg->low.type);
			else
				send_message ( msg, len, node, NORMAL_MSG );
#else
			/* send out the message */
			res = send_message ( msg, len, node, NORMAL_MSG );

			if ( res == -1 )
			{
				break;  /* some kind of error */
			}

			if ( res != len )
			{   /* only partial send */
				_pprintf ( "send_from_q: res %d != len %d\n", res, len );
				tester ();
			}
#endif
			if ( !(msg->flags & (SYSMSG|MOVING) )
				&& (strcmp ( msg->rcver, "$IH" ) != 0) )
				log_ack_pending ( msg, node );  /* record an ack pending */

			l_remove ( msg );   /*remove msg from queue */

#ifdef MARK3
			if ( ! islocked_macro ( msg ) )
				l_insert ( l_prev_macro ( inuse_messages ), msg );
			else
#endif
			destroy_msg ( msg );        /* deallocate msg */
			messages_to_send--;
		}
	}   /* go through the whole queue */
}  /* send_from_q */

#ifdef MARK3
FUNCTION send_message_fast ( buf, len, dest, type, status )

	char * buf;
	int len, dest, type, *status;
{
	int iret;

#ifdef TIMING
	start_timing ( SYSTEM_TIMING_MODE );
#endif

	if ( dest != CP && dest != ALL )
		dest += node_offset;

	LEDS ( 2 );
	send.buf  = (int *)buf;
	send.mlen = len;
	send.dest = dest;
	send.type = type;
	iret = send_msg ( &send, status );
	if ( iret != OK )
	{
		_pprintf ( "ERROR: send_msg returned %d\n", iret );
		tester ();
	}

#ifdef TIMING
	stop_timing ();
#endif
	return ( iret );
}
#endif /* MARK3 */

/*The following comment makes lint shut up.  Please do not delete it. */
/*ARGSUSED*/
FUNCTION send_message ( buf, len, dest, type )

	char * buf;
	int len, dest, type;
{
	int iret;
#ifdef BBN
	MSG_STRUCT  message_struct;
#endif
#ifdef SUN
	MSG_STRUCT  message_struct;
#endif

#ifdef TIMING
if ( ltSTime ( gvt.simtime, posinfPlus1.simtime ) )
	start_timing ( SYSTEM_TIMING_MODE );
#endif

#ifdef TRANSPUTER

	xsend ( buf, len, dest, type );

	/*  
	send_from_q's ! BRDCST_ABLE part is patterned on the behavior of the
	Sun version of send_message.  To make the Transputer code compatible with
	that, iret will be set to the value that indicates success when run on the
	SUN
	*/

	iret = len; 

#endif  /* TRANSPUTER */

#ifdef MARK3

	if ( dest != CP && dest != ALL )
		dest += node_offset;

	LEDS ( 2 );
	send.buf  = (int *)buf;
	send.mlen = len;
	send.dest = dest;
	send.type = type;
	iret = send_msg_w ( &send );
	if ( iret != OK )
	{
		_pprintf ( "ERROR: send_msg_w returned %d\n", iret );
		tester ();
	}
#endif

#if BBN || SUN
	message_struct.buf = buf;
	message_struct.mlen = len;
	message_struct.dest = dest;
	message_struct.source = tw_node_num;
	message_struct.type = type;

	iret = send_msg ( &message_struct );        /* send it on out */
#endif

#ifdef TIMING
if ( ltSTime ( gvt.simtime, posinfPlus1.simtime ) )
	stop_timing ();
#endif

	return ( iret );
}

log_ack_pending ( msg, node )

	Msgh * msg;
	Int node;
{
#ifndef BBN
	register int i;

	for ( i = 0; i < MAX_ACKS; i++ )
		if ( ! ack[i].busy )
			break;

	if ( i == MAX_ACKS )
	{
		_pprintf ( "log_ack_pending: you blew it dummy!\n" );
		crash ();
	}

	/* save in ack pending array */
	ack[i].busy = TRUE;
	ack[i].node = node;
	ack[i].num  = msg->gid.num;
	ack[i].time = msg->sndtim;

	acks_pending++;
#endif

#ifdef PARANOID
	if (ltVTime(min_msg_time,gvt))
	{
		twerror("log_ack_pending: min_msg_time %f < gvt %f at start of routine\n",      
						min_msg_time.simtime,gvt.simtime);
		tester();
	}
#endif

   if ( gtVTime ( min_msg_time, msg->sndtim ) &&
	   strcmp ( msg->rcver, "$IH") != 0  )
		min_msg_time = msg->sndtim;     /* update min_msg_time */

#if PARANOID
	if (ltVTime(min_msg_time,MinLvt) &&
		ltVTime(MinLvt,posinfPlus1) &&
		gvt.simtime > 0.0 &&
		strcmp(msg->rcver,"$IH") != 0)
	{
		twerror("log_ack_pending: setting min_msg_time %f < MinLvt %f\n",
						min_msg_time.simtime,MinLvt.simtime);
		showmsg(msg);
		tester();
	}
#endif

	if (ltVTime(min_msg_time,gvt))
	{
		twerror("log_ack_pending: setting min_msg_time %f < gvt %f\n",
						min_msg_time.simtime,gvt.simtime);
		showmsg(msg);
		tester();
	}
}

destroy_msg ( msg )

	Msgh * msg;
{
#if PARANOID
	List_hdr    *l;
#endif
	if ( islocked_macro ( msg ) )
		{
#if PARANOID
		l = (List_hdr*)msg - 1;
		if ((l->next != l) || (l->prev !=l))
			{
			_pprintf("destroy_msg: locked but not released %x\n",msg);
			tester();
			}
#endif
		unlock_macro ( msg );
		}
	else
		l_destroy ( msg );
}

#ifdef CHECKSUM
int checksum ( tw_msg )

	Msgh * tw_msg;
{
	register Byte * pointer;
	register int counter;
	register int sum;

	pointer = ( (char *)&tw_msg->checksum ) + sizeof ( tw_msg->checksum );
	counter = sizeof ( Msgh ) - ( pointer - (char *)tw_msg ) + tw_msg->txtlen;
	sum = 0;

	while ( counter-- )
	{
		sum += *pointer++;
	}

	return ( sum );
}
#endif
@


1.11
log
@debugging code, plus a bug fix (PLR)
@
text
@d7 3
d384 1
a384 1
#ifdef BBN
d386 1
a386 1
#endif BBN
d410 1
a410 1
#ifdef BBN
d426 1
a426 1
#endif BBN
d494 5
d746 2
a747 1
			if ( ! ( msg->flags & ( SYSMSG | MOVING ) ) )
@


1.10
log
@Fix new bug in Mark3 code.
@
text
@d7 3
d394 5
a398 1
	for ( msg = (Msgh *) l_next_macro ( pmq );
d400 4
a403 3
		  msg = (Msgh *) l_next_macro ( msg ) )
	{
		showmsg ( msg );
d412 5
a416 1
	for ( msg = (Msgh *) l_next_macro ( rmq );
d418 4
a421 3
		  msg = (Msgh *) l_next_macro ( msg ) )
	{
		showmsg ( msg );
d432 5
a436 1
	for ( msg = (Msgh *) l_next_macro ( stdout_q );
d438 4
a441 3
		  msg = (Msgh *) l_next_macro ( msg ) )
	{
		showmsg ( msg );
d453 7
d490 1
a490 1
				}       /* if (node != tw_node_num)
d674 1
a674 1
				break;  /* skip this msg if rm_msg full */
@


1.9
log
@New copyright notice.
@
text
@d7 3
d180 7
a186 1
	||   msg->low.type != ACK_MSG )
a296 1
	int status;
d310 1
a310 1
	send_message_fast ( &qack[cc], sizeof(Ack_msg), node, ACK_MSG, &status );
a475 1
	int status;
d559 2
a560 1
				send_message_fast ( brdcst_msg, len, ALL, NORMAL_MSG, &status );
d695 1
a695 1
				send_message_fast ( msg, len, node, NORMAL_MSG, &status );
@


1.8
log
@Allow sun version to send zero length messages.
@
text
@d1 4
d7 3
a38 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.7
log
@1. Modified Sun version to support signal driven sockets.
2. Removed mistuff, change d 128 to IH_NODE, other numbers to constants
3. MicroTime support added.
4. Modified Ack_msg a bit.
@
text
@d3 6
a763 12
	LowLevelMsgH junk;

	if ( len == 0 )
	{
		buf = (char *) &junk;
		len = sizeof ( junk );

		junk.to_node = dest;
		junk.from_node = tw_node_num;
		junk.type = type;
		junk.length = len;
	}
@


1.6
log
@Call tester() if emergbuf goes to rmq.
@
text
@d3 3
d165 3
a167 3
	if ( msg->mistuff[0] != node
	|| ( msg->mistuff[1] != tw_node_num && msg->mistuff[1] != 128 && msg->mistuff[1] != 0 )
	||   msg->mistuff[2] != 0 )
d210 2
a211 2
	if ( msg->to_node == 128 )
		msg->to_node = 0;
d214 2
a215 2
	if ( msg->from_node != tw_node_num
	||   msg->to_node != node )
d278 2
d283 5
a287 2
	((Ack_msg *)msg)->ack_flag = 1;
	((Ack_msg *)msg)->num = msg->gid.num;
d291 2
a292 2
	queack ( msg );
	send_message_fast ( &qack[cc], sizeof(Ack_msg), node, 0, &qackst[cc] );
d294 1
a294 1
	cc = send_message ( (char *) msg, sizeof(Ack_msg), node, 0 );
d296 2
a297 3
		queack ( msg );
	else
	if ( cc != sizeof(Ack_msg) )
d423 1
a423 1
			if ( msg->mistuff[1] == CP )
d426 1
a426 1
				node = msg->mistuff[1] & 127;
d428 1
a428 1
			node = msg->mistuff[1] & 127;
d434 1
a434 1
				res = send_message ( msg, len, node, 0 );
d458 1
d481 1
d483 2
d486 1
a486 1
								node, 0 );
d498 1
a498 1
			if ( res != 8 )
d500 2
a501 1
				_pprintf ( "send_from_q: res != 8\n", res );
d522 9
d537 3
a539 1

d542 1
a542 2
				send_message_fast ( brdcst_msg, len, ALL, 0,
						&brdcst_msg->mistuff[4] );
d550 1
a550 1
				send_message ( brdcst_msg, len, ALL, 0 );
d556 1
a556 1
			res = send_message ( brdcst_msg, len, ALL, 0 );     /* send it */
d575 1
a575 1
				res = send_message ( brdcst_msg, len, node, 0 );
d577 2
d620 1
a620 1
		if ( msg->mistuff[1] == CP )
d623 1
a623 1
		   node = msg->mistuff[1] & 127;
d625 1
a625 1
		node = msg->mistuff[1] & 127;
d660 7
d673 3
a675 1

d677 1
a677 1
				send_message_fast ( msg, len, node, 0, &msg->mistuff[4] );
d679 1
a679 1
				send_message ( msg, len, node, 0 );
d682 1
a682 1
			res = send_message ( msg, len, node, 0 );
d685 1
d687 1
a754 1
	Msgh * msg;
d756 3
d760 12
d810 1
a810 1
#ifdef BBN
d814 1
a814 1
	message_struct.source = miparm.me;
a817 39

	msg = message_struct.buf;
	if ( type == EMSG && ! ( msg->flags & MOVING) &&
	ltVTime(msg->sndtim,gvt))
	{
		twerror("send_message: pre-gvt msg going into send_buff, vt %f\n",
				msg->sndtim.simtime);
		showmsg( message_struct.buf);
		tester();
	}
#endif

#ifdef SUN
	iret = write ( msg_ochan[dest], buf, len );

	if ( iret != len && iret != -1 )
	{
		register int res, i = 0;

		for ( ;; )
		{
			res = write ( msg_ochan[dest], buf+iret, len-iret );

			if ( res != -1 )
			{
				iret += res;

				if ( iret == len )
					break;
			}

			if ( ++i == 1000 )
			{
				_pprintf ( "send_message stuck writing to node %d\n", dest );

				i = 0;
			}
		}
	}
@


1.5
log
@Tab conversion.
@
text
@d2 4
a5 1
 * $Log:        msgcntl.c,v $
d609 7
a615 1
			rm_msg = msg;       /* else short circuit the send process */
@


1.4
log
@1.  Add some PARANOID checks.
2.  Add send_e_from_q() for emergbuf.
@
text
@d2 5
a6 1
 * $Log:	msgcntl.c,v $
d18 1
a18 1
char msgcntl_id [] = "@@(#)msgcntl.c	1.48\t10/2/89\t15:02:31\tTIMEWARP";
d20 3
a22 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d28 4
a31 4
	msgcntl.c contains the low-level message sending routines that get
	messages from the tester output queue to the underlying message
	delivery system.  Acks are also largely handled by routines in this
	module.
d35 3
a37 3
	rcvmsg(msg,node) - check an incoming message's validity
		Parameters - Msgh * msg, Int node
		Return - Always returns zero
d39 3
a41 3
	print_acks() - print the contents of the acks table
		Parameters - none
		Return - Always returns zero
d43 3
a45 3
	rcvack(msg,node) - remove an ack from the acks table
		Parameters - Ack_msg  *msg, Int node
		Return - Always returns zero
d47 3
a49 3
	queack(msg,node) - list an ack as outstanding
		Parameters - Msgh * msg, Int node
		Return - Always returns zero
d51 3
a53 3
	sndack(msg,node) - send an ack
		Parameters - Msgh * msg, Int node
		Return - Always returns zero
d55 4
a58 4
	enq_msg(msg) - put an outgoing message in the queue for its
			destination node
		Parameters - Msgh * msg
		Return - Always returns zero
d60 3
a62 3
	print_queues() - print the queues of messages going out to other nodes
		Parameters - none
		Return - Always returns zero
d64 4
a67 4
	send_from_q() - send out any acks, broadcast messages, or normal 
			messages going to other nodes
		Parameters - none
		Return - Always returns zero
d69 4
a72 4
	log_ack_pending(msg,node) - make an entry for a message's outstanding
			ack in the acks table
		Parameters - Msgh * msg, Int node
		Return - zero, or crash
d74 3
a76 3
	destroy_msg(msg) - get rid of a message
		Parameters - Msgh *msg
		Return - Always returns zero
d78 3
a80 3
	checksum(tw_msg) - compute a checksum for a message
		Parameters - Msgh * tw_msg
		Return - the checksum
d84 3
a86 3
	rcvmsg() is  a checking function called by read_the_mail() and
	other routines when they are in PARANOID mode.  It checks the
	validity of certain message fields.
d88 1
a88 1
	print_acks() prints the table of outstanding acknowledgements.
d90 2
a91 2
	rcvack() removes an ack's entry from the table of outstanding
	acknowledgements.
d93 1
a93 1
	queack() puts an entry in the acknowledgement queue.
d95 2
a96 2
	sndack() calls send_message() to ship off an acknowledgement.
	The entry in the acknowledgement queue is made by log_ack_pending().
d98 4
a101 4
	enq_msg() puts an entry for an outgoing message into a node's 
	list in the pmq[] table.  System messages are put before the first
	non-system message, and regular messages are put in in send time 
	order, after all system messages.  
d103 2
a104 2
	print_queues() prints the queue kept for each node in the local
	pmq[] table.  
d106 14
a119 14
	send_from_q(), if we're not on a Mark3, first tries to use
	send_message(0 to send out any queued acks.  Whatever machine
	we're on, if there is a message to be broadcast, and this node
	is not the only node participating in the simulation, call 
	send_message() to send it out.  If BRDCST_ABLE is set, indicating
	a low level broadcast ability, just send it out once.  If there is
	no low level broadcast ability, loop, calling send_message() for
	each node.  After broadcast messages are taken care of, call
	send_stdout_msg(), if necessary.  Then run through all entries in
	the pmq[] array.  For each, look at each message in the queue of
	messages to be sent to the entry's node.  If there aren't already
	too many acks outstanding, call send_message() to send it, and
	go on to the next message.  Remove and destroy any message that
	got sent.
d121 2
a122 2
	log_ack_pending() finds an unused entry in the ack[] array, and
	fills it with an entry for the message in question.
d124 1
a124 1
	destroy_msg() gets rid of a message's storage by calling l_destroy().
d126 1
a126 1
	checksum() computes a checksum for a message.
d154 2
a155 2
    Msgh * msg;
    Int node;
d159 8
a166 8
    if ( msg->mistuff[0] != node
    || ( msg->mistuff[1] != tw_node_num && msg->mistuff[1] != 128 && msg->mistuff[1] != 0 )
    ||   msg->mistuff[2] != 0 )
    {
	_pprintf ( "Bad Msg from Node %d ", node );
	_pprintf ( "%.8x %.8x\n", *((int *)msg), *(((int*)msg)+1) );
        showmsg(msg);
        tester();
d168 3
a170 3
	tester ();
	dump_socket ( node );
	tester ();
d172 1
a172 1
    }
d178 1
a178 1
    _pprintf ( "messages_to_send = %d\n", messages_to_send );
d180 1
a180 1
    int i;
d182 2
a183 2
    _pprintf ( "acks_pending = %d, messages_to_send = %d\n",
		acks_pending, messages_to_send );
d185 4
a188 4
    for ( i = 0; i < MAX_ACKS; i++ )
	if ( ack[i].busy )
	    _pprintf ( "node %d num %d time %f\n",
		ack[i].node, ack[i].num, ack[i].time.simtime );
d195 2
a196 2
    Ack_msg * msg;
    Int node;
d198 1
a198 1
    register int i;
d202 1
a202 1
    rcvack_cnt++;
d204 2
a205 2
    if ( msg->to_node == 128 )
	msg->to_node = 0;
d208 5
a212 5
    if ( msg->from_node != tw_node_num
    ||   msg->to_node != node )
    {
	_pprintf ( "Bad Ack from Node %d ", node );
	_pprintf ( "%.8x %.8x\n", *((int *)msg), *(((int*)msg)+1) );
d215 3
a217 3
	tester ();
	dump_socket ( node );
	tester ();
d219 1
a219 1
    }
d222 7
a228 7
    for ( i = 0; i < MAX_ACKS; i++ )
    {
	if ( ack[i].busy
	&&   ack[i].node == node
	&&   ack[i].num  == msg->num )
	    break;
    }
d230 11
a240 11
    if ( i < MAX_ACKS )
    {
	ack[i].busy = FALSE;
	acks_pending--;
    }
    else
    {
	_pprintf ( "ack not found %d %d\n", node, msg->num );
	print_acks ();
	tester ();
    }
d246 1
a246 1
    Msgh * msg;
d250 3
a252 3
    if ( acks_queued < MAX_QACKS )
    {
	acks_queued++;
d254 1
a254 1
	qack[ack_q_tail++] = * (Ack_msg *) msg;
d256 8
a263 8
	if ( ack_q_tail >= MAX_QACKS )
	    ack_q_tail = 0;
    }
    else
    {
	_pprintf ( "Too many qacks\n" );
	tester ();
    }
d268 2
a269 2
    Msgh * msg;
    Int node;
d271 1
a271 1
    int cc;
d275 2
a276 2
    ((Ack_msg *)msg)->ack_flag = 1;
    ((Ack_msg *)msg)->num = msg->gid.num;
d279 3
a281 3
    cc = ack_q_tail;
    queack ( msg );
    send_message_fast ( &qack[cc], sizeof(Ack_msg), node, 0, &qackst[cc] );
d283 6
a288 6
    cc = send_message ( (char *) msg, sizeof(Ack_msg), node, 0 );
    if ( cc == -1 )
	queack ( msg );
    else
    if ( cc != sizeof(Ack_msg) )
	printf ( "sndack: cc = %d\n", cc );
d296 1
a296 1
    register Msgh * msg;
d298 1
a298 1
    register Msgh * next, * prev;
d300 9
a308 8
    if ( issys_macro ( msg ) )
    {  /* here if system message */
	for ( next = pmq, prev = (Msgh *) l_next_macro ( next );
				! l_ishead_macro ( prev );
	      next = prev, prev = (Msgh *) l_next_macro ( next ) )
	{  /* position to first non system message */
	    if ( ! issys_macro ( prev ) )
		break;
d310 9
a318 10
    }
    else
    if ( isanti_macro ( msg ) )
    {  /* it's a negative message */
	for ( next = pmq, prev = (Msgh *) l_next_macro ( next );
				! l_ishead_macro ( prev );
	      next = prev, prev = (Msgh *) l_next_macro ( next ) )
	{
	    if ( issys_macro ( prev ) )
		continue;	/* bypass system messages */
d320 2
a321 2
	    if ( isposi_macro ( prev ) )
		break;		/* stop at first regular message */
d323 3
a325 2
	    if ( ltVTime ( msg->sndtim, prev->sndtim ) )
		break;		/* or when past the q's send time */
d327 8
a334 9
    }
    else
    {  /* regular message--go through queue backwards */
	for ( next = (Msgh *) l_prev_macro ( pmq );
		   ! l_ishead_macro ( next );
	      next = (Msgh *) l_prev_macro ( next ) )
	{
	    if ( issys_macro ( next ) )
		break;	/* stop at first system message */
d336 2
a337 2
	    if ( isanti_macro ( next ) )
		break;	/* or first negative message */
d339 3
a341 2
	    if ( geVTime ( msg->sndtim, next->sndtim ) )
		break;	/* or when past the q's send time */
a342 1
    }
d344 1
a344 1
    l_insert ( next, msg );	/* put this message in the queue */
d346 1
a346 1
    messages_to_send++;		/* and increment count */
d357 1
a357 1
    Msgh * msg;
d359 1
a359 1
    dprintf ( "PMQ\n" );
d361 1
a361 1
    showmsg_head ();
d363 6
a368 6
    for ( msg = (Msgh *) l_next_macro ( pmq );
	      ! l_ishead_macro ( msg );
	  msg = (Msgh *) l_next_macro ( msg ) )
    {
	showmsg ( msg );
    }
d372 1
a372 1
    dprintf ( "RMQ\n" );
d374 1
a374 1
    showmsg_head ();
d376 6
a381 6
    for ( msg = (Msgh *) l_next_macro ( rmq );
	      ! l_ishead_macro ( msg );
	  msg = (Msgh *) l_next_macro ( msg ) )
    {
	showmsg ( msg );
    }
d386 2
a387 2
    dprintf ( "\n" );
    dprintf ( "STDOUT Q\n" );
d389 1
a389 1
    showmsg_head ();
d391 6
a396 6
    for ( msg = (Msgh *) l_next_macro ( stdout_q );
	      ! l_ishead_macro ( msg );
	  msg = (Msgh *) l_next_macro ( msg ) )
    {
	showmsg ( msg );
    }
d403 2
a404 2
    Msgh	*msg;
    int		len,node,res;
d407 5
a411 5
    for (msg = (Msgh *) l_next_macro(pmq);
	!l_ishead_macro(msg); msg = (Msgh *) l_next_macro(msg))
	{	/* loop through pmq looking for emergbuf */
    	if (msg == emergbuf)
	    {	/* found emergbuf here */
d413 4
a416 4
	    if ( msg->mistuff[1] == CP )
		node = 0;    /* CP is node 0 */
	    else
		node = msg->mistuff[1] & 127;
d418 1
a418 1
	    node = msg->mistuff[1] & 127;
d420 5
a424 5
	    len = msg->txtlen + sizeof ( Msgh );
	    if (node != tw_node_num)
		{	/* only handle this case for now */
		/* send out the message */
		res = send_message ( msg, len, node, 0 );
d426 2
a427 2
		if (res == -1)
		    break;	/* send buffs may be full */
d429 12
a440 12
		if ( res != len )
		    {   /* only partial send */
		    _pprintf ( "sysbuf: res %d != len %d\n", res, len );
		    tester ();
		    }
		l_remove(msg);
		destroy_msg(msg);
		messages_to_send--;
		}	/* if (node != tw_node_num)
	    break;	/* stop looking in pmq */
	    }	/* if (msg == emergbuf) */
	}	/* end of pmq--hope something happened */
d446 4
a449 4
    register Msgh * msg, * next_msg;
    register int len, node, res;
    int not_done_yet;
    extern int mlog;
d454 4
a457 4
    while ( acks_queued )
    {
	if ( qackst[ack_q_head] != DONE )
	    break;
d459 1
a459 1
	acks_queued--;
d461 4
a464 4
	ack_q_head++;
	if ( ack_q_head >= MAX_QACKS )
	    ack_q_head = 0;
    }
d467 1
a467 7
    while ( acks_queued )
    {
	acks_queued--;
	node = qack[ack_q_head].from_node;
	res = send_message ( (char *) &qack[ack_q_head], sizeof(Ack_msg),
				node, 0 );
	if ( res == -1 )
d469 14
a482 8
	    acks_queued++;
	    return;
	}
	else
	{
	    ack_q_head++;
	    if ( ack_q_head >= MAX_QACKS )
		ack_q_head = 0;
d484 6
a489 5
	    if ( res != 8 )
	    {
		_pprintf ( "send_from_q: res != 8\n", res );
		tester ();
	    }
a490 1
    }
d494 2
a495 2
    if ( brdcst_msg != NULL )
    {  /* handle pending broadcast first */
d497 9
a505 9
	if ( tw_num_nodes == 1 )
	{  /* only one node--don't bother */
	    rm_msg = brdcst_msg;
	    brdcst_msg = NULL;
	    messages_to_send--;
	}
	else
	{
	    len = brdcst_msg->txtlen + sizeof ( Msgh );
d508 5
a512 5
	    if ( mlog )
	    {
		mark3time ();
		brdcst_msg->msgtimef = node_cputime;
	    }
d514 16
a529 16
	    if ( ! islocked_macro ( brdcst_msg ) )
	    {
		send_message_fast ( brdcst_msg, len, ALL, 0,
			&brdcst_msg->mistuff[4] );
		l_insert ( l_prev_macro ( inuse_messages ), brdcst_msg );
		entcpy ( brdcst_buf, brdcst_msg, len );
		lock_macro ( brdcst_buf );
		rm_msg = brdcst_buf;
	    }
	    else
	    {
		send_message ( brdcst_msg, len, ALL, 0 );
		rm_msg = brdcst_msg;
	    }
	    brdcst_msg = NULL;
	    messages_to_send--;
d531 1
a531 1
	    res = send_message ( brdcst_msg, len, ALL, 0 );	/* send it */
d533 6
a538 6
	    if ( res != -1 )
	    {	/* success */
		rm_msg = brdcst_msg;
		brdcst_msg = NULL;
		messages_to_send--;
	    }
d540 3
a542 3
	}
#else	/* not BRDCST_ABLE */
	not_done_yet = FALSE;
d544 1
a544 1
        len = brdcst_msg->txtlen + sizeof ( Msgh );
d546 1
a546 9
	for ( node = 0; node < tw_num_nodes; node++ )
	{
	    if ( brdcst_flag[node] != 0 )
	    {
		res = send_message ( brdcst_msg, len, node, 0 );

		if ( res == -1 )
		    not_done_yet = TRUE;
		else
d548 3
a550 1
		    brdcst_flag[node] = 0;
d552 13
a564 5
		    if ( res != len )
		    {
			_pprintf ( "send_from_q: res %d != len %d\n", res, len );
			tester ();
		    }
d566 7
a572 9
	    }
	}
	if ( not_done_yet == FALSE
	&&   rm_msg == NULL )
	{
	    rm_msg = brdcst_msg;
	    brdcst_msg = NULL;
	    messages_to_send--;
	}
d574 1
a574 1
    }  /* if brdcst_msg != NULL */
d577 2
a578 2
    if ( ! no_stdout )
	send_stdout_msg ();	/* handle stdout msg queue */
d581 2
a582 2
    if ( brdcst_msg != NULL )
	return;
d584 6
a589 6
    /* here if no more pending broadcasts */
    for ( msg = (Msgh *) l_next_macro ( pmq );
	      ! l_ishead_macro ( msg );
	  msg = next_msg )
    {
	next_msg = (Msgh *) l_next_macro ( msg );
d591 1
a591 1
	len = msg->txtlen + sizeof ( Msgh );
d593 4
a596 4
	if ( msg->mistuff[1] == CP )
	   node = 0;	/* CP is node 0 */
	else
	   node = msg->mistuff[1] & 127;
d598 1
a598 1
	node = msg->mistuff[1] & 127;
d601 4
a604 4
	if ( node == tw_node_num )
	{  /* message to this node */
	    if ( rm_msg != NULL )
		break;	/* skip this msg if rm_msg full */
d606 1
a606 1
	    rm_msg = msg;	/* else short circuit the send process */
d609 3
a611 3
	    if ( ! ( msg->flags & ( SYSMSG | MOVING ) ) &&
		gtVTime ( min_msg_time, msg->sndtim ))
		min_msg_time = msg->sndtim;	/* update min_msg_time */
d614 5
a618 5
	    l_remove ((List_hdr *)  msg );
	    messages_to_send--;
	}
	else
	{  /* send to remote node */
d620 6
a625 6
	    if ( isanti_macro ( msg ) && acks_pending < max_neg_acks )
		;
	    else
	    if ( ! issys_macro ( msg )
	    &&   acks_pending >= max_acks )
		break;
d628 5
a632 5
	    if ( mlog )
	    {
		mark3time ();
		msg->msgtimef = node_cputime;
	    }
d634 4
a637 4
	    if ( ! islocked_macro ( msg ) )
		send_message_fast ( msg, len, node, 0, &msg->mistuff[4] );
	    else
		send_message ( msg, len, node, 0 );
d639 2
a640 2
	    /* send out the message */
	    res = send_message ( msg, len, node, 0 );
d642 2
a643 2
	    if ( res == -1 )
		break;	/* some kind of error */
d645 5
a649 5
	    if ( res != len )
	    {	/* only partial send */
		_pprintf ( "send_from_q: res %d != len %d\n", res, len );
		tester ();
	    }
d651 2
a652 2
	    if ( ! ( msg->flags & ( SYSMSG | MOVING ) ) )
		log_ack_pending ( msg, node );	/* record an ack pending */
d654 1
a654 1
	    l_remove ( msg );	/*remove msg from queue */
d657 3
a659 3
	    if ( ! islocked_macro ( msg ) )
		l_insert ( l_prev_macro ( inuse_messages ), msg );
	    else
d661 4
a664 4
	    destroy_msg ( msg );	/* deallocate msg */
	    messages_to_send--;
	}
    }	/* go through the whole queue */
d670 2
a671 2
    char * buf;
    int len, dest, type, *status;
d673 1
a673 1
    int iret;
d676 1
a676 1
    start_timing ( SYSTEM_TIMING_MODE );
d679 2
a680 2
    if ( dest != CP && dest != ALL )
	dest += node_offset;
d682 11
a692 11
    LEDS ( 2 );
    send.buf  = (int *)buf;
    send.mlen = len;
    send.dest = dest;
    send.type = type;
    iret = send_msg ( &send, status );
    if ( iret != OK )
    {
	_pprintf ( "ERROR: send_msg returned %d\n", iret );
	tester ();
    }
d695 1
a695 1
    stop_timing ();
d697 1
a697 1
    return ( iret );
d705 2
a706 2
    char * buf;
    int len, dest, type;
d708 1
a708 1
    int iret;
d710 2
a711 2
    MSG_STRUCT  message_struct;
    Msgh * msg;
d716 1
a716 1
    start_timing ( SYSTEM_TIMING_MODE );
d721 1
a721 1
    xsend ( buf, len, dest, type );
d723 6
a728 6
    /*  
    send_from_q's ! BRDCST_ABLE part is patterned on the behavior of the
    Sun version of send_message.  To make the Transputer code compatible with
    that, iret will be set to the value that indicates success when run on the
    SUN
    */
d730 1
a730 1
    iret = len;	
d732 1
a732 1
#endif	/* TRANSPUTER */
d736 2
a737 2
    if ( dest != CP && dest != ALL )
	dest += node_offset;
d739 11
a749 11
    LEDS ( 2 );
    send.buf  = (int *)buf;
    send.mlen = len;
    send.dest = dest;
    send.type = type;
    iret = send_msg_w ( &send );
    if ( iret != OK )
    {
	_pprintf ( "ERROR: send_msg_w returned %d\n", iret );
	tester ();
    }
d753 5
a757 5
    message_struct.buf = buf;
    message_struct.mlen = len;
    message_struct.dest = dest;
    message_struct.source = miparm.me;
    message_struct.type = type;
d759 1
a759 1
    iret = send_msg ( &message_struct );	/* send it on out */
d761 9
a769 9
    msg = message_struct.buf;
    if ( type == EMSG && ! ( msg->flags & MOVING) &&
    ltVTime(msg->sndtim,gvt))
    {
	twerror("send_message: pre-gvt msg going into send_buff, vt %f\n",
		msg->sndtim.simtime);
	showmsg( message_struct.buf);
	tester();
    }
d773 1
a773 1
    iret = write ( msg_ochan[dest], buf, len );
d775 1
a775 5
    if ( iret != len && iret != -1 )
    {
	register int res, i = 0;

	for ( ;; )
d777 1
a777 1
	    res = write ( msg_ochan[dest], buf+iret, len-iret );
d779 3
a781 3
	    if ( res != -1 )
	    {
		iret += res;
d783 3
a785 3
		if ( iret == len )
		    break;
	    }
d787 3
a789 3
	    if ( ++i == 1000 )
	    {
		_pprintf ( "send_message stuck writing to node %d\n", dest );
d791 7
a797 2
		i = 0;
	    }
a798 1
    }
d803 1
a803 1
    stop_timing ();
d806 1
a806 1
    return ( iret );
d811 2
a812 2
    Msgh * msg;
    Int node;
d815 1
a815 1
    register int i;
d817 3
a819 3
    for ( i = 0; i < MAX_ACKS; i++ )
	if ( ! ack[i].busy )
	    break;
d821 5
a825 5
    if ( i == MAX_ACKS )
    {
	_pprintf ( "log_ack_pending: you blew it dummy!\n" );
	crash ();
    }
d827 5
a831 5
    /* save in ack pending array */
    ack[i].busy = TRUE;
    ack[i].node = node;
    ack[i].num  = msg->gid.num;
    ack[i].time = msg->sndtim;
d833 1
a833 1
    acks_pending++;
d837 6
a842 6
    if (ltVTime(min_msg_time,gvt))
    {
        twerror("log_ack_pending: min_msg_time %f < gvt %f at start of routine\n",      
                        min_msg_time.simtime,gvt.simtime);
        tester();
    }
d846 2
a847 2
       strcmp ( msg->rcver, "$IH") != 0  )
	min_msg_time = msg->sndtim;	/* update min_msg_time */
d850 10
a859 10
    if (ltVTime(min_msg_time,MinLvt) &&
	ltVTime(MinLvt,posinfPlus1) &&
	gvt.simtime > 0.0 &&
	strcmp(msg->rcver,"$IH") != 0)
    {
        twerror("log_ack_pending: setting min_msg_time %f < MinLvt %f\n",
                        min_msg_time.simtime,MinLvt.simtime);
        showmsg(msg);
        tester();
    }
d862 7
a868 7
    if (ltVTime(min_msg_time,gvt))
    {
        twerror("log_ack_pending: setting min_msg_time %f < gvt %f\n",
                        min_msg_time.simtime,gvt.simtime);
        showmsg(msg);
        tester();
    }
d873 1
a873 1
    Msgh * msg;
d876 1
a876 1
    List_hdr	*l;
d878 2
a879 2
    if ( islocked_macro ( msg ) )
	{
d881 6
a886 6
	l = (List_hdr*)msg - 1;
	if ((l->next != l) || (l->prev !=l))
	    {
	    _pprintf("destroy_msg: locked but not released %x\n",msg);
	    tester();
	    }
d888 4
a891 4
	unlock_macro ( msg );
	}
    else
	l_destroy ( msg );
d897 1
a897 1
    Msgh * tw_msg;
d899 3
a901 3
    register Byte * pointer;
    register int counter;
    register int sum;
d903 3
a905 3
    pointer = ( (char *)&tw_msg->checksum ) + sizeof ( tw_msg->checksum );
    counter = sizeof ( Msgh ) - ( pointer - (char *)tw_msg ) + tw_msg->txtlen;
    sum = 0;
d907 4
a910 4
    while ( counter-- )
    {
	sum += *pointer++;
    }
d912 1
a912 1
    return ( sum );
@


1.3
log
@A change to make sure IH messages don't contribute to gvt calculation,
and a bug fix to look at the correct flag in a message.
@
text
@d3 4
d133 4
d396 44
d540 2
d604 6
d661 1
a661 1
}
d845 13
d871 3
d875 9
d885 1
@


1.2
log
@use .simtime field as necessary
@
text
@d3 3
a646 1
#ifdef PARANOID
a648 1
#endif
a696 1
#ifdef PARANOID
d698 1
a698 1
    if (msg->mtype == EMSG && ! ( msg->flags & MOVING) &&
a706 1
#endif
d781 2
a782 1
    if ( gtVTime ( min_msg_time, msg->sndtim ) )
a784 1
#ifdef PARANOID
a791 1
#endif
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d650 1
a650 1
if ( ltSTime ( gvt.simtime, posinfPlus1 ) )
d739 1
a739 1
if ( ltSTime ( gvt.simtime, posinfPlus1 ) )
@
