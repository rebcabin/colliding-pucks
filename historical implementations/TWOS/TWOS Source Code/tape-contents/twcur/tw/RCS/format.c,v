head     1.5;
branch   ;
access   ;
symbols  TW2_7:1.5 TW2_6:1.5 TW2_5_1:1.4 TW2_5:1.3 TW2_4_2:1.2 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.5
date     91.11.01.09.35.18;  author reiher;  state Rel;
branches ;
next     1.4;

1.4
date     91.07.17.15.08.17;  author judy;  state Rel;
branches ;
next     1.3;

1.3
date     91.06.03.12.24.09;  author configtw;  state Rel;
branches ;
next     1.2;

1.2
date     90.12.10.10.41.10;  author configtw;  state Rel;
branches ;
next     1.1;

1.1
date     90.08.07.15.38.21;  author configtw;  state Rel;
branches ;
next     ;


desc
@monitor support functions
@


1.5
log
@added strings for system messages related to dynamic load management and
critical path computation (PLR)
@
text
@
/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
/*
 * $Log:	format.c,v $
 * Revision 1.4  91/07/17  15:08:17  judy
 * New copyright notice.
 * 
 * Revision 1.3  91/06/03  12:24:09  configtw
 * Tab conversion.
 * 
 * Revision 1.2  90/12/10  10:41:10  configtw
 * use .simtime field as necessary
 * 
 * Revision 1.1  90/08/07  15:38:21  configtw
 * Initial revision
 * 
*/
char format_id [] = "@@(#)format.c       1.21\t9/27/89\t14:03:48\tTIMEWARP";

/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

#ifndef TRANSPUTER

/*

Purpose:
		
		format.c contains code that takes pointers to data, and flags
		indicating the data's type, and converts the data to human-
		readable formats.  It is used primarily by the monitor.

Functions:

		tod() - return the contents of atime
				Parameters - none
				Return - a pointer to the atime character array

		formhdr(bp,name,caller,level) - set up a string indicating who called
				what function
				Parameters -  char **bp, char *name, char *caller, int level
				Return - Always returns zero

		format(bp,name,data,type,level) - format output of the appropriate type
				Parameters -  char **bp, char *name, int *data,
								int type, int level
				Return -  argument size (currently either 1 or 2)

		form_vtime(bp,vtime) - convert a virtual time to human-readable form
				Parameters - char **bp, VTime vtime
				Return - Always returns zero

Implementation:

		tod() simply returns a constant array address.

		formhdr() takes its last three parameters, produces a string
		describing their values, and puts the string into the place
		pointed to by its first parameter.

		format() has the bulk of the module's code.  formhdr() is
		usually called just before format().  It is called once
		per invocation of monitor() (or whatever other routine is
		formatting data), and produces a header on an output string,
		describing what routine called what other routine.  Then, for
		each parameter in the call being looked at by the monitor,
		format() is invoked once.  The point of format is to build up
		a string containing the name of the data item, and some reasonable
		formatting of its value.  Since the item in question may be a
		structure, this reasonable formatting may not be straightforward.

		format() puts the name it is provided into the string.  If its 
		data field is zero, it then puts "NULL" into the string.  size
		is set to 1.  The remainder of format is a large case statement
		on the type provided as a parameter.

		Going through the various cases in detail would be rather tedious.
		Most of them are fairly straightforward formattings of the
		data in question, printing decimal values for ints, the actual
		strings for strings, etc.  If the data is a virtual time,
		form_vtime() is called to handle it.  If the data is a list
		header, determine if it is a real list header, or just a list
		element header.  In the former case, just indicate that it is
		a list header.  In the latter case, print out several important
		list element fields, such as send time, receive time, sender's
		and receiver's names, etc.  (Apparently, this code is only meant
		to handle the message lists, not other lists, such as the state
		list.)  The message text is also printed, making sure that the
		leading escape character, if any, is converted to the string
		"<ESC>".  World map entries have their names and nodes copied.
		
		Whatever the data type, return size.

		form_vtime() looks to see if the virtual time in question is
		either POSINF or NEGINF.  If so, it produces the strings
		"POSINF" and "NEGINF", respectively.  Otherwise, the virtual
		time is simply converted into an integer.

*/

#include "twcommon.h"
#include "twsys.h"

formhdr ( bp, name, caller )

	char **bp;
	char *name;
	char *caller;
{
	sprintf ( *bp, "%d %s called by %s", miparm.me, name, caller );
	*bp += strlen ( *bp );
}

static char *mname[] = {
		"TYPE0",        /*  0 */
		"TYPE1",        /*  1 */
		"CMSG",         /*  2 */
		"DYNCRMSG",     /*  3 */
		"TYPE4",        /*  4 */
		"TMSG",         /*  5 */
		"EMSG",         /*  6 */
		"DYNDSMSG",     /*  7 */
		"CREATESYS",    /*  8 */
		"GVTSYS",       /*  9 */
		"COMMAND",      /* 10 */
		"CRT_ACK",      /* 11 */
		"SIM_END_MSG",  /* 12 */
		"MIGR_LOG",     /* 13 */
		"XL_STATS",     /* 14 */
		"MONINIT",      /* 15 */
		"TW_ERROR",     /* 16 */
		"TYPE17",       /* 17 */
		"STATEMSG",     /* 18 */
		"STATEACK",     /* 19 */
		"STATENAK",     /* 20 */
		"STATEDONE",    /* 21 */
		"MOVEPHASE",    /* 22 */
		"PHASEACK",     /* 23 */
		"PHASENAK",     /* 24 */
		"PHASEDONE",    /* 25 */
		"MOVEVTIME",    /* 26 */
		"VTIMEACK",     /* 27 */
		"VTIMENAK",     /* 28 */
		"VTIMEDONE",    /* 29 */
		"TYPE30",       /* 30 */
		"TYPE31",       /* 31 */
		"HOMENOTIF",    /* 32 */
		"HOMEASK",      /* 33 */
		"HOMEANS",      /* 34 */
		"HOMECHANGE",   /* 35 */
		"CACHEINVAL",   /* 36 */
		"LOADSYS",      /* 37 */
		"PCREATESYS",   /* 38 */
		"ADDSTATS",     /* 39 */
		"CRITPATH",		/* 40 */
		"CRITSTEP",		/* 41 */
		"CRITEND",		/* 42 */
		"CRIT_LOG",		/* 43 */
		"CRITRM"		/* 44 */
	};

static char *gname[6] = {
	"GVTINIT",          /* 71 */
	"GVTSTART",         /* 72 */
	"GVTACK",           /* 73 */
	"GVTSTOP",          /* 74 */
	"GVTLVT",           /* 75 */
	"GVTUPDATE" };      /* 76 */

extern int ok_to_monitor;
extern char monitor_object[20];

int format ( bp, name, data, type, level )

	char **bp;
	char *name;
	int *data;
	int type;
	int level;
{
	int size = 1;       /* default argument size */

	sprintf ( *bp, " %s =", name );
	*bp += strlen ( *bp );

	if ( data == 0L )
	{
		sprintf ( *bp, " NULL" );
		*bp += strlen ( *bp );
		return ( size );
	}

	switch ( type )
	{
		case 1:                 /* Byte         */

			if ( level > 0 )
			{
				sprintf ( *bp, " %lx", (Byte *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 2:                 /* Int          */

			if ( level > 0 )
			{
				sprintf ( *bp, " %d", *(Int *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 3:                 /* Name         */

			if ( level > 0 )
			{
				sprintf ( *bp, " %s", (Name *)data );
				*bp += strlen ( *bp );

				if ( strcmp ( monitor_object, (Name *)data ) == 0 )
					ok_to_monitor = TRUE;
			}
			break;

		case 4:                 /* VTime        */

			if ( level > 0 )
			{
				form_vtime ( bp, *(VTime *)data );
			}
			size = sizeof ( VTime ) / sizeof ( int );
			break;

		case 5:                 /* Msgh         */

			if ( level > 0 )
			{
				if ( (((List_hdr *)data)-1)->size == 0 )
				{
					sprintf ( *bp, " LIST_HDR" );
					*bp += strlen ( *bp );
				}
				else
				{
					sprintf ( *bp, " %s", mname[((Msgh *)data)->mtype] );
					*bp += strlen ( *bp );
					sprintf ( *bp, " %s", ((Msgh *)data)->snder );
					*bp += strlen ( *bp );
					form_vtime ( bp, ((Msgh *)data)->sndtim );
					sprintf ( *bp, " %s", ((Msgh *)data)->rcver );
					*bp += strlen ( *bp );
					form_vtime ( bp, ((Msgh *)data)->rcvtim );

					if ( strcmp ( monitor_object, ((Msgh *)data)->snder) == 0 )
						ok_to_monitor = TRUE;
					if ( strcmp ( monitor_object, ((Msgh *)data)->rcver) == 0 )
						ok_to_monitor = TRUE;
				}
			}
			break;

		case 6:                 /* Ocb          */

			if ( level > 0 )
			{
				sprintf ( *bp, " %s", ((Ocb *)data)->name );
				*bp += strlen ( *bp );
				form_vtime ( bp, ((Ocb *)data)->svt );

				if ( strcmp ( monitor_object, ((Ocb *)data)->name ) == 0 )
					ok_to_monitor = TRUE;
			}
			break;

		case 7:                 /* STime                */

			if ( level > 0 )
			{
				sprintf ( *bp, " %f", *(STime *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 8:                 /* Gvttype              */

			if ( level > 0 )
			{
				sprintf ( *bp, " %s", gname[*((Gvttype *)data)-GVTINIT] );
				*bp += strlen ( *bp );
			}
			break;

		case 9:                 /* Flag         */

			break;

		case 10:                /* Long         */

			if ( level > 0 )
			{
				sprintf ( *bp, " %ld", *(Long *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 11:                /* Uint         */

			if ( level > 0 )
			{
				sprintf ( *bp, " %x", *(Uint *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 12:                /* Ulong                */

			if ( level > 0 )
			{
				sprintf ( *bp, " %lx", *(Ulong *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 13:                /* Char         */

			if ( level > 0 )
			{
				sprintf ( *bp, " %s", (Char *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 14:                /* State        */

			if ( level > 0 )
			{
				sprintf ( *bp, " %lx", (State *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 15:                /* int          */

			if ( level > 0 )
			{
				sprintf ( *bp, " %d", *(int *)data );
				*bp += strlen ( *bp );
			}
			break;

		case 16:                /* Objloc       */

			if ( level > 0 )
			{
				sprintf ( *bp, " %s", ((Objloc *)data)->name );
				*bp += strlen ( *bp );
				sprintf ( *bp, " %d", ((Objloc *)data)->node );
				*bp += strlen ( *bp );

				if ( strcmp ( monitor_object, ((Objloc *)data)->name ) == 0 )
					ok_to_monitor = TRUE;
			}

		default:

			if ( level > 0 )
			{
				sprintf ( *bp, " type%d", type );
				*bp += strlen ( *bp );
			}
			break;

	}
	return ( size );
}

form_vtime ( bp, vtime )

	char **bp;
	VTime vtime;
{
	if ( eqSTime ( vtime.simtime, posinf.simtime ) )
	{
		sprintf ( *bp, " POSINF" );
		*bp += strlen ( *bp );
	}
	else
	if ( eqSTime ( vtime.simtime, posinfPlus1.simtime ) )
	{
		sprintf ( *bp, " POSINF+1" );
		*bp += strlen ( *bp );
	}
	else
	if ( eqSTime ( vtime.simtime, neginf.simtime ) )
	{
		sprintf ( *bp, " NEGINF" );
		*bp += strlen ( *bp );
	}
	else
	if ( eqSTime ( vtime.simtime, neginfPlus1.simtime ) )
	{
		sprintf ( *bp, " NEGINF+1" );
		*bp += strlen ( *bp );
	}
	else
	{
		sprintf ( *bp, " %.2f", vtime.simtime );
		*bp += strlen ( *bp );
	}
}

#endif
@


1.4
log
@New copyright notice.
@
text
@d7 3
d155 8
@


1.3
log
@Tab conversion.
@
text
@d1 4
d6 4
a9 1
 * $Log:        format.c,v $
@


1.2
log
@use .simtime field as necessary
@
text
@d2 4
a5 1
 * $Log:	format.c,v $
d10 1
a10 1
char format_id [] = "@@(#)format.c	1.21\t9/27/89\t14:03:48\tTIMEWARP";
d12 3
a14 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d21 4
a24 4
	
	format.c contains code that takes pointers to data, and flags
	indicating the data's type, and converts the data to human-
	readable formats.  It is used primarily by the monitor.
d28 3
a30 3
	tod() - return the contents of atime
		Parameters - none
		Return - a pointer to the atime character array
d32 4
a35 4
	formhdr(bp,name,caller,level) - set up a string indicating who called
		what function
		Parameters -  char **bp, char *name, char *caller, int level
		Return - Always returns zero
d37 4
a40 4
	format(bp,name,data,type,level) - format output of the appropriate type
		Parameters -  char **bp, char *name, int *data,
				int type, int level
		Return -  argument size (currently either 1 or 2)
d42 3
a44 3
	form_vtime(bp,vtime) - convert a virtual time to human-readable form
		Parameters - char **bp, VTime vtime
		Return - Always returns zero
d48 1
a48 1
	tod() simply returns a constant array address.
d50 3
a52 3
	formhdr() takes its last three parameters, produces a string
	describing their values, and puts the string into the place
	pointed to by its first parameter.
d54 10
a63 10
	format() has the bulk of the module's code.  formhdr() is
	usually called just before format().  It is called once
	per invocation of monitor() (or whatever other routine is
	formatting data), and produces a header on an output string,
	describing what routine called what other routine.  Then, for
	each parameter in the call being looked at by the monitor,
	format() is invoked once.  The point of format is to build up
	a string containing the name of the data item, and some reasonable
	formatting of its value.  Since the item in question may be a
	structure, this reasonable formatting may not be straightforward.
d65 4
a68 4
	format() puts the name it is provided into the string.  If its 
	data field is zero, it then puts "NULL" into the string.  size
	is set to 1.  The remainder of format is a large case statement
	on the type provided as a parameter.
d70 16
a85 16
	Going through the various cases in detail would be rather tedious.
	Most of them are fairly straightforward formattings of the
	data in question, printing decimal values for ints, the actual
	strings for strings, etc.  If the data is a virtual time,
	form_vtime() is called to handle it.  If the data is a list
	header, determine if it is a real list header, or just a list
	element header.  In the former case, just indicate that it is
	a list header.  In the latter case, print out several important
	list element fields, such as send time, receive time, sender's
	and receiver's names, etc.  (Apparently, this code is only meant
	to handle the message lists, not other lists, such as the state
	list.)  The message text is also printed, making sure that the
	leading escape character, if any, is converted to the string
	"<ESC>".  World map entries have their names and nodes copied.
	
	Whatever the data type, return size.
d87 4
a90 4
	form_vtime() looks to see if the virtual time in question is
	either POSINF or NEGINF.  If so, it produces the strings
	"POSINF" and "NEGINF", respectively.  Otherwise, the virtual
	time is simply converted into an integer.
d99 3
a101 3
    char **bp;
    char *name;
    char *caller;
d103 2
a104 2
    sprintf ( *bp, "%d %s called by %s", miparm.me, name, caller );
    *bp += strlen ( *bp );
d108 38
a145 38
	"TYPE0",	/*  0 */
	"TYPE1",	/*  1 */
	"CMSG",		/*  2 */
	"DYNCRMSG",	/*  3 */
	"TYPE4",	/*  4 */
	"TMSG",		/*  5 */
	"EMSG",		/*  6 */
	"DYNDSMSG",	/*  7 */
	"CREATESYS",	/*  8 */
	"GVTSYS",	/*  9 */
	"COMMAND",	/* 10 */
	"CRT_ACK",	/* 11 */
	"SIM_END_MSG",	/* 12 */
	"MIGR_LOG",	/* 13 */
	"XL_STATS",	/* 14 */
	"MONINIT",	/* 15 */
	"TW_ERROR",	/* 16 */
	"TYPE17",	/* 17 */
	"STATEMSG",	/* 18 */
	"STATEACK",	/* 19 */
	"STATENAK",	/* 20 */
	"STATEDONE",	/* 21 */
	"MOVEPHASE",	/* 22 */
	"PHASEACK",	/* 23 */
	"PHASENAK",	/* 24 */
	"PHASEDONE",	/* 25 */
	"MOVEVTIME",	/* 26 */
	"VTIMEACK",	/* 27 */
	"VTIMENAK",	/* 28 */
	"VTIMEDONE",	/* 29 */
	"TYPE30",	/* 30 */
	"TYPE31",	/* 31 */
	"HOMENOTIF",	/* 32 */
	"HOMEASK",	/* 33 */
	"HOMEANS",	/* 34 */
	"HOMECHANGE",	/* 35 */
	"CACHEINVAL",	/* 36 */
    };
d148 6
a153 6
    "GVTINIT",		/* 71 */
    "GVTSTART",		/* 72 */
    "GVTACK",		/* 73 */
    "GVTSTOP",		/* 74 */
    "GVTLVT",		/* 75 */
    "GVTUPDATE" };	/* 76 */
d160 5
a164 5
    char **bp;
    char *name;
    int *data;
    int type;
    int level;
d166 1
a166 1
    int size = 1;	/* default argument size */
d168 1
a168 6
    sprintf ( *bp, " %s =", name );
    *bp += strlen ( *bp );

    if ( data == 0L )
    {
	sprintf ( *bp, " NULL" );
a169 2
	return ( size );
    }
d171 3
a173 7
    switch ( type )
    {
	case 1:			/* Byte		*/

	    if ( level > 0 )
	    {
		sprintf ( *bp, " %lx", (Byte *)data );
d175 2
a176 2
	    }
	    break;
d178 3
a180 1
	case 2:			/* Int		*/
d182 6
a187 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %d", *(Int *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d189 1
a189 1
	case 3:			/* Name		*/
d191 6
a196 4
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %s", (Name *)data );
		*bp += strlen ( *bp );
d198 1
a198 4
		if ( strcmp ( monitor_object, (Name *)data ) == 0 )
		    ok_to_monitor = TRUE;
	    }
	    break;
d200 4
a203 1
	case 4:			/* VTime	*/
d205 4
a208 6
	    if ( level > 0 )
	    {
		form_vtime ( bp, *(VTime *)data );
	    }
	    size = sizeof ( VTime ) / sizeof ( int );
	    break;
d210 1
a210 1
	case 5:			/* Msgh		*/
d212 6
a217 17
	    if ( level > 0 )
	    {
		if ( (((List_hdr *)data)-1)->size == 0 )
		{
		    sprintf ( *bp, " LIST_HDR" );
		    *bp += strlen ( *bp );
		}
		else
		{
		    sprintf ( *bp, " %s", mname[((Msgh *)data)->mtype] );
		    *bp += strlen ( *bp );
		    sprintf ( *bp, " %s", ((Msgh *)data)->snder );
		    *bp += strlen ( *bp );
		    form_vtime ( bp, ((Msgh *)data)->sndtim );
		    sprintf ( *bp, " %s", ((Msgh *)data)->rcver );
		    *bp += strlen ( *bp );
		    form_vtime ( bp, ((Msgh *)data)->rcvtim );
d219 1
a219 7
		    if ( strcmp ( monitor_object, ((Msgh *)data)->snder) == 0 )
			ok_to_monitor = TRUE;
		    if ( strcmp ( monitor_object, ((Msgh *)data)->rcver) == 0 )
			ok_to_monitor = TRUE;
		}
	    }
	    break;
d221 17
a237 1
	case 6:			/* Ocb		*/
d239 7
a245 5
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %s", ((Ocb *)data)->name );
		*bp += strlen ( *bp );
		form_vtime ( bp, ((Ocb *)data)->svt );
d247 1
a247 4
		if ( strcmp ( monitor_object, ((Ocb *)data)->name ) == 0 )
		    ok_to_monitor = TRUE;
	    }
	    break;
d249 5
a253 1
	case 7:			/* STime		*/
d255 4
a258 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %f", *(STime *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d260 1
a260 1
	case 8:			/* Gvttype		*/
d262 6
a267 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %s", gname[*((Gvttype *)data)-GVTINIT] );
		*bp += strlen ( *bp );
	    }
	    break;
d269 1
a269 1
	case 9:			/* Flag		*/
d271 6
a276 1
	    break;
d278 1
a278 1
	case 10:		/* Long		*/
d280 1
a280 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %ld", *(Long *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d282 1
a282 1
	case 11:		/* Uint		*/
d284 6
a289 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %x", *(Uint *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d291 1
a291 1
	case 12:		/* Ulong		*/
d293 6
a298 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %lx", *(Ulong *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d300 1
a300 1
	case 13:		/* Char		*/
d302 6
a307 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %s", (Char *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d309 1
a309 1
	case 14:		/* State	*/
d311 6
a316 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %lx", (State *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d318 1
a318 1
	case 15:		/* int		*/
d320 6
a325 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %d", *(int *)data );
		*bp += strlen ( *bp );
	    }
	    break;
d327 1
a327 1
	case 16:		/* Objloc	*/
d329 6
a334 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " %s", ((Objloc *)data)->name );
		*bp += strlen ( *bp );
		sprintf ( *bp, " %d", ((Objloc *)data)->node );
		*bp += strlen ( *bp );
d336 1
a336 3
		if ( strcmp ( monitor_object, ((Objloc *)data)->name ) == 0 )
		    ok_to_monitor = TRUE;
	    }
d338 6
a343 1
	default:
d345 3
a347 6
	    if ( level > 0 )
	    {
		sprintf ( *bp, " type%d", type );
		*bp += strlen ( *bp );
	    }
	    break;
d349 11
a359 2
    }
    return ( size );
d364 2
a365 2
    char **bp;
    VTime vtime;
d367 28
a394 28
    if ( eqSTime ( vtime.simtime, posinf.simtime ) )
    {
	sprintf ( *bp, " POSINF" );
	*bp += strlen ( *bp );
    }
    else
    if ( eqSTime ( vtime.simtime, posinfPlus1.simtime ) )
    {
	sprintf ( *bp, " POSINF+1" );
	*bp += strlen ( *bp );
    }
    else
    if ( eqSTime ( vtime.simtime, neginf.simtime ) )
    {
	sprintf ( *bp, " NEGINF" );
	*bp += strlen ( *bp );
    }
    else
    if ( eqSTime ( vtime.simtime, neginfPlus1.simtime ) )
    {
	sprintf ( *bp, " NEGINF+1" );
	*bp += strlen ( *bp );
    }
    else
    {
	sprintf ( *bp, " %.2f", vtime.simtime );
	*bp += strlen ( *bp );
    }
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d364 1
a364 1
    if ( eqSTime ( vtime.simtime, posinf ) )
d370 1
a370 1
    if ( eqSTime ( vtime.simtime, posinfPlus1 ) )
d376 1
a376 1
    if ( eqSTime ( vtime.simtime, neginf ) )
d382 1
a382 1
    if ( eqSTime ( vtime.simtime, neginfPlus1 ) )
@
