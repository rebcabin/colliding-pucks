head     1.17;
branch   ;
access   ;
symbols  TW2_7:1.17 TW2_6:1.16 TW2_5_1:1.13 TW2_5:1.11 TW2_4_2:1.4 TW2_4_1:1.2 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.17
date     91.12.27.08.41.59;  author reiher;  state Rel;
branches ;
next     1.16;

1.16
date     91.11.06.11.10.52;  author configtw;  state Rel;
branches ;
next     1.15;

1.15
date     91.11.04.10.15.40;  author pls;  state Dev;
branches ;
next     1.14;

1.14
date     91.11.01.09.35.58;  author reiher;  state Dev;
branches ;
next     1.13;

1.13
date     91.07.17.15.08.33;  author judy;  state Rel;
branches ;
next     1.12;

1.12
date     91.07.09.13.44.56;  author steve;  state Dev;
branches ;
next     1.11;

1.11
date     91.06.07.15.25.23;  author configtw;  state Rel;
branches ;
next     1.10;

1.10
date     91.06.03.14.27.12;  author configtw;  state Dev;
branches ;
next     1.9;

1.9
date     91.06.03.12.24.16;  author configtw;  state Dev;
branches ;
next     1.8;

1.8
date     91.05.31.13.15.24;  author pls;  state Dev;
branches ;
next     1.7;

1.7
date     91.04.01.15.36.45;  author reiher;  state Dev;
branches ;
next     1.6;

1.6
date     91.03.28.16.15.53;  author configtw;  state Dev;
branches ;
next     1.5;

1.5
date     91.03.25.16.14.46;  author csupport;  state Dev;
branches ;
next     1.4;

1.4
date     90.12.10.10.41.31;  author configtw;  state Rel;
branches ;
next     1.3;

1.3
date     90.11.27.09.32.32;  author csupport;  state Dev;
branches ;
next     1.2;

1.2
date     90.08.16.10.32.19;  author steve;  state Exp;
branches ;
next     1.1;

1.1
date     90.08.07.15.38.26;  author configtw;  state Rel;
branches ;
next     ;


desc
@gvt support routines
@


1.17
log
@Added code to support dynamic window throttling
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	gvt2.c,v $
 * Revision 1.16  91/11/06  11:10:52  configtw
 * Add sequence output for Suns.
 * 
 * Revision 1.15  91/11/04  10:15:40  pls
 * Force gvt display to print sequence numbers.
 * 
 * Revision 1.14  91/11/01  09:35:58  reiher
 * Removed all code relating to the memory out poll flag, changed all 
 * occurrences of miparm.me to tw_node_num, and added a call to the critical
 * path calculation module, if needed
 * 
 * Revision 1.13  91/07/17  15:08:33  judy
 * New copyright notice.
 * 
 * Revision 1.12  91/07/09  13:44:56  steve
 * Added MicroTime support for Sun version. Replace 5 with STATS_DATA and
 * 6 with GVT_DATA.
 * 
 * Revision 1.11  91/06/07  15:25:23  configtw
 * Put oldgvt outside of #if DLM.
 *
 * Revision 1.10  91/06/03  14:27:12  configtw
 * Fix code for DLM off.
 * 
 * Revision 1.9  91/06/03  12:24:16  configtw
 * Tab conversion.
 * 
 * Revision 1.8  91/05/31  13:15:24  pls
 * 1.  Add resendState flag for migration control.
 * 2.  Add PARANOID code to check for scheduler queue misordering.
 * 3.  Don't depend on queue ordering at term time.
 * 
 * Revision 1.7  91/04/01  15:36:45  reiher
 * Added some code to look for gvt going backwards, and to support migration
 * graphics.
 * 
 * Revision 1.6  91/03/28  16:15:53  configtw
 * Put hoglog output in XL_STATS.
 * 
 * Revision 1.5  91/03/25  16:14:46  csupport
 * Add hoglog support.
 * 
 * Revision 1.4  90/12/10  10:41:31  configtw
 * use .simtime field as necessary
 * 
 * Revision 1.3  90/11/27  09:32:32  csupport
 * 1.  check memory_out_time before signaling out-of-memory
 * 2.  go to tester if out of memory
 * 
 * Revision 1.2  90/08/16  10:32:19  steve
 * added page fault counting to systems which support getrusage()
 * the page counting use to be in faults.c which is now unneeded.
 * 
 * Revision 1.1  90/08/07  15:38:26  configtw
 * Initial revision
 * 
*/
char gvt_id [] = "@@(#)gvt2.c    1.9\t10/23/89\t08:53:45\tTIMEWARP";



#include <stdio.h>
#include "twcommon.h"
#include "twsys.h"
#include "machdep.h"

extern VTime min_msg_time;
int gvtCount;

int     resendState = TRUE;     /* set false when state is nak'd */
long run_time, run_time_2;
double seconds;

VTime MinLvt;

int myNum;
int numNodes;
int numFrom, numTo, from[2], to[2];
int Out0, Out1;

int numArrive;
#ifdef GETRUSAGE
static int init_faults = 0;
int total_faults;
#endif
#ifdef DLM
extern int migrGraph;
#endif

int     hlog = 0;
VTime   hlogVTime;
int     maxSlice = 0;           /* maximum object time slice for this node */
Ocb*    maxSliceObj = NULL;     /* object corresponding to maxSlice */
VTime   maxSliceTime;           /* time for above object */
int     sliceTime;              /* time for current slice */

extern long highEpt ;
extern long highestEpt ;
extern long critNode ;
extern long nodesReporting;
extern Name critObject ;
extern long critEnabled ;

/*
   Calculate which nodes send us a GVT start message.  Put the number
   of such nodes into numFrom, and their node numbers into from[].
   Also calculate which nodes we send the GVT start message to, put
   the number of such nodes into numTo, and the node numbers into to[].
   See Steve Bellenot's paper on "Global Virtual Time Algorithms".
*/

FUNCTION gvtcfg()
{
	int Mid0, Mid1, myInv, OutFrom, In0, In1, InTo;
	int pen0, pen1;

	nodesReporting = tw_num_nodes;

	myNum = tw_node_num;          /* this nodes number */
	numNodes = miparm.maxnprc;  /* total number of nodes */

	MinLvt = posinfPlus1;

	numArrive = 0;

	Mid0 = ( numNodes - 1 )/2;
	Mid1 = ( numNodes & 0x01 )? Mid0 : Mid0 + 1;

	/* matching node on other tree */
	myInv = numNodes - myNum - 1;

	/* for binary tree with root 0 */
	Out0 = 2 * myNum + 1;               /* upper child number */
	Out1 = Out0 + 1;                    /* lower child number */
	OutFrom = ( myNum - 1 )/2;          /* parent number */

	/* for binary tree with root numNodes-1 */
	In0 = 2 * myNum - numNodes;         /* upper child number */
	In1 = In0 - 1;                      /* lower child number */
	InTo = ( numNodes + myNum + 1 )/2;  /* parent number */

	for ( pen0 = 1; pen0 < Mid0 + 1; pen0 = 2 * pen0 + 1 )
	{
		;
	}
	pen0 = pen0/2 - 1;
	pen1 = numNodes - pen0 -1;

	/* the two trees can share the bottom row */
	if ( pen1 <= 2 * pen0 + 3 )
	{
		Mid0 = pen1 - 1;
		Mid1 = pen0 + 1;
	}

  Debug

	if ( myNum == 0 )
	{   /* left root */
		numFrom = 0;
	}
	else if ( myNum <= Mid0 )
	{   /* in left tree */
		numFrom = 1;
		from[0] = OutFrom;
	}
	else if ( Mid1 <= In1 )
	{   /* right tree */
		numFrom = 2;
		from[0] = In0;
		from[1] = In1;
	}
	else if ( Mid1 == In0 )
	{   /* extra element between trees (eg 7->11 with 15 nodes) */
		numFrom = 1;
		from[0] = In0;
	}
	else
	{   /* input from matching node on left tree */
		numFrom = 1;
		from[0] = myInv;
	}

	if ( myNum == numNodes - 1 )
	{   /* right root */
		numTo = 0;
	}
	else if ( myNum >= Mid1 )
	{   /* in right tree */
		numTo = 1;
		to[0] = InTo;
	}
	else if ( Mid0 >= Out1 )
	{   /* in left tree */
		numTo = 2;
		to[0] = Out0;
		to[1] = Out1;
	}
	else if ( Mid0 == Out0 )
	{   /* extra element between trees (eg 3->7 with 15 nodes) */
		numTo = 1;
		to[0] = Out0;
	}
	else
	{   /* output to matching node on right tree */
		numTo = 1;
		to[0] = myInv;
	}

}

FUNCTION gvtinterrupt ()
{
  Debug

	gvtstart();
	dispatch();
}

FUNCTION gvtinit ()
{
  Debug

	if ( tw_node_num== 0 )
	{  /* if node 0 initiate gvtinterrupt routine every second */
#ifdef MICROTIME
		schedule_next_gvt();
#else
		timrint ( gvtinterrupt );
#endif
	}
}

FUNCTION gvtmessage ( type, time, dest )

	Int         type;
	VTime       time;
	Int         dest;
{
	Msgh        *p;
	Gvtmsg      *q;

  Debug

	p = sysbuf (); /*SFB maybe sometimes output_buf()??? */
	q = (Gvtmsg *) (p + 1);
	q->msgtype = type;
	q->sender = tw_node_num;
	q->time = time;

	sprintf ( p->snder, "GVT%d", tw_node_num );
	sprintf ( p->rcver, "GVT%d", dest );
	p->sndtim = gvt;
	p->rcvtim = time;

	sysmsg ( GVTSYS, p, sizeof (Gvtmsg), dest );
}

FUNCTION gvtproc ( gvt_message )

	Gvtmsg      *gvt_message;
{

  Debug

#ifdef TIMING
#define GVT_TIMING_MODE 11
	start_timing ( GVT_TIMING_MODE );
#endif

	switch ( gvt_message->msgtype )
	{
		case GVTSTART:          /* command to start a local GVT calculation */
			gvtstart ();
			break;

		case GVTLVT:            /* incoming minimum LVT value */
			gvtlvt (gvt_message->time );
			break;

		case GVTUPDATE:         /* announcement of new GVT value */
			gvtupdate ( gvt_message->time );
			break;
	}

#ifdef TIMING
	stop_timing ();
#endif
}

/* start the gvt calculation process */

FUNCTION gvtstart ( )

{
	int i;

  Debug


	if ( numFrom == 2 )
	{  /* 2 inputs expected--wait for both */
		if ( numArrive == 0 ) 
		{
			numArrive = 1;
			return;             /* if only 1 is here yet */
		}
		else
		{
			numArrive = 0;      /* both have arrived--continue */
		}
	}

	/* lvtstart (); replace with: */
	logmsg ();  /* calculate min_msg_time */

	if ( numTo == 2 )
	{  /* pass this message on */
		gvtmessage ( GVTSTART, gvt, to[0] );
		gvtmessage ( GVTSTART, gvt, to[1] );
	}
	else if ( numTo == 1 )
	{
		gvtmessage ( GVTSTART, gvt, to[0] );
	}
	else /* we are the last one */
	{
		gvtlvt ( MinLvt );
	}
}

FUNCTION gvtlvt ( lvt )

	VTime       lvt;    /* minimum LVT value */
{

  Debug


/* from old gvtstop */
	if ( numArrive == 0 ) 
	{   /* this is the first pass through gvtlvt() */
		lvtstop ( &MinLvt );    /* calculate our local virtual time */
	}

/* from old gvtlvt */
	if ( ltVTime ( lvt, MinLvt ) )
	{  /* passed in time is less */
		MinLvt = lvt;   /* remember the passed in time */
	}


	if ( numTo == 2 )
	{  /* we're expecting 2 of these messages */
		if ( numArrive == 0 ) 
		{

			numArrive = 1;
			return;     /* if we've only received the first */
		}
		else
		{  /* both messages have arrived */

			numArrive = 0;
		}
	}


	if ( numFrom == 2 )
	{  /* we need to send 2 of these messages (in reverse) */
		gvtmessage ( GVTLVT, MinLvt, from[0] );
		gvtmessage ( GVTLVT, MinLvt, from[1] );
	}
	else if ( numFrom == 1 )
	{  /* only send 1 */
		gvtmessage ( GVTLVT, MinLvt, from[0] );
	}
	else /* we are the last one */
	{

		gvtupdate ( MinLvt );   /* start the update cycle */

	}
}

STime gvt_sync = NEGINF+1;

VTime oldgvt1 = NEGINF;
VTime oldgvt2 = NEGINF;
VTime dynWindow = POSINF;
extern double windowMultiplier;

FUNCTION gvtupdate ( newgvt )

	VTime       newgvt;         /* new value of GVT */
{
	char        pvts[20];
	char        min_vts[20];
	char        newgvts[20];
	char        loggvts[20];

	extern int mem_stats_enabled;
	extern int no_gvtout;
	extern int qlog;
	char buff[MINPKTL];

#ifdef TIMING
	extern int timing[20];
	extern int timing_mode;
	int i;

#ifdef MARK3
	static char stats[200];

	extern int inttime;
#endif
#endif

  Debug

/* instead of the B'Cast, do a tree output */
	if ( Out0 < numNodes )
	{
		gvtmessage ( GVTUPDATE, newgvt, Out0, 0 );
	}

	if ( Out1 < numNodes )
	{
		gvtmessage ( GVTUPDATE, newgvt, Out1, 0 );
	}

#ifdef GETRUSAGE
	if ( init_faults  )
	{
/*
		if ( 0 )
			print_faults();
*/
	}
	else
	{
		set_faults();
		init_faults = 1;
	}
#endif

/* from gvtcalc */
	/* reset these */
	MinLvt = posinfPlus1;

	resendState = TRUE; /* ok to resend previously nak'd states */

/* from gvtupdate */
	if ( ltSTime ( gvt.simtime, posinf.simtime ) )
	{  /* our last gvt was not posinf */
		if ( gtSTime ( newgvt.simtime, gvt_sync ) )
		{  /* all nodes are past the initial starting time */
			if ( leSTime ( gvt.simtime, gvt_sync ) )
			{  /* our last gvt was not past the initial start time */

				run_time = clock ();    /* start the run time clock */
#ifdef TIMING
				for ( i = 0; i < 20; i++ )
					timing[i] = 0;
#endif
			}
			else
				do_timing();    /* cumulate timing figures */
		}

		if ( tw_node_num == 0 )
		{  /* convert times to strings on node 0 */
			ttoc ( pvts, pvt );
			ttoc ( min_vts, min_vt );
			ttoc ( newgvts, newgvt );

			if ( ! no_gvtout )
			{  /* print the new gvt */
#ifdef SUN
				_pprintf ( "Seconds: %6.2f   Gvt: %s%8d%8d\n", seconds, 
					newgvts,newgvt.sequence1,newgvt.sequence2 );
#endif

#ifdef TRANSPUTER
				_pprintf ( "Seconds: %6.2f   Gvt: %s\n", seconds, newgvts );
#endif

#ifdef BBN
				printf ( "Seconds:\t%6.2f\t\tGvt:\t%s%8d%8d\n", seconds,
					newgvts,newgvt.sequence1,newgvt.sequence2 );
#endif

#ifdef MARK3
				extern int subcube_num;

				printf ( "%d-- Seconds:\t%6.2f\t\tGvt:\t%s\n", subcube_num,
						seconds, newgvts );
/*
				{
					char gvt_line[80];

					sprintf ( gvt_line, " -- Pvt: %s MinVt: %s Gvt: %s\n",
						pvts, min_vts, newgvts);

					send_message ( gvt_line, strlen ( gvt_line ) + 1, CP, GVT_DATA );
				}
*/
#endif
#ifdef DLM
				if ( migrGraph )
				{
					ttoc1 (loggvts, newgvt );
					sprintf ( buff, "Gvt  %s \n", newgvts);

					send_to_IH ( buff, strlen ( buff ) + 1, MIGR_LOG );
				}
#endif
			}
		}
	}

#ifdef TIMING
#ifdef MARK3
	if ( eqSTime ( newgvt.simtime, posinfPlus1.simtime ) )
	{
		timing[timing_mode] += mark3time ();

	sprintf ( stats, "Node %d Gvt %d Pvt %d MinVt %d Tester %3.2f Timewarp %3.2f Objects %3.2f System %3.2f Idle %3.2f Rollback %3.2f Queue %3.2f Sched %3.2f Dlvr %3.2f Serve %3.2f Objend %3.2f Gvt %3.2f Ints %3.2f\n",
		tw_node_num, gvt, pvt, min_vt,
		((float) timing[0]) / 500000.0,
		((float) timing[1]) / 500000.0,
		((float) timing[2]) / 500000.0,
		((float) timing[3]) / 500000.0,
		((float) timing[4]) / 500000.0,
		((float) timing[5]) / 500000.0,
		((float) timing[6]) / 500000.0,
		((float) timing[7]) / 500000.0,
		((float) timing[8]) / 500000.0,
		((float) timing[9]) / 500000.0,
		((float) timing[10]) / 500000.0,
		((float) timing[11]) / 500000.0,
		((float) inttime ) * 4.34 / 1000000.0 );

	send_message ( stats, strlen ( stats ), CP, STATS_DATA );
	}
#endif
#ifdef SUN
	_pprintf ( "Tester %3.2f Timewarp %3.2f Objects %3.2f System %3.2f\n",
		((float) timing[0]) / 1000000.0,
		((float) timing[1]) / 1000000.0,
		((float) timing[2]) / 1000000.0,
		((float) timing[3]) / 1000000.0 );
#endif
#endif

	/* If there has been an increase in simtime over the last gvt tick, 
		bump up the window.  Otherwise, leave the window alone. */

	if ( newgvt.simtime - gvt.simtime > 0 )
	{
		dynWindow.simtime = gvt.simtime +  windowMultiplier * (
					(newgvt.simtime - gvt.simtime ) ) ;
	}
	dynWindow.sequence1 = dynWindow.sequence2 = 10000000;


	if ( dynWindow.simtime > POSINF )
		dynWindow.simtime = POSINF;


	oldgvt2 = oldgvt1;
	oldgvt1 = gvt;

	/* now set the new time */
	gvt = min_vt = newgvt;      /* must be done before gcpast */

if ( ltVTime ( min_msg_time, gvt ) )
{
	  twerror("gvtupdate:  min_msg_time %f below new gvt %f\n",
			  min_msg_time.simtime, gvt.simtime);
	  tester();
}


#ifdef DLM
/*
	if ( tw_node_num == 0 && 
		oldgvt2.simtime != NEGINF  && 
		eqVTime ( gvt, oldgvt1 ) && 
		eqVTime ( oldgvt1, oldgvt2 ) )
	{
		_pprintf ( "GVT repeats three times\n");
		tester();
	}
*/
#endif DLM


	gvtcount++;

	gcpast ();

	if ( mem_stats_enabled )
	{  /* do memory stats */
		mem_stats ();
	}



	if ( tw_node_num == GVTNODE )
	{
		if ( eqSTime ( newgvt.simtime, posinfPlus1.simtime ) )
		{       /* final time has been reached */
#ifdef BBN

		printf
		(
			"\nSimulation Over!\n\nElapsed time %.2f seconds\n\n",
			seconds
		);
#endif
#ifdef MARK3

		printf 
		(
			"\n%d-- Simulation Over!\n\n%d-- Elapsed time %.2f seconds\n\n",
			subcube_num, subcube_num, seconds
		);
#endif
#ifdef SUN
		printf 
		(
			"\n-- Simulation Over!\n\n-- Elapsed time %.2f seconds\n\n",
			seconds
		);
#endif
#ifdef TRANSPUTER
		_pprintf 
		(
			"\n-- Simulation Over!\n\n-- Elapsed time %.2f seconds\n\n",
			seconds
		);
#endif
		}
		else
		{
			extern int interval, delta;
			extern STime interval_change_time;

			if ( geSTime ( newgvt.simtime, interval_change_time ) )
			{
				interval = 1;
#ifdef MARK3
				delta = 250;
#endif
			}
#ifdef MICROTIME
			schedule_next_gvt();
#else
			timrint ( gvtinterrupt );
#endif
		}
	}

	if ( eqSTime ( newgvt.simtime, posinf.simtime ) )
	{
		extern STime cutoff_time;

#ifdef GETRUSAGE
		total_faults = num_faults();
/*
		_pprintf ( "Total Faults %d\n", total_faults );
*/
#endif

		cutoff_time = POSINF;
		term_objects ();
	}
	else
	if ( eqSTime ( newgvt.simtime, posinfPlus1.simtime ) )
	{
		dump_stats ( seconds );
		if ( critEnabled == TRUE )
		{
			calculateCritPath();
		}
		else
		{	
			send_to_IH ( "Simulation End\n", 16, SIM_END_MSG );
		}
	}
}

FUNCTION term_objects ()
{
	Ocb * o, * n;
	Msgh * msg;

	for ( o = fstocb_macro; o; o = n )
	{
		n = nxtocb_macro (o);

		if ( eqSTime ( o->svt.simtime, posinfPlus1.simtime ) )
			continue;

		if ( o->typepointer->term && 
				eqSTime ( o->phase_end.simtime, posinfPlus1.simtime ) )
		{
			if ( eqSTime ( o->svt.simtime, posinf.simtime )
			&&   o->runstat == BLKINF )
			{
				msg = make_message ( TMSG, "TW", o->svt, o->name, 
									    o->svt, 0, 0 );

				nq_input_message ( o, msg );
			}
		}
		else
		{
			l_remove ( o );
			o->svt = posinfPlus1;
			l_insert ( l_prev_macro ( _prqhd ), o );
		}
	}
}

/* cumulate run time in "seconds" */

do_timing()
{
#ifdef SUN
	run_time_2 = clock();
	seconds += (run_time_2 - run_time) / (double) TICKS_PER_SECOND;
#endif
#ifdef MARK3
	run_time_2 = clock();
	seconds += (run_time_2 - run_time) / 1000000.;
#endif
#ifdef TRANSPUTER
	run_time_2 = clock();
	seconds += (run_time_2 - run_time) / 1000000.;
#endif
#ifdef BBN
	run_time_2 = clock();
	seconds += ( (run_time_2 - run_time) * 62.5 ) / 1000000.;
#endif
	run_time = run_time_2;
}

/* calculate our local virtual time */

FUNCTION lvtstop ( t )

	VTime       *t;
{
	Ocb         *o;
	VTime       min;

#if PARANOID
	Ocb         *firstOcb = NULL;
#endif

	pvt = posinfPlus1;  /* init to the max */

	for ( o = fstocb_macro; o; o = nxtocb_macro (o) )
	{  /* cycle through the object list for this node */
		if ( o->runstat == ITS_STDOUT )
			continue;           /* skip stdout objects */

		/*  This code is in place to test for cases in which the first
				ocb in the scheduler queue is not the one with the earliest
				svt. */

#if PARANOID
		if ( firstOcb == NULL )
			firstOcb = o;
#endif

		if ( ltVTime ( o->svt, pvt ) )
		{
			pvt = o->svt;       /* new minimum--save it */

#if PARANOID
			if ( o != firstOcb )
			{
				_pprintf("lvtstop: scheduler misordering during gvt calculation\n");
				_pprintf("      %s at %f before %s at %f\n", firstOcb->name,
						firstOcb->svt.simtime, o->name, o->svt.simtime );
				tester();
			}
#endif

		}
#if !PARANOID
		break;
#endif

	}


	/* calculate minimum message & object migration time */
	minmsg ( &min_vt );

	if ( ltVTime ( pvt, min_vt ) )
	{  /* pvt is earlier--use it */
		min_vt = pvt;
	}

if ( ltVTime ( min_vt, gvt ) )
{
_pprintf("min_vt %f less than gvt %f after checking pvt\n",
	  min_vt.simtime, gvt.simtime);
tester();
}

	/* calculate the minimum time of pending actions */
	min = MinPendingList ();

	if ( ltVTime ( min, min_vt ) )
	{  /* min is earlier--use it */
		min_vt = min;
	}

if ( ltVTime ( min_vt, gvt ) )
{
_pprintf("min_vt %f less than gvt %f after checking pending list\n",
	  min_vt.simtime, gvt.simtime);
tester();
}


	if ( eqSTime ( min_vt.simtime, posinfPlus1.simtime ) )
	{  /* no minimum time found */
		extern int states_to_send, ocbs_to_send;

		if ( states_to_send || ocbs_to_send )
		{
		   _pprintf("Migrations not complete at POSINF+1, %d states, %d ocbs\n",
				states_to_send, ocbs_to_send );

			min_vt.simtime = POSINF;
		}
	}

	*t = min_vt;        /* send time back to the caller */
#ifdef DLM
	local_min_vt = min_vt;
#endif DLM

  Debug

	if ( ltVTime ( min_vt, gvt ) )
	{  /* uh oh, we're earlier than we should be */
		twerror ( "lvtstop E min_vt %.2f less than old gvt %.2f",
			min_vt.simtime, gvt.simtime );
		tester ();
	}

	return;
}       /* lvtstop */

#ifdef GETRUSAGE
#include <sys/time.h>
#include <sys/resource.h>

int initFaults;
int lastFaultCount;

set_faults()
{
	struct rusage u;

	getrusage (0, &u);
	lastFaultCount = initFaults =  u.ru_majflt;
}

num_faults()
{
	struct rusage u;

	getrusage (0, &u);
	return  u.ru_majflt - initFaults;
}

/* debug code
int printCount;

print_faults()
{
	int thisCount;
	struct rusage u;


	printCount++;
	getrusage (0, &u);
	thisCount =  u.ru_majflt;

	if ( thisCount > lastFaultCount )
		_pprintf
		( "%4d -- %d more faults -- total: %d\n", 
			printCount, thisCount - lastFaultCount,
			thisCount - initFaults );

	lastFaultCount = thisCount;
}
*/
#endif

@


1.16
log
@Add sequence output for Suns.
@
text
@d7 3
d396 2
d562 15
a576 1
#ifdef DLM
a578 1
#endif DLM
@


1.15
log
@Force gvt display to print sequence numbers.
@
text
@d7 3
d481 2
a482 1
				_pprintf ( "Seconds: %6.2f   Gvt: %s\n", seconds, newgvts );
@


1.14
log
@Removed all code relating to the memory out poll flag, changed all 
occurrences of miparm.me to tw_node_num, and added a call to the critical
path calculation module, if needed
@
text
@d7 5
d486 2
a487 1
				printf ( "Seconds:\t%6.2f\t\tGvt:\t%s\n", seconds, newgvts );
@


1.13
log
@New copyright notice.
@
text
@d7 3
a64 4
int memory_out_flag;
VTime memory_out_time;  /* set when memory_out_flag is set, in m_create() */
int start_memory_out_flag;

a69 1
int mem_out_poll_flag;
d92 7
d112 3
a114 1
	myNum = miparm.me;          /* this nodes number */
a117 1
	mem_out_poll_flag = 8; /*???why?*/
d219 1
a219 1
	if ( miparm.me == 0 )
d229 1
a229 1
FUNCTION gvtmessage ( type, time, dest, flags )
a233 1
	Int         flags;
d243 1
a243 1
	q->sender = miparm.me;
a244 1
	q->flags = flags;
d246 1
a246 1
	sprintf ( p->snder, "GVT%d", miparm.me );
d273 1
a273 1
			gvtlvt (gvt_message->time, gvt_message->flags );
a311 3
	start_memory_out_flag = memory_out_flag;


d314 2
a315 2
		gvtmessage ( GVTSTART, gvt, to[0], 0 );
		gvtmessage ( GVTSTART, gvt, to[1], 0 );
d319 1
a319 1
		gvtmessage ( GVTSTART, gvt, to[0], 0 );
d323 1
a323 1
		gvtlvt ( MinLvt, mem_out_poll_flag);
d327 1
a327 1
FUNCTION gvtlvt ( lvt, flags)
a329 1
	Int         flags;  /* memory out flag */
a338 10

		mem_out_poll_flag = start_memory_out_flag & memory_out_flag;

		if ( gtSTime ( MinLvt.simtime, posinf.simtime ) )
			/* set a flag bit if we're at the end of time */
			flags |= 2;

		if (mem_out_poll_flag && (ltVTime(MinLvt,memory_out_time)))
			/* out-of-memory is for some future event; not critical */
			mem_out_poll_flag = 0;
a344 3

		/* save the passed in flags */
		mem_out_poll_flag = flags;
d366 2
a367 2
		gvtmessage ( GVTLVT, MinLvt, from[0], mem_out_poll_flag );
		gvtmessage ( GVTLVT, MinLvt, from[1], mem_out_poll_flag );
d371 1
a371 1
		gvtmessage ( GVTLVT, MinLvt, from[0], mem_out_poll_flag );
a374 11
		if ( mem_out_poll_flag == 1 )   /* memory out */
		{  /* out of memory on node with lowest lvt */
			if ( eqVTime ( MinLvt, gvt ) )
			{
				_pprintf ( "Terminating Because of Memory Out\n" );
				tester ();
#if 0
				tw_exit (0);
#endif
			}
		}
a442 1
	mem_out_poll_flag = 8; /*???why?*/
d464 1
a464 1
		if ( miparm.me == 0 )
d520 1
a520 1
		miparm.me, gvt, pvt, min_vt,
d565 1
a565 1
	if ( miparm.me == 0 && 
d588 1
a588 1
	if ( miparm.me == GVTNODE )
d661 8
a668 1
		send_to_IH ( "Simulation End\n", 16, SIM_END_MSG );
d886 1
@


1.12
log
@Added MicroTime support for Sun version. Replace 5 with STATS_DATA and
6 with GVT_DATA.
@
text
@d1 4
d7 4
a51 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.11
log
@Put oldgvt outside of #if DLM.
@
text
@d3 3
d210 3
d214 1
d473 1
a473 3
#ifdef SUN
				run_time = time (0);
#else
a474 1
#endif
d516 1
a516 1
					send_message ( gvt_line, strlen ( gvt_line ) + 1, CP, 6 );
d555 1
a555 1
	send_message ( stats, strlen ( stats ), CP, 5 );
d655 3
a657 1

d659 1
d723 2
a724 2
	run_time_2 = time (0);
	seconds += run_time_2 - run_time;
@


1.10
log
@Fix code for DLM off.
@
text
@d3 3
a394 1
#ifdef DLM
a396 1
#endif DLM
@


1.9
log
@Tab conversion.
@
text
@d2 4
a5 1
 * $Log:        gvt2.c,v $
d72 1
d74 1
d439 1
d442 1
d515 1
d523 1
@


1.8
log
@1.  Add resendState flag for migration control.
2.  Add PARANOID code to check for scheduler queue misordering.
3.  Don't depend on queue ordering at term time.
@
text
@d2 6
a7 1
 * $Log:	gvt2.c,v $
d33 1
a33 1
char gvt_id [] = "@@(#)gvt2.c	1.9\t10/23/89\t08:53:45\tTIMEWARP";
d35 3
a37 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d49 1
a49 1
VTime memory_out_time;	/* set when memory_out_flag is set, in m_create() */
d52 1
a52 1
int	resendState = TRUE;	/* set false when state is nak'd */
d71 6
a76 6
int	hlog = 0;
VTime	hlogVTime;
int	maxSlice = 0;		/* maximum object time slice for this node */
Ocb*	maxSliceObj = NULL;	/* object corresponding to maxSlice */
VTime	maxSliceTime;		/* time for above object */
int	sliceTime;		/* time for current slice */
d88 2
a89 2
    int Mid0, Mid1, myInv, OutFrom, In0, In1, InTo;
    int pen0, pen1;
d91 2
a92 2
    myNum = miparm.me;		/* this nodes number */
    numNodes = miparm.maxnprc;	/* total number of nodes */
d94 2
a95 2
    MinLvt = posinfPlus1;
    mem_out_poll_flag = 8; /*???why?*/
d97 1
a97 1
    numArrive = 0;
d99 2
a100 2
    Mid0 = ( numNodes - 1 )/2;
    Mid1 = ( numNodes & 0x01 )? Mid0 : Mid0 + 1;
d102 2
a103 2
    /* matching node on other tree */
    myInv = numNodes - myNum - 1;
d105 4
a108 4
    /* for binary tree with root 0 */
    Out0 = 2 * myNum + 1;		/* upper child number */
    Out1 = Out0 + 1;			/* lower child number */
    OutFrom = ( myNum - 1 )/2;		/* parent number */
d110 4
a113 4
    /* for binary tree with root numNodes-1 */
    In0 = 2 * myNum - numNodes;		/* upper child number */
    In1 = In0 - 1;			/* lower child number */
    InTo = ( numNodes + myNum + 1 )/2;	/* parent number */
d115 6
a120 6
    for ( pen0 = 1; pen0 < Mid0 + 1; pen0 = 2 * pen0 + 1 )
    {
	;
    }
    pen0 = pen0/2 - 1;
    pen1 = numNodes - pen0 -1;
d122 6
a127 6
    /* the two trees can share the bottom row */
    if ( pen1 <= 2 * pen0 + 3 )
    {
	Mid0 = pen1 - 1;
	Mid1 = pen0 + 1;
    }
d131 25
a155 25
    if ( myNum == 0 )
    {	/* left root */
	numFrom = 0;
    }
    else if ( myNum <= Mid0 )
    {	/* in left tree */
	numFrom = 1;
	from[0] = OutFrom;
    }
    else if ( Mid1 <= In1 )
    {	/* right tree */
	numFrom = 2;
	from[0] = In0;
	from[1] = In1;
    }
    else if ( Mid1 == In0 )
    {	/* extra element between trees (eg 7->11 with 15 nodes) */
	numFrom = 1;
	from[0] = In0;
    }
    else
    {	/* input from matching node on left tree */
	numFrom = 1;
	from[0] = myInv;
    }
d157 25
a181 25
    if ( myNum == numNodes - 1 )
    {	/* right root */
	numTo = 0;
    }
    else if ( myNum >= Mid1 )
    {	/* in right tree */
	numTo = 1;
	to[0] = InTo;
    }
    else if ( Mid0 >= Out1 )
    {	/* in left tree */
	numTo = 2;
	to[0] = Out0;
	to[1] = Out1;
    }
    else if ( Mid0 == Out0 )
    {	/* extra element between trees (eg 3->7 with 15 nodes) */
	numTo = 1;
	to[0] = Out0;
    }
    else
    {	/* output to matching node on right tree */
	numTo = 1;
	to[0] = myInv;
    }
d189 2
a190 2
    gvtstart();
    dispatch();
d197 4
a200 4
    if ( miparm.me == 0 )
    {  /* if node 0 initiate gvtinterrupt routine every second */
	timrint ( gvtinterrupt );
    }
d205 4
a208 4
    Int		type;
    VTime	time;
    Int		dest;
    Int		flags;
d210 2
a211 2
    Msgh	*p;
    Gvtmsg	*q;
d215 6
a220 6
    p = sysbuf (); /*SFB maybe sometimes output_buf()??? */
    q = (Gvtmsg *) (p + 1);
    q->msgtype = type;
    q->sender = miparm.me;
    q->time = time;
    q->flags = flags;
d222 4
a225 4
    sprintf ( p->snder, "GVT%d", miparm.me );
    sprintf ( p->rcver, "GVT%d", dest );
    p->sndtim = gvt;
    p->rcvtim = time;
d227 1
a227 1
    sysmsg ( GVTSYS, p, sizeof (Gvtmsg), dest );
d232 1
a232 1
    Gvtmsg	*gvt_message;
d239 1
a239 1
    start_timing ( GVT_TIMING_MODE );
d242 5
a246 5
    switch ( gvt_message->msgtype )
    {
	case GVTSTART:		/* command to start a local GVT calculation */
	    gvtstart ();
	    break;
d248 3
a250 3
	case GVTLVT:		/* incoming minimum LVT value */
	    gvtlvt (gvt_message->time, gvt_message->flags );
	    break;
d252 4
a255 4
	case GVTUPDATE:		/* announcement of new GVT value */
	    gvtupdate ( gvt_message->time );
	    break;
    }
d258 1
a258 1
    stop_timing ();
d267 1
a267 1
    int i;
d272 11
a282 6
    if ( numFrom == 2 )
    {  /* 2 inputs expected--wait for both */
	if ( numArrive == 0 ) 
	{
	    numArrive = 1;
	    return;		/* if only 1 is here yet */
a283 5
	else
	{
	    numArrive = 0;	/* both have arrived--continue */
	}
    }
d285 2
a286 2
    /* lvtstart (); replace with: */
    logmsg ();	/* calculate min_msg_time */
d288 1
a288 1
    start_memory_out_flag = memory_out_flag;
d291 13
a303 13
    if ( numTo == 2 )
    {  /* pass this message on */
	gvtmessage ( GVTSTART, gvt, to[0], 0 );
	gvtmessage ( GVTSTART, gvt, to[1], 0 );
    }
    else if ( numTo == 1 )
    {
	gvtmessage ( GVTSTART, gvt, to[0], 0 );
    }
    else /* we are the last one */
    {
        gvtlvt ( MinLvt, mem_out_poll_flag);
    }
d308 2
a309 2
    VTime	lvt;	/* minimum LVT value */
    Int		flags;	/* memory out flag */
d316 3
a318 3
    if ( numArrive == 0 ) 
    {	/* this is the first pass through gvtlvt() */
	lvtstop ( &MinLvt );	/* calculate our local virtual time */
d320 1
a320 1
	mem_out_poll_flag = start_memory_out_flag & memory_out_flag;
d322 3
a324 3
	if ( gtSTime ( MinLvt.simtime, posinf.simtime ) )
	    /* set a flag bit if we're at the end of time */
	    flags |= 2;
d326 4
a329 4
	if (mem_out_poll_flag && (ltVTime(MinLvt,memory_out_time)))
	    /* out-of-memory is for some future event; not critical */
	    mem_out_poll_flag = 0;
    }
d332 3
a334 3
    if ( ltVTime ( lvt, MinLvt ) )
    {  /* passed in time is less */
	MinLvt = lvt;	/* remember the passed in time */
d336 3
a338 3
	/* save the passed in flags */
	mem_out_poll_flag = flags;
    }
d341 4
a344 4
    if ( numTo == 2 )
    {  /* we're expecting 2 of these messages */
	if ( numArrive == 0 ) 
	{
d346 5
a350 5
	    numArrive = 1;
	    return;	/* if we've only received the first */
	}
	else
	{  /* both messages have arrived */
d352 2
a353 1
	    numArrive = 0;
a354 1
    }
d357 17
a373 17
    if ( numFrom == 2 )
    {  /* we need to send 2 of these messages (in reverse) */
	gvtmessage ( GVTLVT, MinLvt, from[0], mem_out_poll_flag );
	gvtmessage ( GVTLVT, MinLvt, from[1], mem_out_poll_flag );
    }
    else if ( numFrom == 1 )
    {  /* only send 1 */
	gvtmessage ( GVTLVT, MinLvt, from[0], mem_out_poll_flag );
    }
    else /* we are the last one */
    {
	if ( mem_out_poll_flag == 1 )	/* memory out */
	{  /* out of memory on node with lowest lvt */
	    if ( eqVTime ( MinLvt, gvt ) )
	    {
		_pprintf ( "Terminating Because of Memory Out\n" );
		tester ();
d375 1
a375 1
		tw_exit (0);
d377 2
a378 2
	    }
	}
d380 1
a380 1
	gvtupdate ( MinLvt );	/* start the update cycle */
d382 1
a382 1
    }
d394 1
a394 1
    VTime	newgvt;		/* new value of GVT */
d396 4
a399 4
    char	pvts[20];
    char	min_vts[20];
    char	newgvts[20];
    char	loggvts[20];
d401 4
a404 4
    extern int mem_stats_enabled;
    extern int no_gvtout;
    extern int qlog;
    char buff[MINPKTL];
d407 3
a409 3
    extern int timing[20];
    extern int timing_mode;
    int i;
d412 1
a412 1
    static char stats[200];
d414 1
a414 1
    extern int inttime;
d421 4
a424 4
    if ( Out0 < numNodes )
    {
	gvtmessage ( GVTUPDATE, newgvt, Out0, 0 );
    }
d426 4
a429 4
    if ( Out1 < numNodes )
    {
	gvtmessage ( GVTUPDATE, newgvt, Out1, 0 );
    }
d432 10
a441 10
    if ( init_faults  )
    {
	if ( 0 )
	    print_faults();
    }
    else
    {
	set_faults();
	init_faults = 1;
    }
d445 3
a447 3
    /* reset these */
    MinLvt = posinfPlus1;
    mem_out_poll_flag = 8; /*???why?*/
d449 1
a449 1
    resendState = TRUE;	/* ok to resend previously nak'd states */
d452 6
a457 6
    if ( ltSTime ( gvt.simtime, posinf.simtime ) )
    {  /* our last gvt was not posinf */
	if ( gtSTime ( newgvt.simtime, gvt_sync ) )
	{  /* all nodes are past the initial starting time */
	    if ( leSTime ( gvt.simtime, gvt_sync ) )
	    {  /* our last gvt was not past the initial start time */
d459 1
a459 1
		run_time = time (0);
d461 1
a461 1
		run_time = clock ();	/* start the run time clock */
d464 2
a465 2
		for ( i = 0; i < 20; i++ )
		    timing[i] = 0;
d467 4
a470 4
	    }
	    else
		do_timing();	/* cumulate timing figures */
	}
d472 5
a476 5
	if ( miparm.me == 0 )
	{  /* convert times to strings on node 0 */
	    ttoc ( pvts, pvt );
	    ttoc ( min_vts, min_vt );
	    ttoc ( newgvts, newgvt );
d478 2
a479 2
	    if ( ! no_gvtout )
	    {  /* print the new gvt */
d481 1
a481 1
		_pprintf ( "Seconds: %6.2f   Gvt: %s\n", seconds, newgvts );
d485 1
a485 1
		_pprintf ( "Seconds: %6.2f   Gvt: %s\n", seconds, newgvts );
d489 1
a489 1
		printf ( "Seconds:\t%6.2f\t\tGvt:\t%s\n", seconds, newgvts );
d493 1
a493 1
		extern int subcube_num;
d495 2
a496 2
		printf ( "%d-- Seconds:\t%6.2f\t\tGvt:\t%s\n", subcube_num,
			seconds, newgvts );
d498 2
a499 2
		{
		    char gvt_line[80];
d501 2
a502 2
		    sprintf ( gvt_line, " -- Pvt: %s MinVt: %s Gvt: %s\n",
			pvts, min_vts, newgvts);
d504 2
a505 2
		    send_message ( gvt_line, strlen ( gvt_line ) + 1, CP, 6 );
		}
d508 4
a511 4
		if ( migrGraph )
		{
		    ttoc1 (loggvts, newgvt );
		    sprintf ( buff, "Gvt  %s \n", newgvts);
d513 3
a515 1
		    send_to_IH ( buff, strlen ( buff ) + 1, MIGR_LOG );
a516 1
	    }
a517 1
    }
d521 3
a523 3
    if ( eqSTime ( newgvt.simtime, posinfPlus1.simtime ) )
    {
	timing[timing_mode] += mark3time ();
d525 15
a539 15
    sprintf ( stats, "Node %d Gvt %d Pvt %d MinVt %d Tester %3.2f Timewarp %3.2f Objects %3.2f System %3.2f Idle %3.2f Rollback %3.2f Queue %3.2f Sched %3.2f Dlvr %3.2f Serve %3.2f Objend %3.2f Gvt %3.2f Ints %3.2f\n",
	miparm.me, gvt, pvt, min_vt,
	((float) timing[0]) / 500000.0,
	((float) timing[1]) / 500000.0,
	((float) timing[2]) / 500000.0,
	((float) timing[3]) / 500000.0,
	((float) timing[4]) / 500000.0,
	((float) timing[5]) / 500000.0,
	((float) timing[6]) / 500000.0,
	((float) timing[7]) / 500000.0,
	((float) timing[8]) / 500000.0,
	((float) timing[9]) / 500000.0,
	((float) timing[10]) / 500000.0,
	((float) timing[11]) / 500000.0,
	((float) inttime ) * 4.34 / 1000000.0 );
d541 2
a542 2
    send_message ( stats, strlen ( stats ), CP, 5 );
    }
d545 5
a549 5
    _pprintf ( "Tester %3.2f Timewarp %3.2f Objects %3.2f System %3.2f\n",
	((float) timing[0]) / 1000000.0,
	((float) timing[1]) / 1000000.0,
	((float) timing[2]) / 1000000.0,
	((float) timing[3]) / 1000000.0 );
d554 2
a555 2
    oldgvt2 = oldgvt1;
    oldgvt1 = gvt;
d558 2
a559 2
    /* now set the new time */
    gvt = min_vt = newgvt;	/* must be done before gcpast */
d563 3
a565 3
      twerror("gvtupdate:  min_msg_time %f below new gvt %f\n",
              min_msg_time.simtime, gvt.simtime);
      tester();
d571 8
a578 8
    if ( miparm.me == 0 && 
	oldgvt2.simtime != NEGINF  && 
	eqVTime ( gvt, oldgvt1 ) && 
	eqVTime ( oldgvt1, oldgvt2 ) )
    {
	_pprintf ( "GVT repeats three times\n");
	tester();
    }
d583 1
a583 1
    gvtcount++;
d585 1
a585 1
    gcpast ();
d587 4
a590 4
    if ( mem_stats_enabled )
    {  /* do memory stats */
	mem_stats ();
    }
d594 4
a597 4
    if ( miparm.me == GVTNODE )
    {
	if ( eqSTime ( newgvt.simtime, posinfPlus1.simtime ) )
	{	/* final time has been reached */
d600 5
a604 5
	printf
	(
	    "\nSimulation Over!\n\nElapsed time %.2f seconds\n\n",
	    seconds
	);
d608 5
a612 5
	printf 
	(
	    "\n%d-- Simulation Over!\n\n%d-- Elapsed time %.2f seconds\n\n",
	    subcube_num, subcube_num, seconds
	);
d615 5
a619 5
	printf 
	(
	    "\n-- Simulation Over!\n\n-- Elapsed time %.2f seconds\n\n",
	    seconds
	);
d622 5
a626 5
	_pprintf 
	(
	    "\n-- Simulation Over!\n\n-- Elapsed time %.2f seconds\n\n",
	    seconds
	);
d628 5
a632 5
	}
	else
	{
	    extern int interval, delta;
	    extern STime interval_change_time;
d634 3
a636 3
	    if ( geSTime ( newgvt.simtime, interval_change_time ) )
	    {
		interval = 1;
d638 1
a638 1
		delta = 250;
d640 1
a640 1
	    }
d642 2
a643 1
	    timrint ( gvtinterrupt );
a644 1
    }
d646 3
a648 3
    if ( eqSTime ( newgvt.simtime, posinf.simtime ) )
    {
	extern STime cutoff_time;
d651 1
a651 1
        total_faults = num_faults();
d653 1
a653 1
	_pprintf ( "Total Faults %d\n", total_faults );
d657 9
a665 9
	cutoff_time = POSINF;
	term_objects ();
    }
    else
    if ( eqSTime ( newgvt.simtime, posinfPlus1.simtime ) )
    {
	dump_stats ( seconds );
	send_to_IH ( "Simulation End\n", 16, SIM_END_MSG );
    }
d670 2
a671 2
    Ocb * o, * n;
    Msgh * msg;
d673 3
a675 3
    for ( o = fstocb_macro; o; o = n )
    {
	n = nxtocb_macro (o);
d677 2
a678 2
	if ( eqSTime ( o->svt.simtime, posinfPlus1.simtime ) )
	    continue;
d680 8
a687 8
	if ( o->typepointer->term && 
		eqSTime ( o->phase_end.simtime, posinfPlus1.simtime ) )
	{
	    if ( eqSTime ( o->svt.simtime, posinf.simtime )
	    &&   o->runstat == BLKINF )
	    {
		msg = make_message ( TMSG, "TW", o->svt, o->name, 
					o->svt, 0, 0 );
d689 9
a697 2
		nq_input_message ( o, msg );
	    }
a698 7
	else
	{
	    l_remove ( o );
	    o->svt = posinfPlus1;
	    l_insert ( l_prev_macro ( _prqhd ), o );
	}
    }
d706 2
a707 2
    run_time_2 = time (0);
    seconds += run_time_2 - run_time;
d710 2
a711 2
    run_time_2 = clock();
    seconds += (run_time_2 - run_time) / 1000000.;
d714 2
a715 2
    run_time_2 = clock();
    seconds += (run_time_2 - run_time) / 1000000.;
d718 2
a719 2
    run_time_2 = clock();
    seconds += ( (run_time_2 - run_time) * 62.5 ) / 1000000.;
d721 1
a721 1
    run_time = run_time_2;
d728 1
a728 1
    VTime	*t;
d730 2
a731 2
    Ocb		*o;
    VTime	min;
d734 1
a734 1
    Ocb		*firstOcb = NULL;
d737 1
a737 1
    pvt = posinfPlus1;	/* init to the max */
d739 4
a742 4
    for ( o = fstocb_macro; o; o = nxtocb_macro (o) )
    {  /* cycle through the object list for this node */
	if ( o->runstat == ITS_STDOUT )
	    continue;		/* skip stdout objects */
d744 3
a746 3
	/*  This code is in place to test for cases in which the first
		ocb in the scheduler queue is not the one with the earliest
		svt. */
d749 2
a750 2
	if ( firstOcb == NULL )
	    firstOcb = o;
d753 3
a755 3
	if ( ltVTime ( o->svt, pvt ) )
	{
	    pvt = o->svt;	/* new minimum--save it */
d758 7
a764 7
	    if ( o != firstOcb )
	    {
		_pprintf("lvtstop: scheduler misordering during gvt calculation\n");
		_pprintf("	%s at %f before %s at %f\n", firstOcb->name,
			firstOcb->svt.simtime, o->name, o->svt.simtime );
		tester();
	    }
d767 1
a767 1
	}
d769 1
a769 1
	break;
d772 1
a772 1
    }
d775 2
a776 2
    /* calculate minimum message & object migration time */
    minmsg ( &min_vt );
d778 4
a781 4
    if ( ltVTime ( pvt, min_vt ) )
    {  /* pvt is earlier--use it */
	min_vt = pvt;
    }
d786 1
a786 1
      min_vt.simtime, gvt.simtime);
d790 2
a791 2
    /* calculate the minimum time of pending actions */
    min = MinPendingList ();
d793 4
a796 4
    if ( ltVTime ( min, min_vt ) )
    {  /* min is earlier--use it */
	min_vt = min;
    }
d801 1
a801 1
      min_vt.simtime, gvt.simtime);
d806 3
a808 3
    if ( eqSTime ( min_vt.simtime, posinfPlus1.simtime ) )
    {  /* no minimum time found */
	extern int states_to_send, ocbs_to_send;
d810 4
a813 4
	if ( states_to_send || ocbs_to_send )
	{
	   _pprintf("Migrations not complete at POSINF+1, %d states, %d ocbs\n",
		states_to_send, ocbs_to_send );
d815 2
a816 1
	    min_vt.simtime = POSINF;
a817 1
    }
d819 1
a819 1
    *t = min_vt;	/* send time back to the caller */
d821 1
a821 1
    local_min_vt = min_vt;
d826 6
a831 6
    if ( ltVTime ( min_vt, gvt ) )
    {  /* uh oh, we're earlier than we should be */
	twerror ( "lvtstop E min_vt %.2f less than old gvt %.2f",
	    min_vt.simtime, gvt.simtime );
	tester ();
    }
d833 2
a834 2
    return;
}	/* lvtstop */
d845 1
a845 1
    struct rusage u;
d847 2
a848 2
    getrusage (0, &u);
    lastFaultCount = initFaults =  u.ru_majflt;
d853 1
a853 1
    struct rusage u;
d855 2
a856 2
    getrusage (0, &u);
    return  u.ru_majflt - initFaults;
d864 2
a865 2
    int thisCount;
    struct rusage u;
d868 3
a870 3
    printCount++;
    getrusage (0, &u);
    thisCount =  u.ru_majflt;
d872 5
a876 5
    if ( thisCount > lastFaultCount )
	_pprintf
	( "%4d -- %d more faults -- total: %d\n", 
	    printCount, thisCount - lastFaultCount,
	    thisCount - initFaults );
d878 1
a878 1
    lastFaultCount = thisCount;
@


1.7
log
@Added some code to look for gvt going backwards, and to support migration
graphics.
@
text
@d3 4
d47 1
d369 1
d371 1
d444 2
d670 2
d673 1
a673 1
	    break;
a674 2
	n = nxtocb_macro (o);

d728 4
d739 9
d749 1
d752 12
d765 2
d768 1
@


1.6
log
@Put hoglog output in XL_STATS.
@
text
@d3 3
d36 1
d59 1
d494 4
a497 3
#ifndef DLM
		ttoc1 (loggvts, newgvt );
		sprintf ( buff, "GVT  %s \n", newgvts);
d499 2
a500 2
		send_to_IH ( buff, strlen ( buff ) + 1, MIGR_LOG );
#endif DLM
d547 8
d740 7
d754 8
@


1.5
log
@Add hoglog support.
@
text
@d3 3
a634 5

	if (hlog)
	    {
	    _pprintf("Max slice for object %s: %.0f ms @@ %f %lu\n", maxSliceObj->name, ((float) maxSlice * 62.5) / 1000., maxSliceTime.simtime, maxSliceTime.sequence1);
	    }
@


1.4
log
@use .simtime field as necessary
@
text
@d3 3
d53 7
d625 1
d632 5
@


1.3
log
@1.  check memory_out_time before signaling out-of-memory
2.  go to tester if out of memory
@
text
@d3 4
d294 1
a294 1
	if ( gtSTime ( MinLvt, posinf ) )
d420 1
a420 1
    if ( ltSTime ( gvt, posinf ) )
d422 1
a422 1
	if ( gtSTime ( newgvt, gvt_sync ) )
d424 1
a424 1
	    if ( leSTime ( gvt, gvt_sync ) )
d488 1
a488 1
    if ( eqSTime ( newgvt, posinfPlus1 ) )
a539 1
	
d541 1
d555 1
a555 1
	if ( eqSTime ( newgvt, posinfPlus1 ) )
d593 1
a593 1
	    if ( geSTime ( newgvt, interval_change_time ) )
d605 1
a605 1
    if ( eqSTime ( newgvt, posinf ) )
d619 1
a619 1
    if ( eqSTime ( newgvt, posinfPlus1 ) )
d633 1
a633 1
	if ( eqSTime ( o->svt, posinfPlus1 ) )
d638 2
a639 1
	if ( o->typepointer->term && eqSTime ( o->phase_end, posinfPlus1 ) )
d641 1
a641 1
	    if ( eqSTime ( o->svt, posinf )
d720 1
a720 1
    if ( eqSTime ( min_vt, posinfPlus1 ) )
@


1.2
log
@added page fault counting to systems which support getrusage()
the page counting use to be in faults.c which is now unneeded.
@
text
@d3 4
d26 1
d285 1
a285 1
    {
d293 4
d304 1
a304 1
	/* forget our own memory_out_flag condition */
a340 1
#ifdef PARANOID
a341 1
#endif
d743 1
a743 1
}
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d36 1
a36 1
#ifdef BF_MACH
d390 1
a390 1
#ifdef BF_MACH
d598 1
a598 1
#ifdef BF_MACH
d737 47
@
