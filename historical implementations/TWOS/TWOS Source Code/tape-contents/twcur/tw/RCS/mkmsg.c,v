head     1.3;
branch   ;
access   ;
symbols  TW2_7:1.3 TW2_6:1.3 TW2_5_1:1.3 TW2_5:1.2 TW2_4_2:1.1 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.3
date     91.07.17.15.10.20;  author judy;  state Rel;
branches ;
next     1.2;

1.2
date     91.06.03.12.25.23;  author configtw;  state Rel;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.16;  author configtw;  state Rel;
branches ;
next     ;


desc
@request & initialize message buffers
@


1.3
log
@New copyright notice.
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	mkmsg.c,v $
 * Revision 1.2  91/06/03  12:25:23  configtw
 * Tab conversion.
 * 
 * Revision 1.1  90/08/07  15:40:16  configtw
 * Initial revision
 * 
*/
char mkmsg_id [] = "@@(#)mkmsg.c 1.9\t6/2/89\t12:44:35\tTIMEWARP";


/*

Purpose:

		mkmsg.c contains routines that request and initialize message
		buffers.  These routines are used only in Tester.c and flower.c.
		The first routine requests space, then sets up the message.
		The second routine works with an already-allocated space,
		and merely sets up the message.

Functions:

		make_message(mtype,snder,sndtim,rcver,rcvtim,txtlen,text) -
				request a message list element, and initialize it
				Parameters - Byte mtype, Name *snder, VTime sndtim,
						Name *rcver, VTime rcvtim, Int txtlen, Byte *text
				Return - a pointer to the message list element, or a NULL ptr, 
						if no space is available

		make_static_msg(message,mtype,snder,sndtim,rcver,rcvtim,txtlen,text) - 
				initialize the provided message list element
				Parameters - Msgh *message, Byte mtype, Name *snder,
						VTime sndtim, Name *rcver, VTime rcvtim, Int txtlen, 
						Byte *text
				Return - a pointer to the message list element

Implementation:

		make_message() calls l_create() to get memory to hold the 
		message.  Failure to get the memory causes a NULL pointer to 
		be returned.  If memory was obtained, call clear() to zero it.
		Copy the provided parameters into the appropriate place in the
		new message space.  Get a unique id for it by calling uniq().
		Return a pointer to the message.

		make_static_msg() is similar, but is provided with the memory
		space by a parameter.  Thus, it does not call l_create(), and
		it will never return a NULL pointer.  (It behooves a user of
		this routine to make very sure that he has the memory he thinks
		he does before calling this routine.)  Otherwise, it is the
		same as make_message().
*/

#include "twcommon.h"
#include "twsys.h"

Msgh *
FUNCTION make_message ( mtype, snder, sndtim, rcver, rcvtim, txtlen, text )

	Byte mtype;
	Name * snder;
	VTime sndtim;
	Name * rcver;
	VTime rcvtim;
	Int txtlen;
	Byte * text;
{
	Msgh * message;

  Debug  

	/* find space, invoking sendback if necessary */
	message =  (Msgh *) m_create ( sizeof ( Msgh ) + txtlen, sndtim, 
								CRITICAL );

	if ( message == NULL )
		return ( NULL );        /* no space found */

	clear ( message, sizeof ( Msgh ) + txtlen );        /* zero it */

	/* fill in the blanks */
	message->mtype = mtype;
	strcpy ( message->snder, snder );
	message->sndtim = sndtim;
	strcpy ( message->rcver, rcver );
	message->rcvtim = rcvtim;

	message->txtlen = txtlen;

	if ( txtlen > 0 )
		/* copy text in area just past message header */
		entcpy ( message + 1, text, txtlen );

	message->gid.node = miparm.me;
	message->gid.num  = uniq ();

	mark_macro ( message );     /* mark message as used */

	return ( message );
}


Msgh *
make_static_msg ( message, mtype, snder, sndtim, rcver, rcvtim, txtlen, text )

	Msgh * message;
	Byte mtype;
	Name * snder;
	VTime sndtim;
	Name * rcver;
	VTime rcvtim;
	Int txtlen;
	Byte * text;
{
	clear ( message, sizeof ( Msgh ) + txtlen );

	message->mtype = mtype;
	strcpy ( message->snder, snder );
	message->sndtim = sndtim;
	strcpy ( message->rcver, rcver );
	message->rcvtim = rcvtim;
	message->txtlen = txtlen;

	if ( txtlen > 0 )
		entcpy ( message + 1, text, txtlen );

	message->gid.node = miparm.me;
	message->gid.num  = uniq ();

	return ( message );
}
@


1.2
log
@Tab conversion.
@
text
@d1 4
d6 4
a9 1
 * $Log:        mkmsg.c,v $
a15 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d7 1
a7 1
char mkmsg_id [] = "@@(#)mkmsg.c	1.9\t6/2/89\t12:44:35\tTIMEWARP";
d9 3
a11 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d17 5
a21 5
	mkmsg.c contains routines that request and initialize message
	buffers.  These routines are used only in Tester.c and flower.c.
	The first routine requests space, then sets up the message.
	The second routine works with an already-allocated space,
	and merely sets up the message.
d25 6
a30 6
	make_message(mtype,snder,sndtim,rcver,rcvtim,txtlen,text) -
		request a message list element, and initialize it
		Parameters - Byte mtype, Name *snder, VTime sndtim,
			Name *rcver, VTime rcvtim, Int txtlen, Byte *text
		Return - a pointer to the message list element, or a NULL ptr, 
			if no space is available
d32 6
a37 6
	make_static_msg(message,mtype,snder,sndtim,rcver,rcvtim,txtlen,text) - 
		initialize the provided message list element
		Parameters - Msgh *message, Byte mtype, Name *snder,
			VTime sndtim, Name *rcver, VTime rcvtim, Int txtlen, 
			Byte *text
		Return - a pointer to the message list element
d41 6
a46 6
	make_message() calls l_create() to get memory to hold the 
	message.  Failure to get the memory causes a NULL pointer to 
	be returned.  If memory was obtained, call clear() to zero it.
	Copy the provided parameters into the appropriate place in the
	new message space.  Get a unique id for it by calling uniq().
	Return a pointer to the message.
d48 6
a53 6
	make_static_msg() is similar, but is provided with the memory
	space by a parameter.  Thus, it does not call l_create(), and
	it will never return a NULL pointer.  (It behooves a user of
	this routine to make very sure that he has the memory he thinks
	he does before calling this routine.)  Otherwise, it is the
	same as make_message().
d62 7
a68 7
    Byte mtype;
    Name * snder;
    VTime sndtim;
    Name * rcver;
    VTime rcvtim;
    Int txtlen;
    Byte * text;
d70 1
a70 1
    Msgh * message;
d74 3
a76 3
    /* find space, invoking sendback if necessary */
    message =  (Msgh *) m_create ( sizeof ( Msgh ) + txtlen, sndtim, 
    				CRITICAL );
d78 2
a79 2
    if ( message == NULL )
        return ( NULL );	/* no space found */
d81 1
a81 1
    clear ( message, sizeof ( Msgh ) + txtlen );	/* zero it */
d83 6
a88 6
    /* fill in the blanks */
    message->mtype = mtype;
    strcpy ( message->snder, snder );
    message->sndtim = sndtim;
    strcpy ( message->rcver, rcver );
    message->rcvtim = rcvtim;
d90 1
a90 1
    message->txtlen = txtlen;
d92 3
a94 3
    if ( txtlen > 0 )
    	/* copy text in area just past message header */
        entcpy ( message + 1, text, txtlen );
d96 2
a97 2
    message->gid.node = miparm.me;
    message->gid.num  = uniq ();
d99 1
a99 1
    mark_macro ( message );	/* mark message as used */
d101 1
a101 1
    return ( message );
d108 8
a115 8
    Msgh * message;
    Byte mtype;
    Name * snder;
    VTime sndtim;
    Name * rcver;
    VTime rcvtim;
    Int txtlen;
    Byte * text;
d117 1
a117 1
    clear ( message, sizeof ( Msgh ) + txtlen );
d119 6
a124 6
    message->mtype = mtype;
    strcpy ( message->snder, snder );
    message->sndtim = sndtim;
    strcpy ( message->rcver, rcver );
    message->rcvtim = rcvtim;
    message->txtlen = txtlen;
d126 2
a127 2
    if ( txtlen > 0 )
        entcpy ( message + 1, text, txtlen );
d129 2
a130 2
    message->gid.node = miparm.me;
    message->gid.num  = uniq ();
d132 1
a132 1
    return ( message );
@
