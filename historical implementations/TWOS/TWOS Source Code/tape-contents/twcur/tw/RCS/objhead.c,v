head     1.10;
branch   ;
access   ;
symbols  TW2_7:1.10 TW2_6:1.9 TW2_5_1:1.7 TW2_5:1.6 TW2_4_2:1.1 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.10
date     91.12.27.08.47.35;  author reiher;  state Rel;
branches ;
next     1.9;

1.9
date     91.11.01.13.25.10;  author reiher;  state Rel;
branches ;
next     1.8;

1.8
date     91.11.01.09.51.46;  author pls;  state Dev;
branches ;
next     1.7;

1.7
date     91.07.17.15.11.19;  author judy;  state Rel;
branches ;
next     1.6;

1.6
date     91.06.03.14.24.21;  author configtw;  state Rel;
branches ;
next     1.5;

1.5
date     91.06.03.12.25.50;  author configtw;  state Dev;
branches ;
next     1.4;

1.4
date     91.05.31.14.57.40;  author pls;  state Dev;
branches ;
next     1.3;

1.3
date     91.04.01.15.44.31;  author reiher;  state Dev;
branches ;
next     1.2;

1.2
date     91.03.26.09.31.02;  author pls;  state Dev;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.36;  author configtw;  state Rel;
branches ;
next     ;


desc
@handle object initiation
@


1.10
log
@Added code to support event count throttling
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	objhead.c,v $
 * Revision 1.9  91/11/01  13:25:10  reiher
 * Started initial events' EPTs at zero, added timing code
 * (PLR)
 * 
 * Revision 1.8  91/11/01  09:51:46  pls
 * 1.  Change version id.
 * 2.  Add parm to loadstatebuffer() for bug 15.
 * 
 * Revision 1.7  91/07/17  15:11:19  judy
 * New copyright notice.
 * 
 * Revision 1.6  91/06/03  14:24:21  configtw
 * Change #ifdef to #if
 * 
 * Revision 1.5  91/06/03  12:25:50  configtw
 * Tab conversion.
 * 
 * Revision 1.4  91/05/31  14:57:40  pls
 * Change object type to NULL if destroyed.
 * 
 * Revision 1.3  91/04/01  15:44:31  reiher
 * Code to support Tapas Som's work, plus possibly incorrect code to permit
 * multiple create messages to be delivered to an object without error,
 * provided they are all the same type.
 * 
 * Revision 1.2  91/03/26  09:31:02  pls
 * Add Steve's RBC code.
 * 
 * Revision 1.1  90/08/07  15:40:36  configtw
 * Initial revision
 * 
*/
char objhead_id [] = "@@(#)objhead.c     $Revision: 1.9 $\t$Date: 91/11/01 13:25:10 $\tTIMEWARP";


/*
Purpose:

		The code in objhead.c is intended to select the next message 
		from a running object's input queue, and perform the proper
		action to handle that message.  That action consists largely
		of arranging to have a state available, and calling the
		appropriate routine to handle the particular message type.
		In the current system, the only types of messages that
		objhead(), the main routine here, needs to handle are
		event messages.

Functions:

		objhead(o) - choose the next message from the current object's
				input queue and handle it
				Parameters - Ocb *o
				Returns - SUCCESS or FAILURE

Implementation:

		Look for an unprocessed message in the input queue, by consulting
		the ocb's ci pointer.  If there is no such message, return FAILURE.
		Otherwise, examine the type of the message.
		Try to load a state for this object.  If the attempt fails,
		return FAILURE.  Set the loaded state's send time to the ocb's
		simulation time, set the state type to NOERR, indicate in the
		ocb that an event is being processed,
		indicate that we are in a NONEDGE control mode, and set
		xqting_ocb to o, indicating that this object is the executing 
		one.  Call setctx() to prepare for a switch of execution to 
		the object, and update a counter keeping track of the number of 
		event starts.
*/

#include <stdio.h>
#include "twcommon.h"
#include "twsys.h"

extern FILE * cpulog;

#ifdef MSGTIMER
extern long msgstart, msgend;
extern long msgtime ;
extern long msgcount ;
extern int mlog;
#endif MSGTIMER

dummy_destroy () {}
dummy_init () {}

FUNCTION        objhead (o)
	Ocb            *o;
{
	register Msgh  *m;
	register int i;
	Typtbl * tempType = NULL;

  Debug

#ifdef PARANOID
	if ( gtVTime ( o->svt, o->phase_end ) )
	{
		twerror ( "objhead F object %s phase %f", o->name, o->phase_end.simtime );
		tester ();
	}
#endif

	m = o->ci;
/*
_pprintf("objhead %s msg is 0x%x\n", o->name, m);
_pprintf("prev 0x%x next 0x%x size %d pad %d\n",
		((List_hdr *) m - 1)->prev,
		((List_hdr *) m - 1)->next,
		((List_hdr *) m - 1)->size,
		((List_hdr *) m - 1)->pad );
*/
	if (m->mtype == DYNCRMSG)
	{
	  tempType = ChangeType ( o, m );

	  if ( tempType != (Typtbl *)-1 )
	  {
		  o->typepointer = tempType;
	  }
	  else
	  {
		  o->typepointer = o->cs->otype;
	  }
	}
	else
	if ( m->mtype == DYNDSMSG )
	{
		/*  type_table[1] contains the entry for the NULL type.   Dynamic
				destroy messages always change the object's type to NULL.*/

		o->typepointer = &(type_table[1]);

	}
	else
	{
		o->typepointer = o->cs->otype;
	}

#ifdef RBC
	if ( o->uses_rbc )
	{
		o->pvz_len = 0;
	}
	else
#endif
	o->pvz_len = o->typepointer->statesize;

	o->centry = m->mtype;
	if ( loadstatebuffer(o,tempType) == FAILURE )
	{
		return FAILURE;
	}
	o->sb->stype = o->centry;
	o->sb->sndtim = o->svt;
	o->sb->serror = NOERR;
	o->control = NONEDGE;
	o->sb->stdout_sequence = 0;
	for ( i = 0; i < MAX_TW_STREAMS; i++ )
		o->sb->stream[i].sequence = 0;
	xqting_ocb = o;
#ifdef SOM
/* Ept is calculated for any message type that calls message_vector().
	  The types of messages that don't call that routine are create
	  messages, and they set the Ept separately.  For static messages,
	  it's set to the time of their creation.  For dynamic create messages,
	  it's set to the ept of the create message.
*/
#endif SOM

	switch (m->mtype)
	{

	case CMSG:

		if ( cpulog )
			HOST_fprintf ( cpulog, "O %s\n", o->name );

		o->ecount = 0;
		o->sb->otype = o->typepointer;
#ifdef SOM
	  o->sb->Ept = 0;
#endif SOM
#ifdef RBC
		if ( o->uses_rbc )
		{
			setctx (o->footer, o->typepointer->init, o->stk);
		}
		else
#endif
		setctx (o->sb + 1, o->typepointer->init, o->stk);
		break;

	case EMSG:

		if ( message_vector (o) == FAILURE )
		{
#ifdef RBC
			if ( o->uses_rbc )
				l_destroy ( o->sb );
			else
			/* destroy_state and rollback chip don't mix */
#endif
			destroy_state ( o->sb );

			o->sb = NULL;
			l_destroy ( o->stk );
			o->stk = NULL;
			o->control = EDGE;
#ifdef RBC
			if ( o->uses_rbc && rollback_op ( o, 1, o->svt ) )
			{
				_pprintf ( "objhead weird rbc rollback failure\n" );
				tester();
			}
#endif 
			return FAILURE;
		}

		if ( cpulog )
			HOST_fprintf ( cpulog, "B %s %f %d\n", o->name,
				o->svt.simtime, o->stats.cputime );
#ifdef RBC
		if ( o->uses_rbc )
		{
			setctx (o->footer, o->typepointer->event, o->stk);
		}
		else
#endif
#ifdef MSGTIMER
        	if ( !mlog && m->mtype == EMSG )
			{
				msgstart = m->msgtimef;
			}
#endif MSGTIMER
		setctx (o->sb + 1, o->typepointer->event, o->stk);
		o->stats.numestart++;
		o->eventsPermitted--;
		break;

	case TMSG:

		o->ecount = 0;
		m = nxtigb (m);
		if (m != NULL)
		{
			o->ci = m;
			if ( message_vector (o) == FAILURE )
			{
#ifdef RBC
				if ( o->uses_rbc )
					l_destroy ( o->sb );
				else
				/* destroy_state and rollback chip don't mix */
#endif
				destroy_state ( o->sb );

				o->sb = NULL;
				l_destroy ( o->stk );
				o->stk = NULL;
				o->control = EDGE;
#ifdef RBC
				if ( o->uses_rbc && rollback_op ( o, 1, o->svt ) )
				{
					_pprintf ( "objhead weird rbc rollback failure\n" );
					tester();
				}
#endif 
				return FAILURE;
			}
		}
#ifdef RBC
		if ( o->uses_rbc )
		{
			setctx (o->footer, o->typepointer->term, o->stk);
		}
		else
#endif
		setctx (o->sb + 1, o->typepointer->term, o->stk);
		break;

	case DYNCRMSG:

		if ( cpulog )
			HOST_fprintf ( cpulog, "O %s\n", o->name );

		o->ecount = 0;
		o->sb->otype = o->typepointer;
#ifdef SOM
		o->sb->Ept = m->Ept;
#endif SOM
#ifdef RBC
		if ( o->uses_rbc )
		{
			setctx (o->footer, o->typepointer->init, o->stk);
		}
		else
#endif
		if ( tempType == (Typtbl *)-1 )
		{
			/* In this case, we don't want to rerun the init section, as
				we have a second create message for the object of the same
				kind as the first. */

			setctx (o->sb + 1, dummy_init, o->stk);
		}
		else
		{
			setctx (o->sb + 1, o->typepointer->init, o->stk);
		}
		o->stats.numcreate++;
		break;

	case DYNDSMSG:

		o->ecount = 0;
#ifdef RBC
		if ( o->uses_rbc )
		{
			setctx (o->footer, dummy_destroy, o->stk);
		}
		else
#endif
		setctx(o->sb + 1, dummy_destroy , o->stk);
		o->stats.numdestroy++;
		break;

	default:

		twerror ("objhead E input validity check failure");
		return FAILURE;
	}                           /* end of switch mtype */

	return SUCCESS;
}


FUNCTION message_vector (o)

	Ocb * o;
{
	register Msgh *m;
	register Byte *t;

	Msgh * temp[MAXMSGS];

	register Msgh **v = temp;

	if ( o->msgv != NULL )
	{
		_pprintf ( "message_vector: o->msgv != NULL for %s\n", o->name );
		destroy_message_vector ( o );
	}

	o->ecount = 0;

	for ( m = o->ci; m && m->mtype == o->ci->mtype; m = nxtigb (m) )
	{
		if ( o->ecount == MAXMSGS )
		{
			o->sb->serror = MSGVOFLOW;

			break;
		}

		if ( cpulog )
		{
			if ( o->stats.cputime < m->cputime )
				o->stats.cputime = m->cputime;
		}

		if ( m->txtlen > pktlen )
		{
			twerror ( "message_vector I txtlen > pktlen in objhead" );
			tester();
		}
		else
			t = m_create ( msgdefsize, o->svt, NONCRITICAL );

		if ( t == NULL )
		{
			while ( v != temp )
			{
				v--;

				l_destroy ( (List_hdr *) *v );
			}

			return FAILURE;
		}

		entcpy ( t, m, sizeof(Msgh) + m->txtlen );

		*v++ = (Msgh *) t;

#ifdef SOM

	/* loadstatebuffer() has initialized the new state's Ept to that of the
	  old state, so only the input messages' epts need to be maxed in
	  to find the new Ept. */

	  if ( o->sb->Ept < m->Ept )
	  {
		  o->sb->Ept = m->Ept;
	  }

#endif SOM

		o->ecount++;
	}

	o->msgv = (Msgh **) m_create ( o->ecount * 4, o->svt, NONCRITICAL );

	if ( o->msgv == NULL )
	{
		while ( v != temp )
		{
			v--;

			l_destroy ( (List_hdr *) *v );
		}

		return FAILURE;
	}

	entcpy ( o->msgv, temp, o->ecount * 4 );

	return SUCCESS;
}

destroy_message_vector (o)

	register Ocb * o;
{
	if ( o->msgv != NULL )
	{
		register Msgh ** v = o->msgv;
		register int i;

		for ( i = 0; i < o->ecount; i++ )
		{       /* release memory for each message vector */
			l_destroy ( (List_hdr *) (*v++) );
		}

		l_destroy ( (List_hdr *) o->msgv );     /* release ptr to table */
		o->msgv = NULL;
	}
}

FUNCTION Typtbl * ChangeType(o,m)

	Ocb         *o;
	Msgh        *m;
{
	Crttext *ChangeText;
	Typtbl *NewType;

	ChangeText = (Crttext *) (m + 1);

	NewType = find_object_type (ChangeText->tp);


	if (NewType == NULL)
	{
		NewType = NULL_TYPE;
	}
	else
	{  
	  if ( NewType == o->typepointer )
	  {
		  /*  In this case, we have a second create message for the
			  same object, of the same type.  We want to simply ignore
			  this message.  */

		  return ( (Typtbl *)-1 );
	  }
#if 0
	  else
		_pprintf("ChangeType changing type of %s from %s to %s at %f\n",
			o->name, o->typepointer->type, NewType->type,m->rcvtim.simtime );
#endif
	}

	return (NewType);
}
@


1.9
log
@Started initial events' EPTs at zero, added timing code
(PLR)
@
text
@d7 4
d39 1
a39 1
char objhead_id [] = "@@(#)objhead.c     $Revision: 1.8 $\t$Date: 91/11/01 09:51:46 $\tTIMEWARP";
d157 1
d159 1
d244 1
@


1.8
log
@1.  Change version id.
2.  Add parm to loadstatebuffer() for bug 15.
@
text
@d7 4
d35 1
a35 1
char objhead_id [] = "@@(#)objhead.c     $Revision$\t$Date$\tTIMEWARP";
d79 7
d182 1
a182 1
	  o->sb->Ept = o->Ept;
d230 6
@


1.7
log
@New copyright notice.
@
text
@d7 3
d31 1
a31 1
char objhead_id [] = "@@(#)objhead.c     1.33\t8/1/89\t11:31:37\tTIMEWARP";
d83 1
a83 1
	Typtbl * tempType;
d108 1
a108 1
	  if ( tempType != -1 )
d141 1
a141 1
	if ( loadstatebuffer(o) == FAILURE )
d281 1
a281 1
		if ( tempType == -1 )
d457 1
a457 1
		  return ( -1 );
d461 2
a462 5
		  if (o->typepointer == &(type_table[1]))
			  _pprintf("old type == NULL\n");
		  else
		  _pprintf("Newtype = %x, o->typepointer = %x\n",NewType,
					  o->typepointer);
@


1.6
log
@Change #ifdef to #if
@
text
@d1 4
d7 3
a29 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.5
log
@Tab conversion.
@
text
@d2 4
a5 1
 * $Log:        objhead.c,v $
d452 1
a452 1
#ifdef 0
@


1.4
log
@Change object type to NULL if destroyed.
@
text
@d2 4
a5 1
 * $Log:	objhead.c,v $
d18 1
a18 1
char objhead_id [] = "@@(#)objhead.c	1.33\t8/1/89\t11:31:37\tTIMEWARP";
d20 3
a22 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d27 8
a34 8
	The code in objhead.c is intended to select the next message 
	from a running object's input queue, and perform the proper
	action to handle that message.  That action consists largely
	of arranging to have a state available, and calling the
	appropriate routine to handle the particular message type.
	In the current system, the only types of messages that
	objhead(), the main routine here, needs to handle are
	event messages.
d38 4
a41 4
	objhead(o) - choose the next message from the current object's
		input queue and handle it
		Parameters - Ocb *o
		Returns - SUCCESS or FAILURE
d45 12
a56 12
	Look for an unprocessed message in the input queue, by consulting
	the ocb's ci pointer.  If there is no such message, return FAILURE.
	Otherwise, examine the type of the message.
	Try to load a state for this object.  If the attempt fails,
	return FAILURE.  Set the loaded state's send time to the ocb's
	simulation time, set the state type to NOERR, indicate in the
	ocb that an event is being processed,
	indicate that we are in a NONEDGE control mode, and set
	xqting_ocb to o, indicating that this object is the executing 
	one.  Call setctx() to prepare for a switch of execution to 
	the object, and update a counter keeping track of the number of 
	event starts.
d69 1
a69 1
    Ocb            *o;
d71 3
a73 3
    register Msgh  *m;
    register int i;
    Typtbl * tempType;
d78 5
a82 5
    if ( gtVTime ( o->svt, o->phase_end ) )
    {
	twerror ( "objhead F object %s phase %f", o->name, o->phase_end.simtime );
	tester ();
    }
d85 1
a85 1
    m = o->ci;
d89 4
a92 4
	((List_hdr *) m - 1)->prev,
	((List_hdr *) m - 1)->next,
	((List_hdr *) m - 1)->size,
	((List_hdr *) m - 1)->pad );
d94 3
a96 3
    if (m->mtype == DYNCRMSG)
    {
      tempType = ChangeType ( o, m );
d98 14
a111 14
      if ( tempType != -1 )
      {
          o->typepointer = tempType;
      }
      else
      {
          o->typepointer = o->cs->otype;
      }
    }
    else
    if ( m->mtype == DYNDSMSG )
    {
	/*  type_table[1] contains the entry for the NULL type.   Dynamic
		destroy messages always change the object's type to NULL.*/
d113 1
a113 1
	o->typepointer = &(type_table[1]);
d115 5
a119 5
    }
    else
    {
	o->typepointer = o->cs->otype;
    }
d122 5
a126 5
    if ( o->uses_rbc )
    {
	o->pvz_len = 0;
    }
    else
d128 1
a128 1
    o->pvz_len = o->typepointer->statesize;
d130 11
a140 11
    o->centry = m->mtype;
    if ( loadstatebuffer(o) == FAILURE )
	return FAILURE;
    o->sb->stype = o->centry;
    o->sb->sndtim = o->svt;
    o->sb->serror = NOERR;
    o->control = NONEDGE;
    o->sb->stdout_sequence = 0;
    for ( i = 0; i < MAX_TW_STREAMS; i++ )
	o->sb->stream[i].sequence = 0;
    xqting_ocb = o;
d143 4
a146 4
      The types of messages that don't call that routine are create
      messages, and they set the Ept separately.  For static messages,
      it's set to the time of their creation.  For dynamic create messages,
      it's set to the ept of the create message.
d150 2
a151 2
    switch (m->mtype)
    {
d153 1
a153 1
    case CMSG:
d155 2
a156 2
	if ( cpulog )
	    HOST_fprintf ( cpulog, "O %s\n", o->name );
d158 2
a159 2
	o->ecount = 0;
	o->sb->otype = o->typepointer;
d161 1
a161 1
      o->sb->Ept = o->Ept;
d164 5
a168 5
	if ( o->uses_rbc )
	{
	    setctx (o->footer, o->typepointer->init, o->stk);
	}
	else
d170 2
a171 2
	setctx (o->sb + 1, o->typepointer->init, o->stk);
	break;
d173 1
a173 1
    case EMSG:
d175 2
a176 2
	if ( message_vector (o) == FAILURE )
	{
d178 4
a181 4
	    if ( o->uses_rbc )
		l_destroy ( o->sb );
	    else
	    /* destroy_state and rollback chip don't mix */
d183 1
a183 1
	    destroy_state ( o->sb );
d185 4
a188 4
	    o->sb = NULL;
	    l_destroy ( o->stk );
	    o->stk = NULL;
	    o->control = EDGE;
d190 5
a194 5
	    if ( o->uses_rbc && rollback_op ( o, 1, o->svt ) )
	    {
		_pprintf ( "objhead weird rbc rollback failure\n" );
		tester();
	    }
d196 2
a197 2
	    return FAILURE;
	}
d199 3
a201 3
	if ( cpulog )
	    HOST_fprintf ( cpulog, "B %s %f %d\n", o->name,
		o->svt.simtime, o->stats.cputime );
d203 5
a207 5
	if ( o->uses_rbc )
	{
	    setctx (o->footer, o->typepointer->event, o->stk);
	}
	else
d209 3
a211 3
	setctx (o->sb + 1, o->typepointer->event, o->stk);
	o->stats.numestart++;
	break;
d213 1
a213 1
    case TMSG:
d215 7
a221 7
	o->ecount = 0;
	m = nxtigb (m);
	if (m != NULL)
	{
	    o->ci = m;
	    if ( message_vector (o) == FAILURE )
	    {
d223 4
a226 4
		if ( o->uses_rbc )
		    l_destroy ( o->sb );
		else
		/* destroy_state and rollback chip don't mix */
d228 1
a228 1
		destroy_state ( o->sb );
d230 4
a233 4
		o->sb = NULL;
		l_destroy ( o->stk );
		o->stk = NULL;
		o->control = EDGE;
d235 11
a245 1
		if ( o->uses_rbc && rollback_op ( o, 1, o->svt ) )
d247 1
a247 2
		    _pprintf ( "objhead weird rbc rollback failure\n" );
		    tester();
d249 1
a249 10
#endif 
		return FAILURE;
	    }
	}
#ifdef RBC
	if ( o->uses_rbc )
	{
	    setctx (o->footer, o->typepointer->term, o->stk);
	}
	else
d251 2
a252 2
	setctx (o->sb + 1, o->typepointer->term, o->stk);
	break;
d254 1
a254 1
    case DYNCRMSG:
d256 2
a257 2
	if ( cpulog )
	    HOST_fprintf ( cpulog, "O %s\n", o->name );
d259 2
a260 2
	o->ecount = 0;
	o->sb->otype = o->typepointer;
d262 1
a262 1
	o->sb->Ept = m->Ept;
d265 5
a269 5
	if ( o->uses_rbc )
	{
	    setctx (o->footer, o->typepointer->init, o->stk);
	}
	else
d271 5
a275 5
	if ( tempType == -1 )
	{
	    /* In this case, we don't want to rerun the init section, as
		we have a second create message for the object of the same
		kind as the first. */
d277 8
a284 8
	    setctx (o->sb + 1, dummy_init, o->stk);
	}
	else
	{
	    setctx (o->sb + 1, o->typepointer->init, o->stk);
	}
	o->stats.numcreate++;
	break;
d286 1
a286 1
    case DYNDSMSG:
d288 1
a288 1
	o->ecount = 0;
d290 5
a294 5
	if ( o->uses_rbc )
	{
	    setctx (o->footer, dummy_destroy, o->stk);
	}
	else
d296 3
a298 3
	setctx(o->sb + 1, dummy_destroy , o->stk);
	o->stats.numdestroy++;
	break;
d300 1
a300 1
    default:
d302 3
a304 3
	twerror ("objhead E input validity check failure");
	return FAILURE;
    }				/* end of switch mtype */
d306 1
a306 1
    return SUCCESS;
d312 1
a312 1
    Ocb * o;
d314 2
a315 2
    register Msgh *m;
    register Byte *t;
d317 1
a317 1
    Msgh * temp[MAXMSGS];
d319 1
a319 1
    register Msgh **v = temp;
d321 5
a325 5
    if ( o->msgv != NULL )
    {
	_pprintf ( "message_vector: o->msgv != NULL for %s\n", o->name );
	destroy_message_vector ( o );
    }
d327 1
a327 1
    o->ecount = 0;
d329 1
a329 3
    for ( m = o->ci; m && m->mtype == o->ci->mtype; m = nxtigb (m) )
    {
	if ( o->ecount == MAXMSGS )
d331 3
a333 1
	    o->sb->serror = MSGVOFLOW;
d335 2
a336 2
	    break;
	}
d338 5
a342 5
	if ( cpulog )
	{
	    if ( o->stats.cputime < m->cputime )
		o->stats.cputime = m->cputime;
	}
d344 7
a350 7
	if ( m->txtlen > pktlen )
	{
	    twerror ( "message_vector I txtlen > pktlen in objhead" );
	    tester();
	}
	else
	    t = m_create ( msgdefsize, o->svt, NONCRITICAL );
d352 5
a356 5
	if ( t == NULL )
	{
	    while ( v != temp )
	    {
		v--;
d358 2
a359 2
		l_destroy ( (List_hdr *) *v );
	    }
d361 2
a362 2
	    return FAILURE;
	}
d364 1
a364 1
	entcpy ( t, m, sizeof(Msgh) + m->txtlen );
d366 1
a366 1
	*v++ = (Msgh *) t;
d370 3
a372 3
    /* loadstatebuffer() has initialized the new state's Ept to that of the
      old state, so only the input messages' epts need to be maxed in
      to find the new Ept. */
d374 4
a377 4
      if ( o->sb->Ept < m->Ept )
      {
          o->sb->Ept = m->Ept;
      }
d381 2
a382 2
	o->ecount++;
    }
d384 1
a384 1
    o->msgv = (Msgh **) m_create ( o->ecount * 4, o->svt, NONCRITICAL );
d386 1
a386 3
    if ( o->msgv == NULL )
    {
	while ( v != temp )
d388 3
a390 1
	    v--;
d392 4
a395 1
	    l_destroy ( (List_hdr *) *v );
d398 1
a398 2
	return FAILURE;
    }
d400 1
a400 3
    entcpy ( o->msgv, temp, o->ecount * 4 );

    return SUCCESS;
d405 1
a405 1
    register Ocb * o;
d407 4
a410 4
    if ( o->msgv != NULL )
    {
	register Msgh ** v = o->msgv;
	register int i;
d412 7
a418 3
	for ( i = 0; i < o->ecount; i++ )
	{	/* release memory for each message vector */
	    l_destroy ( (List_hdr *) (*v++) );
a419 4

	l_destroy ( (List_hdr *) o->msgv );	/* release ptr to table */
	o->msgv = NULL;
    }
d424 2
a425 2
    Ocb		*o;
    Msgh	*m;
d427 2
a428 2
    Crttext *ChangeText;
    Typtbl *NewType;
d430 1
a430 1
    ChangeText = (Crttext *) (m + 1);
d432 1
a432 1
    NewType = find_object_type (ChangeText->tp);
d435 11
a445 11
    if (NewType == NULL)
    {
	NewType = NULL_TYPE;
    }
    else
    {  
      if ( NewType == o->typepointer )
      {
          /*  In this case, we have a second create message for the
              same object, of the same type.  We want to simply ignore
              this message.  */
d447 2
a448 2
          return ( -1 );
      }
d450 6
a455 6
      else
          if (o->typepointer == &(type_table[1]))
              _pprintf("old type == NULL\n");
          else
          _pprintf("Newtype = %x, o->typepointer = %x\n",NewType,
                      o->typepointer);
d457 1
a457 1
    }
d459 1
a459 1
    return (NewType);
@


1.3
log
@Code to support Tapas Som's work, plus possibly incorrect code to permit
multiple create messages to be delivered to an object without error,
provided they are all the same type.
@
text
@d3 5
d103 9
@


1.2
log
@Add Steve's RBC code.
@
text
@d3 3
d58 1
d65 1
d88 10
a97 1
	o->typepointer = ChangeType(o,m);
d124 8
d143 3
d244 3
d254 12
a265 1
	setctx (o->sb + 1, o->typepointer->init, o->stk);
d351 13
d421 19
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d73 8
a80 1

d90 7
d98 1
d121 7
d135 6
d142 1
d147 7
d160 7
d180 6
d187 1
d192 7
d202 7
d219 7
d233 7
@
