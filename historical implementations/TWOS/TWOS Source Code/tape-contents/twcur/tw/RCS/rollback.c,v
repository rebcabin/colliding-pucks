head     1.10;
branch   ;
access   ;
symbols  TW2_7:1.10 TW2_6:1.8 TW2_5_1:1.8 TW2_5:1.7 TW2_4_2:1.3 TW2_4_1:1.2 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.10
date     91.12.27.11.18.07;  author pls;  state Rel;
branches ;
next     1.9;

1.9
date     91.12.27.08.48.06;  author reiher;  state Dev;
branches ;
next     1.8;

1.8
date     91.07.17.15.11.56;  author judy;  state Rel;
branches ;
next     1.7;

1.7
date     91.06.03.12.26.29;  author configtw;  state Rel;
branches ;
next     1.6;

1.6
date     91.05.31.15.16.12;  author pls;  state Dev;
branches ;
next     1.5;

1.5
date     91.04.01.15.45.48;  author reiher;  state Dev;
branches ;
next     1.4;

1.4
date     91.03.26.09.37.42;  author pls;  state Dev;
branches ;
next     1.3;

1.3
date     90.12.10.10.52.25;  author configtw;  state Rel;
branches ;
next     1.2;

1.2
date     90.08.09.16.23.11;  author steve;  state Exp;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.49;  author configtw;  state Rel;
branches ;
next     ;


desc
@do rollback
@


1.10
log
@Fix TIMING code.
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	rollback.c,v $
 * Revision 1.9  91/12/27  08:48:06  reiher
 * Added code to support event count and event time throttling
 * 
 * Revision 1.8  91/07/17  15:11:56  judy
 * New copyright notice.
 * 
 * Revision 1.7  91/06/03  12:26:29  configtw
 * Tab conversion.
 * 
 * Revision 1.6  91/05/31  15:16:12  pls
 * Fix migration bugs.
 * 
 * Revision 1.5  91/04/01  15:45:48  reiher
 * Error tests to catch gvt problems.
 * 
 * Revision 1.4  91/03/26  09:37:42  pls
 * 1.  Add Steve's RBC code.
 * 2.  Remove zip forward optimization.
 * 
 * Revision 1.3  90/12/10  10:52:25  configtw
 * use .simtime field as necessary
 * 
 * Revision 1.2  90/08/09  16:23:11  steve
 * Added limited jump forwarded code for phase migration
 * 
 * Revision 1.1  90/08/07  15:40:49  configtw
 * Initial revision
 * 
*/
char rollback_id [] = "@@(#)rollback.c   1.58\t10/6/89\t14:23:00\tTIMEWARP";


/*

Purpose:

		The code in this module is responsible for determining if it
		is necessary to roll back an object, and for performing the 
		rollback if it is necessary.  There are two major routines,
		rollback() and go_forward(), and several smaller routines.

		rollback() is called at time when rollbacks are not necessary,
		so it must check to see if a rollback is needed at each 
		invocation.  If a rollback is not needed, rollback() need do little
		else.  If a rollback is necessary, rollback() has to restore a
		state prior to the requested rollback time.  It also has to check all 
		of the messages in the object's output queue, to see if any
		of them must be sent out as anti-messages.  In actuality,
		rollback() does not, itself, send out anti-messages, because of
		the lazy cancellation strategy used in this version of Time
		Warp.  Rather, it calls unmark_all_output(), to remove the mark from
		all messages over which it rolled back.  As the object re-
		executes its code, it may send out some duplicates, which will
		result in the restoration of the marks on those messages.  After
		the object completes its execution, it will send anti-messages
		for any unmarked objects (again, using go_forward()).  

		go_forward() is responsible for arranging for an object to
		be ready to run at a specific virtual time.  It sets various
		object states to values indicating its readiness, sets up some 
		pointers for the object, puts the object in the correct place
		in the object queue, cancels any messages that need anti-messages
		sent, and sets up the object scheduler virtual time.

		The other routines contained in this module are supporting
		routines for these two routines.

Functions:

		rollback(o,t_to) - if a rollback needs to be performed, do it
				Parameters - Ocb *o, VTime t_to
				Return - Always returns 0

		go_forward(o,t) - take an object forward to a specific time
				Parameters - Ocb *o, VTime t
				Return - Always returns 0

		latest_earlier_state(o,t) - find the right state to roll back to
				Parameters - Ocb *o, VTime t
				Return - a pointer to the state, if found; NULL
						otherwise

		earliest_later_bundle(o,t) - find the first input bundle after time t
				Parameters - Ocb *o, VTime t
				Return - a pointer to the first message in the bundle,
						or NULL pointer if no bundle exists

		specified_output_bundle(o,t) - find an input bundle with time t
				Parameters - Ocb *o, VTime t
				Return - a pointer to the first message in the bundle,
						or NULL pointer if no bundle exists

Implementation:

		rollback() first checks to see if the object in question is the
		stdout object.  This object never rolls back, so further checks 
		are superfluous; the routine simply returns.  Next, a sanity 
		check to make sure that the object is not trying to go to a time
		before gvt is made.  If that passes, check the time of the call
		to the time in the object's scheduler virtual time field.  If the
		specified time is greater than the scheduler_vt, no rollback is needed, 
		so return.

		If a rollback is needed, set the object's svt to the rollback
		time specified in the call.  Call incr_rollbacks() to keep track
		of how many rollbacks were done.  Reset the state saving timer.
		If the object is in the middle of something (indicated by a
		non-EDGE control state), run through the output messages in the
		current bundle, unmarking them, so that the next call to 
		go_forward() will cancel them.  

		Find an state whose time is no later than the time we need to
		roll back to, using latest_earlier_state().  Delete all later
		states in the state queue.  Set the object's current state to
		the old state just recovered.  It may be that the state that
		should be restored is in the object's temporary state buffer,
		rather than in the state queue.  Check for this case here.
		If the temporary state shouldn't be restored, destroy it and
		its associated stack.  Call go_forward() to perform lazy
		cancellation of messages.

		go_forward() is used to take an object forward to its next
		execution time, from the time of its current state.  It can
		be called due to the completion of an object's execution, or
		because of a rollback.  In either case, the purpose is to 
		prepare an object for its next execution.  Towards this purpose,
		set its run status to READY and its control state to EDGE.
		If the state buffer has an entry, set the time of state to
		that entry's time.  Otherwise, set it to the send time of
		the current state pointer.  Call earliest_later_inputbundle()
		to get a pointer to the next set of input messages to be
		processed.  If no such pointer exists, set the object's
		scheduler time to POSINF, move it to the end of the object
		queue, call cancel_omsgs() to cancel any remaining later
		output messages, and set the object's run status to BLKINF.

		Assuming a next bundle was found, the object's scheduler
		time is set to the rcvtime of that bundle.  Then the object
		is inserted into the correct place in the object queue.
		cancel_omsgs() is used to get rid of any messages between
		its last virtual run time and the next virtual run time.

		latest_earlier_state() runs backwards through an object's
		state queue looking for a state earlier than the specified
		one.  Since the state queue is ordered by state time, the
		first one found is the latest earlier state.

		earliest_later_bundle() runs through an object's input queue,
		searching for the next bundle that should be processed.
		Run backwards through the input queue, examining the receive times
		of each bundle; we are looking for the first bundle that is 
		earlier than the specified time.  For each bundle moved over
		backwards, increment the running count of bundles rolled back
		over.  If we find a bundle with the same time as the specified
		time, run forward until one bundle is found whose time is greater
		than the specified one.  Each bundle traversed in this direction
		causes a decrementation of the count of bundles rolled over
		backwards. Return a pointer to the first message in the bundle.

		specified_output_bundle() runs backward through the output
		queue until it finds an output bundle with a time less than
		or equal to the specified time.  Once such a message is found,
		it runs forward through the queue till it finds a message with
		a send time equal to the specified time, or until it runs out
		of messages.

*/

#include "twcommon.h"
#include "twsys.h"

int aggressive = 0; /* true for aggressive cancellation */

enable_aggressive_cancellation ()
{
	aggressive = 1;
}

#ifdef RBC
int addOneMore;
#endif

FUNCTION rollback ( o, t_to )

	register Ocb *o;
	VTime t_to;
{
	if ( o->runstat == ITS_STDOUT )
	{
		return;         /* no rollbacks for stdout */
	}

Debug

	/* If we shipped a state to the next phase without saving it, and we're
		rolling back, don't count it as committed. */

	o->loststate = 0;

	if ( gtVTime ( t_to, o->svt) )
	{
		/* Rollback not necessary */

		return;
	}

	if ( ltVTime ( t_to, gvt ) && gtVTime ( t_to, neginfPlus1 ) )
	{
		_pprintf ( "rollback: object %s t_to %f less than gvt %f\n",
			o->name, t_to.simtime, gvt.simtime );
		tester ();
	}

	o->runstat = GOFWD;

	if ( neVTime ( o->svt, t_to ) )
	{   /* if it's not a rollback to current time */
		register List_hdr * next;

		o->svt = t_to;          /* set rollback time */

if ( ltVTime ( o->svt, gvt))
{
	twerror ("rollback: svt %f set before gvt %f for %s\n",o->svt.simtime,
			  gvt.simtime, o->name);
	tester();
}
		next = l_next_macro ( o );
		l_remove ( o );         /* remove o from object list */
		nqocb ( o, next );      /* reinsert o in new time order */
	}

	if ( o->sb != NULL )
	{
		adjustEffectWork(o, o->sb);     /* subtract off current work */
#ifdef RBC
		if ( o->uses_rbc )
			l_destroy ( o->sb );
		else
		/* destroy_state and rollback chip don't mix */
#endif
		destroy_state ( o->sb );        /* release all state memory */
		o->eventsPermitted++;

		/* can't be last_sent */
		o->sb = NULL;
		if ( o->stk != NULL )
		{
			l_destroy ( o->stk );       /* release temp stack memory */
			o->stk = NULL;
		}
		if ( o->msgv != NULL )
			destroy_message_vector ( o );       /* release this memory */


#ifdef RBC
		addOneMore = 1;
#endif
	}
#ifdef RBC
	else
	{
		addOneMore = 0;
	}
#endif

	cancel_states ( o, t_to );  /* wipe out states >= rollback time */

	if ( aggressive )
		cancel_all_output ( o, t_to );
	else                                /* we're lazy */
		unmark_all_output ( o, t_to );  /* unmark output >= t_to */
}

extern int cancellation_penalty;

FUNCTION cancel_all_output ( ocb, vt )

	Ocb         *ocb;
	VTime       vt;
{
	register Msgh *msg;

	for ( msg = lstomsg_macro ( ocb ); msg; msg = lstomsg_macro ( ocb ) )
	{
		if ( geVTime ( msg->sndtim, vt ) )
		{
			dqomsg ( msg );
			if ( ocb->co == msg )
			{
				ocb->co = NULL;
			}
			mark_macro ( msg );
			smsg_stat ( ocb, msg );
			deliver ( msg );
			ocb->cancellations += cancellation_penalty;
		}
		else
		{
			break;
		}
	}
}

FUNCTION unmark_all_output ( ocb, vt )

/* unmark all messages in the output list with times >= vt */

	Ocb         *ocb;
	VTime       vt;
{
	register Msgh *msg;

	for ( msg = lstomsg_macro ( ocb ); msg; msg = prvomsg_macro ( msg ) )
	{
		if ( geVTime ( msg->sndtim, vt ) )
		{                               /* this msg time >= vt */
			unmark_macro ( msg );       /* so clear the USED bit */
		}
		else
		{
			break;
		}
	}
}

FUNCTION cancel_states ( ocb, vt )

 /* get rid of any states belonging to ocb that are equal or past vt */

   Ocb          *ocb;
   VTime        vt;
{
/*PJH Are we getting into trouble with register here?
	register */
	State *st;
#ifdef RBC
	int count = addOneMore;
#endif

	for ( st = lststate_macro ( ocb ); st; st = lststate_macro ( ocb ) )
	{
		if ( geVTime ( st->sndtim, vt ) )
		{
#ifdef RBC
			count++;
#endif

			ocb->eventTimePermitted += st->effectWork;
			l_remove ( st );            /* remove state from the list */
			if ( ocb->cs == st )
			{                           /* zero the current state */
				ocb->cs = NULL;
			}
			adjustEffectWork(ocb, st);  /* subtract off work time */
			if ( st == ocb->last_sent )
			{
				ocb->out_of_sq = 1;
				/* for the new jump forward op */
			}
			else
#ifdef RBC
				if ( ocb->uses_rbc )
					l_destroy ( st );
				else
				/* destroy_state and rollback chip don't mix */
#endif
				destroy_state ( st );   /* release its memory */
				ocb->eventsPermitted++;
		}
		else
		{
#if 0
			/*  This code will print a message when the ocb's type is about to
				change due to rollback.  It is only temporary, to verify
				that the code is doing what it should do. */

			if ( ocb->typepointer != st->otype )
			{
/*
				_pprintf("rollback changing type of %s from %s to %s\n",
						ocb->name, ocb->typepointer->type, st->otype->type );
*/
			}
#endif

			/*  Restore this ocb's typepointer to the type specified by
				the last remaining state.  This is to handle the case where
				a dynamic create message was cancelled, to ensure that the
				ocb is restored to type NULL. */

			ocb->typepointer = st->otype;

			break;
		}
	}
#ifdef RBC
	if ( ocb->uses_rbc && count )
		rollback_op ( ocb, count, vt );
#endif
}

#ifdef TIMING
#define ROLLBACK_TIMING_MODE 5
#endif

/* We must not return prematurely in the following routine.  Instead,
exit via get_out, so that TIMING will work properly. */

FUNCTION go_forward ( o )

	Ocb * o ;
{
	List_hdr * next;
  Debug

#ifdef TIMING
	start_timing ( ROLLBACK_TIMING_MODE );
#endif

	o->cs = lststate_macro ( o );

	if ( o->cs == NULL )
	{
		o->runstat = BLKSTATE;
		goto get_out;
	}

look_again:

	o->runstat = READY ;
	o->control = EDGE;
	o->co      = NULL;

	o->ci = earliest_later_inputbundle ( o );

	if ( o->ci != NULL )
	{   
			/* Set the object to execute at that virtual time. */
			o->svt = o->ci->rcvtim;
if ( ltVTime ( o->svt, gvt))
{
	twerror ("go_forward: svt %f set before gvt %f for %s\n",o->svt.simtime,
			  gvt.simtime, o->name);
	tester();
}


			/* Cancel any output msgs that come after this msgs virtual time. */
			if ( ! aggressive )
				cancel_omsgs ( o, o->cs->sndtim, o->svt );

			if ( o->runstat != READY ) /* did cancel cause a rollback? */
			{
				o->ci = NULL;   /* was goto look_again */
				next = l_next_macro ( o );
				l_remove ( o );         /* remove o from object list */
				nqocb ( o, next );      /* reinsert o in new time order */
				goto get_out;
			}
			else
			{
				o->co = specified_outputbundle ( o );
			}
	}
	else
	{
		VTime infinity;

		if ( gtVTime ( gvt, posinf ) )
			infinity = posinfPlus1;
		else
			infinity = posinf;

/* If there is no bundle to execute, see why.  If the reason is that
		there really isn't anything to do and nothing is migrating, or that
		the next thing to do is after the virtual time currently in transit,
		don't change svt.  Otherwise, change svt to indicate that the next
		execution is at the later of the current gvt and the virtual time
		in transit.  PLRBUG */

		if ( eqVTime ( o->phase_limit, o->phase_end ) )
				o->svt = infinity;
		else
		if (ltVTime ( o->svt, o->phase_limit ) )
		{
			if ( geVTime ( o->phase_limit, gvt ) )
				o->svt = o->phase_limit;
			else
				o->svt = gvt;
		}

if ( ltVTime ( o->svt, gvt))
{
	twerror ("go_forward (2): svt %f set before gvt %f for %s\n",o->svt.simtime,
			  gvt.simtime, o->name);
	tester();
}

/*
		if ( gtVTime ( infinity, o->phase_limit ) )
			o->svt = o->phase_limit;
		else
			o->svt = infinity;
*/

		o->runstat = BLKINF;

/* Moved test for BLKINF into the !aggressive test, as runstat must be
		BLKINF unless cancel_omsgs () clears it.  PLRBUG */

		if ( ! aggressive )
		{
			cancel_omsgs ( o, o->cs->sndtim, o->svt );

			if ( o->runstat != BLKINF ) /* did cancel cause a rollback? */
				{
				o->ci = NULL;   /* was goto look_again */
				next = l_next_macro ( o );
				l_remove ( o );         /* remove o from object list */
				nqocb ( o, next );      /* reinsert o in new time order */
				goto get_out;
				}
		}
	}

	if ( o->runstat == BLKINF && 
		 ltSTime ( o->phase_end.simtime, posinf.simtime ) )
	{
		State * state;

		state = lststate_macro ( o );

		if ( state != NULL )
			send_state_copy ( state, o );
	}

	{
		register Ocb * next, * prev;

		next = (Ocb *) l_next_macro ( o );
		prev = (Ocb *) l_prev_macro ( o );

		if ( ( ! l_ishead_macro ( next ) && gtVTime ( o->svt, next->svt ) )
		||   ( ! l_ishead_macro ( prev ) && ltVTime ( o->svt, prev->svt ) ) )
		{
			l_remove ( o );
			nqocb ( o, next );
		}
	}

get_out:

	if ( ltVTime ( o->svt, gvt ) && gtVTime ( o->svt, neginfPlus1 ) )
	{
		_pprintf ( "go_forward: object %s svt %f less than gvt %f\n",
			o->name, o->svt.simtime, gvt.simtime );

		if ( o->loststate == 1 )
		{
			_pprintf("go_forward: lost state for this ocb\n");
		}

		tester ();
	}

#ifdef TIMING
	stop_timing ();
#endif
}

FUNCTION Msgh * earliest_later_inputbundle ( o )

	Ocb * o;
{
	VTime t;
	int type;
	Msgh *m, *n;
	int find_count;
	extern int qlog;

Debug

	t = o->cs->sndtim;
	type = o->cs->stype;

#   define MLATER(m)    geVTime ( (m)->rcvtim, t )

	m = o->ci ? o->ci : lstimsg_macro (o);

	find_count = 0;

	/* first, find an earlier or equal time */
	/* Three cases are possible m later than t, */
	/* m Equal t, m earlier than t */

  if ( m != NULL )
  {
	if (MLATER (m))
	{
		/* back up pointer until MNOTLATER */

		for (n = prvimsg_macro (m);; n = prvimsg_macro (m))
		{
			find_count++;

			if (n == NULL)
			{
				/* Ok, there is no earlier bundle, so m must be the */
				/* earliest later one */
				break;          /* bye! */
			}

			else
			if (MLATER (n))
			{
				/* The one before m is STILL later, so keep going */
				m = n;
				continue;
			}

			else                /* MNOTLATER (n) */
			{
				/* n is just now one step too far, so m must be IT */
				break;          /* bye! */
			}
		}
	}

	else
	{
		/* Go to the first later one or NULL */
		for (m = nxtimsg_macro (m);; m = nxtimsg_macro (m))
		{
			find_count++;

			if (m == NULL || MLATER (m))
			{
				/* Got it */
				break;
			}
		}

	}

	/* If we found a bundle, then make sure that we get to the right
		group within the bundle.  Check the type of the group against the
		type provided in the call, to make sure that the subtime of the
		selected message is later.  If there is no later subtime at this
		virtual time, choose the message at the next virtual time. */

	if ( m != NULL && eqVTime ( m->rcvtim, t) )
	{
		for (; m; m =  nxtimsg_macro(m))
		{
			find_count++;

			if ( gtVTime ( m->rcvtim, t ) )
				break;

			if ( m->mtype > type)
				break;
		}
	}
  }

	if ( m != NULL && geVTime ( m->rcvtim, o->phase_limit ) )
		m = NULL;

	return ( m );
}


FUNCTION Msgh * specified_outputbundle ( o )

	register Ocb * o;
{
	register Msgh * m, * p = NULL;

  Debug

	for ( m = lstomsg_macro ( o ); m; m = prvomsg_macro ( m ) )
	{
		if ( eqVTime ( m->sndtim, o->ci->rcvtim ) )
		{
			if ( m->stype == o->ci->mtype )
			{
				unmark_macro ( m );
				p = m;
			}
			else
			if ( m->stype > o->ci->mtype )
			{
				if ( p == NULL )
					p = m;
				break;
			}
		}
		else
		if ( ltVTime ( m->sndtim, o->ci->rcvtim ) )
		{
			if ( p == NULL )
				p = m;
			break;
		}
	}

	if ( p == NULL )
		p = o->oqh;

	return ( p );
}
@


1.9
log
@Added code to support event count and event time throttling
@
text
@d7 3
d392 1
a392 1
			
d413 3
d432 1
a432 1
		return;
d465 1
a465 1
				return;
d528 1
a528 1
				return;
@


1.8
log
@New copyright notice.
@
text
@d7 3
d246 1
d258 1
d351 2
d372 1
@


1.7
log
@Tab conversion.
@
text
@d1 4
d6 4
a9 1
 * $Log:        rollback.c,v $
a31 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.6
log
@Fix migration bugs.
@
text
@d2 4
a5 1
 * $Log:	rollback.c,v $
d23 1
a23 1
char rollback_id [] = "@@(#)rollback.c	1.58\t10/6/89\t14:23:00\tTIMEWARP";
d25 3
a27 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d33 4
a36 4
	The code in this module is responsible for determining if it
	is necessary to roll back an object, and for performing the 
	rollback if it is necessary.  There are two major routines,
	rollback() and go_forward(), and several smaller routines.
d38 15
a52 15
	rollback() is called at time when rollbacks are not necessary,
	so it must check to see if a rollback is needed at each 
	invocation.  If a rollback is not needed, rollback() need do little
	else.  If a rollback is necessary, rollback() has to restore a
	state prior to the requested rollback time.  It also has to check all 
	of the messages in the object's output queue, to see if any
	of them must be sent out as anti-messages.  In actuality,
	rollback() does not, itself, send out anti-messages, because of
	the lazy cancellation strategy used in this version of Time
	Warp.  Rather, it calls unmark_all_output(), to remove the mark from
	all messages over which it rolled back.  As the object re-
	executes its code, it may send out some duplicates, which will
	result in the restoration of the marks on those messages.  After
	the object completes its execution, it will send anti-messages
	for any unmarked objects (again, using go_forward()).  
d54 6
a59 6
	go_forward() is responsible for arranging for an object to
	be ready to run at a specific virtual time.  It sets various
	object states to values indicating its readiness, sets up some 
	pointers for the object, puts the object in the correct place
	in the object queue, cancels any messages that need anti-messages
	sent, and sets up the object scheduler virtual time.
d61 2
a62 2
	The other routines contained in this module are supporting
	routines for these two routines.
d66 3
a68 3
	rollback(o,t_to) - if a rollback needs to be performed, do it
		Parameters - Ocb *o, VTime t_to
		Return - Always returns 0
d70 3
a72 3
	go_forward(o,t) - take an object forward to a specific time
		Parameters - Ocb *o, VTime t
		Return - Always returns 0
d74 4
a77 4
	latest_earlier_state(o,t) - find the right state to roll back to
		Parameters - Ocb *o, VTime t
		Return - a pointer to the state, if found; NULL
			otherwise
d79 4
a82 4
	earliest_later_bundle(o,t) - find the first input bundle after time t
		Parameters - Ocb *o, VTime t
		Return - a pointer to the first message in the bundle,
			or NULL pointer if no bundle exists
d84 4
a87 4
	specified_output_bundle(o,t) - find an input bundle with time t
		Parameters - Ocb *o, VTime t
		Return - a pointer to the first message in the bundle,
			or NULL pointer if no bundle exists
d91 8
a98 8
	rollback() first checks to see if the object in question is the
	stdout object.  This object never rolls back, so further checks 
	are superfluous; the routine simply returns.  Next, a sanity 
	check to make sure that the object is not trying to go to a time
	before gvt is made.  If that passes, check the time of the call
	to the time in the object's scheduler virtual time field.  If the
	specified time is greater than the scheduler_vt, no rollback is needed, 
	so return.
d100 7
a106 7
	If a rollback is needed, set the object's svt to the rollback
	time specified in the call.  Call incr_rollbacks() to keep track
	of how many rollbacks were done.  Reset the state saving timer.
	If the object is in the middle of something (indicated by a
	non-EDGE control state), run through the output messages in the
	current bundle, unmarking them, so that the next call to 
	go_forward() will cancel them.  
d108 9
a116 9
	Find an state whose time is no later than the time we need to
	roll back to, using latest_earlier_state().  Delete all later
	states in the state queue.  Set the object's current state to
	the old state just recovered.  It may be that the state that
	should be restored is in the object's temporary state buffer,
	rather than in the state queue.  Check for this case here.
	If the temporary state shouldn't be restored, destroy it and
	its associated stack.  Call go_forward() to perform lazy
	cancellation of messages.
d118 14
a131 14
	go_forward() is used to take an object forward to its next
	execution time, from the time of its current state.  It can
	be called due to the completion of an object's execution, or
	because of a rollback.  In either case, the purpose is to 
	prepare an object for its next execution.  Towards this purpose,
	set its run status to READY and its control state to EDGE.
	If the state buffer has an entry, set the time of state to
	that entry's time.  Otherwise, set it to the send time of
	the current state pointer.  Call earliest_later_inputbundle()
	to get a pointer to the next set of input messages to be
	processed.  If no such pointer exists, set the object's
	scheduler time to POSINF, move it to the end of the object
	queue, call cancel_omsgs() to cancel any remaining later
	output messages, and set the object's run status to BLKINF.
d133 5
a137 5
	Assuming a next bundle was found, the object's scheduler
	time is set to the rcvtime of that bundle.  Then the object
	is inserted into the correct place in the object queue.
	cancel_omsgs() is used to get rid of any messages between
	its last virtual run time and the next virtual run time.
d139 4
a142 4
	latest_earlier_state() runs backwards through an object's
	state queue looking for a state earlier than the specified
	one.  Since the state queue is ordered by state time, the
	first one found is the latest earlier state.
d144 11
a154 11
	earliest_later_bundle() runs through an object's input queue,
	searching for the next bundle that should be processed.
	Run backwards through the input queue, examining the receive times
	of each bundle; we are looking for the first bundle that is 
	earlier than the specified time.  For each bundle moved over
	backwards, increment the running count of bundles rolled back
	over.  If we find a bundle with the same time as the specified
	time, run forward until one bundle is found whose time is greater
	than the specified one.  Each bundle traversed in this direction
	causes a decrementation of the count of bundles rolled over
	backwards. Return a pointer to the first message in the bundle.
d156 6
a161 6
	specified_output_bundle() runs backward through the output
	queue until it finds an output bundle with a time less than
	or equal to the specified time.  Once such a message is found,
	it runs forward through the queue till it finds a message with
	a send time equal to the specified time, or until it runs out
	of messages.
d172 1
a172 1
    aggressive = 1;
d181 2
a182 2
    register Ocb *o;
    VTime t_to;
d184 4
a187 4
    if ( o->runstat == ITS_STDOUT )
    {
	return;		/* no rollbacks for stdout */
    }
d191 2
a192 2
    /* If we shipped a state to the next phase without saving it, and we're
        rolling back, don't count it as committed. */
d194 1
a194 1
    o->loststate = 0;
d196 3
a198 3
    if ( gtVTime ( t_to, o->svt) )
    {
	/* Rollback not necessary */
d200 2
a201 2
	return;
    }
d203 6
a208 6
    if ( ltVTime ( t_to, gvt ) && gtVTime ( t_to, neginfPlus1 ) )
    {
	_pprintf ( "rollback: object %s t_to %f less than gvt %f\n",
	    o->name, t_to.simtime, gvt.simtime );
	tester ();
    }
d210 1
a210 1
    o->runstat = GOFWD;
d212 3
a214 3
    if ( neVTime ( o->svt, t_to ) )
    {	/* if it's not a rollback to current time */
	register List_hdr * next;
d216 1
a216 1
	o->svt = t_to;		/* set rollback time */
d220 3
a222 3
    twerror ("rollback: svt %f set before gvt %f for %s\n",o->svt.simtime,
              gvt.simtime, o->name);
    tester();
d224 4
a227 4
	next = l_next_macro ( o );
	l_remove ( o );		/* remove o from object list */
	nqocb ( o, next );	/* reinsert o in new time order */
    }
d229 3
a231 3
    if ( o->sb != NULL )
    {
	adjustEffectWork(o, o->sb);	/* subtract off current work */
d233 4
a236 4
	if ( o->uses_rbc )
	    l_destroy ( o->sb );
	else
	/* destroy_state and rollback chip don't mix */
d238 1
a238 1
	destroy_state ( o->sb );	/* release all state memory */
d240 9
a248 9
        /* can't be last_sent */
	o->sb = NULL;
	if ( o->stk != NULL )
	{
	    l_destroy ( o->stk );	/* release temp stack memory */
	    o->stk = NULL;
	}
	if ( o->msgv != NULL )
	    destroy_message_vector ( o );	/* release this memory */
d251 1
a251 1
	addOneMore = 1;
d253 1
a253 1
    }
d255 4
a258 4
    else
    {
	addOneMore = 0;
    }
d261 1
a261 1
    cancel_states ( o, t_to );	/* wipe out states >= rollback time */
d263 4
a266 4
    if ( aggressive )
	cancel_all_output ( o, t_to );
    else				/* we're lazy */
	unmark_all_output ( o, t_to );	/* unmark output >= t_to */
d273 2
a274 2
    Ocb         *ocb;
    VTime       vt;
d276 1
a276 1
    register Msgh *msg;
d278 1
a278 3
    for ( msg = lstomsg_macro ( ocb ); msg; msg = lstomsg_macro ( ocb ) )
    {
	if ( geVTime ( msg->sndtim, vt ) )
d280 16
a295 9
	    dqomsg ( msg );
	    if ( ocb->co == msg )
	    {
		ocb->co = NULL;
	    }
	    mark_macro ( msg );
	    smsg_stat ( ocb, msg );
	    deliver ( msg );
	    ocb->cancellations += cancellation_penalty;
a296 5
	else
	{
	    break;
	}
    }
d303 2
a304 2
    Ocb         *ocb;
    VTime       vt;
d306 1
a306 1
    register Msgh *msg;
d308 1
a308 7
    for ( msg = lstomsg_macro ( ocb ); msg; msg = prvomsg_macro ( msg ) )
    {
	if ( geVTime ( msg->sndtim, vt ) )
	{				/* this msg time >= vt */
	    unmark_macro ( msg );	/* so clear the USED bit */
	}
	else
d310 8
a317 1
	    break;
a318 1
    }
d329 2
a330 2
    register */
    State *st;
d332 1
a332 1
    int count = addOneMore;
d335 1
a335 3
    for ( st = lststate_macro ( ocb ); st; st = lststate_macro ( ocb ) )
    {
	if ( geVTime ( st->sndtim, vt ) )
d337 2
d340 1
a340 1
	    count++;
d342 12
a353 12
	    l_remove ( st );		/* remove state from the list */
	    if ( ocb->cs == st )
	    {				/* zero the current state */
		ocb->cs = NULL;
	    }
	    adjustEffectWork(ocb, st);	/* subtract off work time */
	    if ( st == ocb->last_sent )
	    {
		ocb->out_of_sq = 1;
	        /* for the new jump forward op */
	    }
	    else
d355 7
a361 2
		if ( ocb->uses_rbc )
		    l_destroy ( st );
d363 1
a363 6
		/* destroy_state and rollback chip don't mix */
#endif
		destroy_state ( st );	/* release its memory */
	}
	else
	{
d365 3
a367 3
	    /*  This code will print a message when the ocb's type is about to
		change due to rollback.  It is only temporary, to verify
		that the code is doing what it should do. */
d369 2
a370 2
	    if ( ocb->typepointer != st->otype )
	    {
d372 2
a373 2
		_pprintf("rollback changing type of %s from %s to %s\n",
			ocb->name, ocb->typepointer->type, st->otype->type );
d375 1
a375 1
	    }
d377 5
a381 5
	    
	    /*  Restore this ocb's typepointer to the type specified by
		the last remaining state.  This is to handle the case where
		a dynamic create message was cancelled, to ensure that the
		ocb is restored to type NULL. */
d383 1
a383 1
	    ocb->typepointer = st->otype;
d385 2
a386 1
	    break;
a387 1
    }
d389 2
a390 2
    if ( ocb->uses_rbc && count )
	rollback_op ( ocb, count, vt );
d400 1
a400 1
    Ocb * o ;
d402 1
a402 1
    List_hdr * next;
d406 1
a406 1
    start_timing ( ROLLBACK_TIMING_MODE );
d409 1
a409 1
    o->cs = lststate_macro ( o );
d411 5
a415 5
    if ( o->cs == NULL )
    {
	o->runstat = BLKSTATE;
	return;
    }
d419 3
a421 3
    o->runstat = READY ;
    o->control = EDGE;
    o->co      = NULL;
d423 1
a423 1
    o->ci = earliest_later_inputbundle ( o );
d425 4
a428 4
    if ( o->ci != NULL )
    {   
	    /* Set the object to execute at that virtual time. */
    	    o->svt = o->ci->rcvtim;
d431 3
a433 3
    twerror ("go_forward: svt %f set before gvt %f for %s\n",o->svt.simtime,
              gvt.simtime, o->name);
    tester();
d437 3
a439 3
	    /* Cancel any output msgs that come after this msgs virtual time. */
	    if ( ! aggressive )
	        cancel_omsgs ( o, o->cs->sndtim, o->svt );
d441 13
a453 19
	    if ( o->runstat != READY ) /* did cancel cause a rollback? */
	    {
	        o->ci = NULL;	/* was goto look_again */
		next = l_next_macro ( o );
		l_remove ( o );		/* remove o from object list */
		nqocb ( o, next );	/* reinsert o in new time order */
		return;
	    }
	    else
	    {
	        o->co = specified_outputbundle ( o );
	    }
    }
    else
    {
	VTime infinity;

	if ( gtVTime ( gvt, posinf ) )
	    infinity = posinfPlus1;
d455 2
a456 1
	    infinity = posinf;
d458 5
d464 5
a468 5
	there really isn't anything to do and nothing is migrating, or that
	the next thing to do is after the virtual time currently in transit,
	don't change svt.  Otherwise, change svt to indicate that the next
	execution is at the later of the current gvt and the virtual time
	in transit.  PLRBUG */
d470 10
a479 10
	if ( eqVTime ( o->phase_limit, o->phase_end ) )
		o->svt = infinity;
	else
	if (ltVTime ( o->svt, o->phase_limit ) )
	{
	    if ( geVTime ( o->phase_limit, gvt ) )
		o->svt = o->phase_limit;
	    else
		o->svt = gvt;
	}
d483 3
a485 3
    twerror ("go_forward (2): svt %f set before gvt %f for %s\n",o->svt.simtime,
              gvt.simtime, o->name);
    tester();
d489 4
a492 4
	if ( gtVTime ( infinity, o->phase_limit ) )
	    o->svt = o->phase_limit;
	else
	    o->svt = infinity;
d495 1
a495 1
	o->runstat = BLKINF;
d498 1
a498 1
	BLKINF unless cancel_omsgs () clears it.  PLRBUG */
d500 3
a502 3
	if ( ! aggressive )
 	{
	    cancel_omsgs ( o, o->cs->sndtim, o->svt );
d504 8
a511 7
	    if ( o->runstat != BLKINF ) /* did cancel cause a rollback? */
		{
	        o->ci = NULL;	/* was goto look_again */
		next = l_next_macro ( o );
		l_remove ( o );		/* remove o from object list */
		nqocb ( o, next );	/* reinsert o in new time order */
	   	return;
a513 1
    }
d515 4
a518 4
    if ( o->runstat == BLKINF && 
	 ltSTime ( o->phase_end.simtime, posinf.simtime ) )
    {
	State * state;
d520 1
a520 1
	state = lststate_macro ( o );
d522 3
a524 3
	if ( state != NULL )
	    send_state_copy ( state, o );
    }
d526 2
a527 2
    {
	register Ocb * next, * prev;
d529 2
a530 2
	next = (Ocb *) l_next_macro ( o );
	prev = (Ocb *) l_prev_macro ( o );
d532 6
a537 5
	if ( ( ! l_ishead_macro ( next ) && gtVTime ( o->svt, next->svt ) )
	||   ( ! l_ishead_macro ( prev ) && ltVTime ( o->svt, prev->svt ) ) )
	{
	    l_remove ( o );
	    nqocb ( o, next );
a538 1
    }
d542 4
a545 4
    if ( ltVTime ( o->svt, gvt ) && gtVTime ( o->svt, neginfPlus1 ) )
    {
	_pprintf ( "go_forward: object %s svt %f less than gvt %f\n",
	    o->name, o->svt.simtime, gvt.simtime );
d547 6
a552 3
	if ( o->loststate == 1 )
	{
	    _pprintf("go_forward: lost state for this ocb\n");
a554 3
	tester ();
    }

d556 1
a556 1
    stop_timing ();
d562 1
a562 1
    Ocb * o;
d564 5
a568 5
    VTime t;
    int type;
    Msgh *m, *n;
    int find_count;
    extern int qlog;
d572 2
a573 2
    t = o->cs->sndtim;
    type = o->cs->stype;
d577 1
a577 1
    m = o->ci ? o->ci : lstimsg_macro (o);
d579 1
a579 1
    find_count = 0;
d581 3
a583 3
    /* first, find an earlier or equal time */
    /* Three cases are possible m later than t, */
    /* m Equal t, m earlier than t */
d587 1
a587 5
    if (MLATER (m))
    {
	/* back up pointer until MNOTLATER */

	for (n = prvimsg_macro (m);; n = prvimsg_macro (m))
d589 1
a589 1
	    find_count++;
d591 3
a593 6
	    if (n == NULL)
	    {
		/* Ok, there is no earlier bundle, so m must be the */
		/* earliest later one */
		break;		/* bye! */
	    }
d595 6
a600 7
	    else
	    if (MLATER (n))
	    {
		/* The one before m is STILL later, so keep going */
		m = n;
		continue;
	    }
d602 14
a615 5
	    else		/* MNOTLATER (n) */
	    {
		/* n is just now one step too far, so m must be IT */
		break;		/* bye! */
	    }
a616 1
    }
d618 1
a618 4
    else
    {
	/* Go to the first later one or NULL */
	for (m = nxtimsg_macro (m);; m = nxtimsg_macro (m))
d620 4
a623 1
	    find_count++;
d625 7
a631 5
	    if (m == NULL || MLATER (m))
	    {
		/* Got it */
		break;
	    }
d634 5
a638 1
    }
d640 5
a644 5
    /* If we found a bundle, then make sure that we get to the right
	group within the bundle.  Check the type of the group against the
	type provided in the call, to make sure that the subtime of the
	selected message is later.  If there is no later subtime at this
	virtual time, choose the message at the next virtual time. */
d646 2
a647 5
    if ( m != NULL && eqVTime ( m->rcvtim, t) )
    {
	for (; m; m =  nxtimsg_macro(m))
 	{
	    find_count++;
d649 4
a652 7
	    if ( gtVTime ( m->rcvtim, t ) )
		break;

	    if ( m->mtype > type)
		break;
  	}
    }
d655 2
a656 2
    if ( m != NULL && geVTime ( m->rcvtim, o->phase_limit ) )
	m = NULL;
d658 1
a658 1
    return ( m );
d664 1
a664 1
    register Ocb * o;
d666 1
a666 1
    register Msgh * m, * p = NULL;
d670 1
a670 3
    for ( m = lstomsg_macro ( o ); m; m = prvomsg_macro ( m ) )
    {
	if ( eqVTime ( m->sndtim, o->ci->rcvtim ) )
d672 22
a693 12
	    if ( m->stype == o->ci->mtype )
	    {
		unmark_macro ( m );
		p = m;
	    }
	    else
	    if ( m->stype > o->ci->mtype )
	    {
		if ( p == NULL )
		    p = m;
		break;
	    }
a694 8
	else
	if ( ltVTime ( m->sndtim, o->ci->rcvtim ) )
	{
	    if ( p == NULL )
		p = m;
	    break;
	}
    }
d696 2
a697 2
    if ( p == NULL )
	p = o->oqh;
d699 1
a699 1
    return ( p );
@


1.5
log
@Error tests to catch gvt problems.
@
text
@d3 3
d59 1
a59 3
	routines for these two routines, except for loadstatebuffer(),
	which is a misplaced supporting routine for code contained in
	objhead.c
a85 4
	loadstatebuffer(o) - set up an active state for the object to run in
		Parameters - Ocb *o
		Return - SUCCESS or FAILURE

a159 11
	loadstatebuffer() checks to see if the object's state buffer is
	already loaded, returning success if it is.  Otherwise, the
	routine looks into the cs pointer to find a state.  If there
	is no state there either, an error has occurred.  If a state
	is found, m_create() is used to allocate space for the temporary
	state buffer, and for the associated stack.  If space is unavailable,
	then any work done in this routine is undone, and FAILURE is 
	returned.  If the m_create()s succeed, the current state is copied
	into the temporary state with entcpy(), and the stack is initialized.
	SUCCESS is returned.

d361 21
d399 1
d441 3
d504 3
d512 2
d515 9
a536 11
    if ( o->runstat == BLKINF && 
	 ltSTime ( o->phase_end.simtime, posinf.simtime ) )
    {
	State * state;

	state = lststate_macro ( o );

	if ( state != NULL )
	    send_state_copy ( state, o );
    }

d543 1
a543 1
/*
a549 1
*/
@


1.4
log
@1.  Add Steve's RBC code.
2.  Remove zip forward optimization.
@
text
@d3 4
d228 7
d418 6
d425 1
d466 7
@


1.3
log
@use .simtime field as necessary
@
text
@d3 3
d37 1
a37 1
	Warp.  Rather, it calls go_forward(), to remove the mark from
d182 4
d232 6
d239 1
d249 4
d254 6
d331 3
d339 3
d354 6
d367 4
d414 2
a415 1
	        goto look_again;
d466 4
a469 1
	   	goto look_again;
@


1.2
log
@Added limited jump forwarded code for phase migration
@
text
@d3 3
d443 2
a444 1
    if ( o->runstat == BLKINF && ltSTime ( o->phase_end.simtime, posinf ) )
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d223 1
d315 7
a321 1
	    destroy_state ( st );	/* release its memory */
d456 6
d463 1
@
