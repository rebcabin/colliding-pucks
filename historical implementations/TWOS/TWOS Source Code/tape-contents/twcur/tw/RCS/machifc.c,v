head     1.8;
branch   ;
access   ;
symbols  TW2_7:1.8 TW2_6:1.8 TW2_5_1:1.7 TW2_5:1.5 TW2_4_2:1.2 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.8
date     91.11.01.09.41.12;  author pls;  state Rel;
branches ;
next     1.7;

1.7
date     91.07.17.15.09.41;  author judy;  state Rel;
branches ;
next     1.6;

1.6
date     91.07.09.14.22.19;  author steve;  state Dev;
branches ;
next     1.5;

1.5
date     91.06.03.12.24.48;  author configtw;  state Rel;
branches ;
next     1.4;

1.4
date     91.05.31.13.29.51;  author pls;  state Dev;
branches ;
next     1.3;

1.3
date     91.04.01.15.39.40;  author reiher;  state Dev;
branches ;
next     1.2;

1.2
date     90.11.27.09.41.28;  author csupport;  state Rel;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.06;  author configtw;  state Rel;
branches ;
next     ;


desc
@machine interface routines
@


1.8
log
@1.  Change ifdef's, version id.
2.  denymsg() fix to not lose memory on Sun's.
3.  Eliminate error in sndmsg() for node 0 to node 0 message.
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	machifc.c,v $
 * Revision 1.7  91/07/17  15:09:41  judy
 * New copyright notice.
 * 
 * Revision 1.6  91/07/09  14:22:19  steve
 * Added support for Sun receive queue in acceptmsg and r_min. Removed 
 * mistuff. Replaced 128 with IH_NODE.
 * 
 * Revision 1.5  91/06/03  12:24:48  configtw
 * Tab conversion.
 *
 * Revision 1.4  91/05/31  13:29:51  pls
 * 1.  Check for rm_msg NULL in peekmsg() (bug 7).
 * 2.  Add PARANOID code to validate state in setctx().
 *
 * Revision 1.3  91/04/01  15:39:40  reiher
 * A bug fix to make sure IH messages aren't considered in GVT calculation,
 * plus a number of tests to catch gvt problems.
 * 
 * Revision 1.2  90/11/27  09:41:28  csupport
 * comment out GVT repetition warning messages
 * 
 * Revision 1.1  90/08/07  15:40:06  configtw
 * Initial revision
 * 
*/
char machifc_id [] = "@@(#)machifc.c     $Revision$\t$Date$\tTIMEWARP";


/* 

Purpose:

		machifc.c contains code that is the machine interface for Time
		Warp.  Most of the code deals with low level message sending
		activities.  Some of it concerns context switching.

Functions:

		timrint(gvttimrproc) - arrange for a procedure to be called when the
						timer expires
				Parameters -  int (*gvttimrproc) ()
				Return - Always returns SUCCESS

		peekmsg() - look at the message in rm_msg
				Parameters - none
				Return - a pointer to the message

		acceptmsg(tw_msg) - put tw_msg in the rm_buf buffer
				Parameters - Msgh * tw_msg
				Return - Always returns zero

		denymsg(tw_msg) - return a message to its sender
				Parameters - Msgh * tw_msg
				Return - returns zero, or exits

		sndmsg(tw_msg,length,node) - put a message into an output queue
				Parameters -  Msgh * tw_msg, Int length, Int node
				Return - SUCCESS or crashes

		brdcst(tw_msg,length) - send a broadcast message, using the broadcast
						capability, if present; send iteratively to all
						nodes, if not
				Parameters - Msgh * tw_msg, Int length
				Return - SUCCESS or crashes

		setctx(state,entry_point,stack) - prepare for a context switch
				Parameters - State * state, Byte * entry_point, Byte * stack
				Return - Always returns zero

		setnull() - clear an object context
				Parameters - none
				Return - Always returns zero

Implementation:

		timrint() sets a function pointer variable to some value so 
		that some particular function can be called when the main()
		loop has determined that the timer counter has reached a certain
		value. 

		peekmsg() locks rm_msg and returns a pointer to it.

		acceptmsg() puts its message into rm_buf, and unlocks rm_msg.

		denymsg() reverses the sender and receiver of rm_msg, and calls
		send_message() to return it to its sender.  

		logmsg() finds the message in the ack[] array with the minimum
		send time.  If that time is less than min_msg_time, min_msg_time
		is set to this lower value.  This routine is used in conjunction
		with gvt calculation.

		minmsg() looks through the pmq[] table's message queues, searching
		for the message with the min rcvtim.  This routine, also, is used
		in conjunction with gvt calculation.  minmsg() looks at the times
		of messages waiting to be sent, logmsg() looks at the times of 
		messages that have been sent, but not yet acked.

		sndmsg() fills in some fields on header of the message to be sent.
		It calculates the checksum(), if that's being done, and stores it
		in the header.  If we're sending an EMSG to node IH_NODE of a Mark3,
		call stdout_msg() for it.  Whether or not we're on a Mark3, if node 
		is IH_NODE and tw_node_num is 0, call ih_msgproc() and destroy_msg().
		Otherwise, call enq_msg() and send_from_q().  

		brdcst() first fills in some message fields.  If we don't have
		a low-level broadcasting ability, set the brdcst_flag[] entry
		for each node to 1.  Call send_from_q().  

		setctx() prepares for a switch of context by setting certain
		pointers, such as object_data.

		setnull() nulls the object_context pointer.
*/


#include <stdio.h>  
#include "twcommon.h"
#include "twsys.h"
#include "tester.h"
#include "machdep.h"

extern Byte * object_context;
extern Byte * object_data;
extern char brdcst_flag[];

FUNCTION timrint ( gvttimrproc )

	int ( * gvttimrproc ) ();
{
  Debug

	timrproc = gvttimrproc;     /* routine to initiate */

	timeon ();                  /* set the interrupt timer */

	return ( SUCCESS );
}

#if DLM

FUNCTION timlint ( loadtimrproc )

	int ( * loadtimrproc ) ();
{
  Debug


	timlproc = loadtimrproc;

	timelon ();

	return ( SUCCESS );
}
#endif DLM


Msgh *
FUNCTION peekmsg ()
{
  Debug

	if (rm_msg != NULLMSGH)
		lock_macro ( rm_msg );

	return ( rm_msg );
}

FUNCTION acceptmsg ( tw_msg )

	Msgh * tw_msg;
{
  Debug

	if ( tw_msg != NULL )
	{  /* copy to tw_msg */
		entcpy ( tw_msg, rm_msg, rm_msg->txtlen + sizeof (Msgh) );

		unlock_macro ( tw_msg );        /* unlock it */
	}

#if MARK3
	if ( rm_msg == (Msgh *) recv.buf )
	{
		give_buf ( &recv );
	}
#endif

#if BBN
	if ( rm_msg != (Msgh *) rm_buf  && rm_msg !=NULL )
		l_destroy ( rm_msg );   /* get rid of message storage */
#endif

#if SUN
	if ( rm_msg != (Msgh *) rm_buf  && rm_msg !=NULL )
		l_destroy ( rm_msg );   /* get rid of message storage */
#endif

	rm_msg = NULL;
}

/*The following comment makes lint shut up.  Please do not delete it. */
/*ARGSUSED*/
FUNCTION denymsg ( tw_msg )

	Msgh * tw_msg;
{
	int node, len, res, i;
	Msgh * msg;

  Debug

	if ( no_message_sendback )
	{
		_pprintf ( "Denymsg Called\n" );
		tw_exit ( 0 );
	}

#ifndef BBN
	if ( acks_pending == MAX_ACKS )
	{
		_pprintf ( "Denymsg & MAX_ACKS: %x\n", rm_msg );
		tester ();
	}
#endif

	msg = rm_msg;

	node = msg->low.from_node;     /* from node */

	msg->low.from_node = tw_node_num;      /* from node */
	msg->low.to_node = node;     /* to node */
/*
	msg->low.type = NORMAL_MSG;        * Ack flag *
*/

	len = msg->txtlen + sizeof ( Msgh );

	unlock_macro ( msg );

#if MARK3
	send_message ( msg, len, node, NORMAL_MSG );
#else
	for ( ;; )
	{
		for ( i = 0; i < 1000; i++ )
		{
			res = send_message ( msg, len, node, NORMAL_MSG );

			if ( res != -1 )
				break;
		}
		if ( i < 1000 )
			break;

		_pprintf ( "Denymsg stuck writing to Node %d\n", node );
	}
#endif

	if ( ! ( msg->flags & MOVING ) )
		log_ack_pending ( msg, node );

#if MARK3
	if ( rm_msg == (Msgh *) recv.buf )
	{
		give_buf ( &recv );
	}
#endif

#if BBN || SUN
	if ( rm_msg != (Msgh *) rm_buf )
		l_destroy ( rm_msg );
#endif

	rm_msg = NULL;
}

FUNCTION logmsg ()
{
#if BBN
  Debug

	/* find minimum of messages sent but not yet ack'd */
	min_msg_time = butterfly_min ();
if ( ltVTime ( min_msg_time, gvt ) )
{
_pprintf("min_msg_time %f below gvt %f in logmsg\n",min_msg_time.simtime,
	  gvt.simtime);
tester();
}
#else
	register int i, n;

  Debug

	min_msg_time = posinfPlus1;

	for ( i = 0, n = acks_pending; n > 0; i++ )
	{
		if ( ack[i].busy )
		{
			n--;

			if ( ltVTime ( ack[i].time, min_msg_time ) )
			{
				min_msg_time = ack[i].time;
			}
		}
	}
if ( ltVTime ( min_msg_time, gvt ) )
{
_pprintf("this code should be ifdefed out!; min_msg_time %f set below gvt %f\n",
			  min_msg_time.simtime, gvt.simtime );
tester();
}
#endif
}

#if DLM
extern VTime oldgvt1 ;
extern VTime oldgvt2 ;
#endif DLM

/* calculate minimum time based on migrating objects, min_msg_time,
   pmq and rmq */


FUNCTION minmsg ( t )

	VTime * t;
{
	register Msgh * msg;
	VTime min;
#if BBN
	VTime r_min();
#endif
#if SUN
	VTime r_min();
#endif
#if DLM
	int gvtMatch;
#endif DLM

	min = migr_min ();  /* calculate minimum time for migrating objects */

if ( ltVTime ( min, gvt ) )
{
_pprintf("in minmsg, min %f less than gvt %f after migr_min\n",
	  min.simtime, gvt.simtime);
tester();
}
#if DLM
	gvtMatch = 0;
	if ( oldgvt2.simtime != NEGINF  && 
		eqVTime ( min, oldgvt1 ) && 
		eqVTime ( oldgvt1, oldgvt2 ) )
	{
		gvtMatch = 1;
/*
		_pprintf ( "GVT %f repeats three times, after migr_min() \n",
						min.simtime);
*/
	}
#endif DLM

	if ( gtVTime ( min, min_msg_time ) )
		min = min_msg_time;     /* minimize on min_msg_time */

if ( ltVTime ( min, gvt ) )
{
_pprintf("in minmsg, min %f less than gvt %f after checking min_msg_time\n",
	  min.simtime, gvt.simtime);
tester();
}
#if DLM
	if ( !gvtMatch && oldgvt2.simtime != NEGINF  && 
		eqVTime ( min, oldgvt1 ) &&
		eqVTime ( oldgvt1, oldgvt2 ) )
	{
		gvtMatch = 1;
/*
		_pprintf ( "GVT %f repeats three times, after min_msg_time check \n",
						min.simtime);
*/
	}
#endif DLM

	for ( msg = (Msgh *) l_next_macro ( pmq );
			  ! l_ishead_macro ( msg );
		  msg = (Msgh *) l_next_macro ( msg ) )
	{  /* cycle through node's message output queue */
		if ( issys_macro ( msg ) )
			continue;   /* skip system messages */
		if ( strcmp ( msg->rcver, "$IH") == 0 )
			continue;  /* skip msgs to the IH */
		if ( ! ( msg->flags & MOVING ) )
		{  /* object is not in process of moving */
			if ( gtVTime ( min, msg->sndtim ) )
				min = msg->sndtim;      /* minimize on sndtim */

			if ( isposi_macro ( msg ) )
				break;  /* break on positive message */
		}
	}

#if DLM
if ( ltVTime ( min, gvt ) )
{
_pprintf("in minmsg, min %f less than gvt %f after checking output queue\n",
	  min.simtime, gvt.simtime);
tester();
}
	if ( !gvtMatch && oldgvt2.simtime != NEGINF  && 
		eqVTime ( min, oldgvt1 ) && 
		eqVTime ( oldgvt1, oldgvt2 ) )
	{
		gvtMatch = 1;
/*
		_pprintf ( "GVT %f repeats three times, after pmq check \n",
						min.simtime);
*/
	}
#endif DLM
#if BBN
	min = r_min ( min );        /* minimize over node's input msg queue */
   if ( ltVTime ( min, gvt ) )
{
_pprintf("in minmsg, min %f less than gvt %f after r_min\n",
	  min.simtime, gvt.simtime);
tester();
}

#endif
#if SUN
	min = r_min ( min );        /* minimize over node's input msg queue */
   if ( ltVTime ( min, gvt ) )
{
_pprintf("in minmsg, min %f less than gvt %f after r_min\n",
	  min.simtime, gvt.simtime);
tester();
}

#endif

#if DLM
	if ( !gvtMatch && oldgvt2.simtime != NEGINF  && 
		eqVTime ( min, oldgvt1 ) && 
		eqVTime ( oldgvt1, oldgvt2 ) )
	{
/*
		_pprintf ( "GVT %f repeats three times, after r_min check \n",
						min.simtime);
*/
	}
#endif DLM
	*t = min;   /* pass back the minimum time */

  Debug
}


FUNCTION sndmsg ( tw_msg, length, node )

	Msgh * tw_msg;
	Int length;
	Int node;
{
	register LowLevelMsgH * ll_msg = (LowLevelMsgH *) tw_msg;
  Debug

#if TIMING
	start_timing ( TESTER_TIMING_MODE );
#endif
	ll_msg->from_node = tw_node_num;   /* from node */
	ll_msg->to_node = node;          /* to node */
	ll_msg->type = NORMAL_MSG;             /* ack flag */
	ll_msg->length = length;

	tw_msg->txtlen = length - sizeof ( Msgh );
/*
	tw_msg->low.from_node = tw_node_num;  
	tw_msg->low.to_node = node;        
	tw_msg->low.type = NORMAL_MSG;          

	tw_msg->txtlen = length - sizeof ( Msgh );
*/
#if CHECKSUM
	tw_msg->checksum = checksum ( tw_msg );
#endif

	if ( node == IH_NODE )
	{
#if MARK3 || BBN
		if ( tw_msg->mtype == EMSG )
		{  /* event message */
			stdout_msg ( tw_msg );      /* send to stdout */

			goto sndmsg_end;            /* and finish up */
		}
		else                            /* not event message */
		if ( tw_msg->mtype == SIM_END_MSG
		&& ( ! no_stdout ) )
		{
			save_sim_end_msg = tw_msg;  /* the simulation is done */
			messages_to_send++;
			goto sndmsg_end;
		}
#endif
		if ( tw_node_num == 0 )
		{  /* if we're on node 0 */
			if ( rm_msg != NULL )
			{
				r_enq(tw_msg);
				_pprintf ( "rm_msg not Null!\n" );
				goto sndmsg_end;
			}

			rm_msg = tw_msg;

			ih_msgproc ( tw_msg );      /* handle the message */

			goto sndmsg_end;            /* finish up */
		}
		else
		{  /* we're not on node 0 */
			node = 0;           /* send IH messages to node 0 */
			/* ???must change it below too */
			/* it is a mistake to change this in the message
			since the main loop uses this to check for an ih_msgproc
			bound message */
		}
	}

	enq_msg ( tw_msg );         /* put msg in output queue */

	send_from_q ();             /* send out messages in queue */

sndmsg_end:

#if TIMING
	stop_timing ();
#endif

	return ( SUCCESS );
}

FUNCTION brdcst ( tw_msg, length )

	register Msgh * tw_msg;
	register Int length;
{
	register int node;

  Debug

#if TIMING
	start_timing ( TESTER_TIMING_MODE );
#endif

	tw_msg->low.from_node = tw_node_num;
	tw_msg->low.to_node = ALL;
	tw_msg->low.type = NORMAL_MSG;
	tw_msg->low.length = length;

	tw_msg->txtlen = length - sizeof ( Msgh );

#if CHECKSUM
	tw_msg->checksum = checksum ( tw_msg );
#endif

	if ( brdcst_msg != NULL )
	{
		_pprintf ( "brdcst_msg overwrite\n" );
		crash ();
	}

	brdcst_msg = tw_msg;        /* point to the message */

#ifndef BRDCST_ABLE
	for ( node = 0; node < tw_num_nodes; node++ )
	{
		if ( node != tw_node_num )
			brdcst_flag[node] = 1;
	}
#endif

	messages_to_send++;

	send_from_q ();     /* this does the send */

#if TIMING
	stop_timing ();
#endif

	return ( SUCCESS );
}

FUNCTION setctx ( state, entry_point, stack )

	State * state;
	Byte * entry_point;
	Byte * stack;
{
  Debug

#if PARANOID
	validState(state - 1);
#endif
	object_data    = (Byte *)state;
	object_context = stack + objstksize;

	if ( entry_point != NULL )
		* ( (Byte **) (object_context-4) ) = entry_point;
}

FUNCTION setnull ()
{
  Debug

	object_context = NULL;
}
@


1.7
log
@New copyright notice.
@
text
@d7 3
d32 1
a32 1
char machifc_id [] = "@@(#)machifc.c     1.36\t9/26/89\t15:36:46\tTIMEWARP";
d146 1
a146 1
#ifdef DLM
d188 1
a188 1
#ifdef MARK3
d195 1
a195 1
#ifdef BBN
d200 1
a200 1
#ifdef SUN
d247 1
a247 1
#ifdef MARK3
d269 1
a269 1
#ifdef MARK3
d276 1
a276 1
#ifdef BBN
d286 1
a286 1
#ifdef BBN
d325 1
a325 1
#ifdef DLM
d340 1
a340 1
#ifdef BBN
d343 1
a343 1
#ifdef SUN
d346 1
a346 1
#ifdef DLM
d358 1
a358 1
#ifdef DLM
d381 1
a381 1
#ifdef DLM
d412 1
a412 1
#ifdef DLM
d430 1
a430 1
#ifdef BBN
d440 1
a440 1
#ifdef SUN
d451 1
a451 1
#ifdef DLM
d477 1
a477 1
#ifdef TIMING
d493 1
a493 1
#ifdef CHECKSUM
d499 1
a499 1
#ifdef MARK3_OR_BBN
d519 1
d521 1
a521 1
				tester ();
d546 1
a546 1
#ifdef TIMING
d562 1
a562 1
#ifdef TIMING
d573 1
a573 1
#ifdef CHECKSUM
d597 1
a597 1
#ifdef TIMING
@


1.6
log
@Added support for Sun receive queue in acceptmsg and r_min. Removed 
mistuff. Replaced 128 with IH_NODE.
@
text
@d1 4
d6 5
a10 1
 * $Log:        machifc.c,v $
a30 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.5
log
@Tab conversion.
@
text
@d3 3
d9 1
a9 1
 * 
d99 1
a99 1
		in the header.  If we're sending an EMSG to node 128 of a Mark3,
d101 1
a101 1
		is 128 and tw_node_num is 0, call ih_msgproc() and destroy_msg().
d163 1
d192 5
d227 1
a227 1
	node = msg->mistuff[0];     /* from node */
d229 5
a233 3
	msg->mistuff[0] = tw_node_num;      /* from node */
	msg->mistuff[1] = node;     /* to node */
	msg->mistuff[2] = 0;        /* Ack flag */
d240 1
a240 1
	send_message ( msg, len, node, 0 );
d246 1
a246 1
			res = send_message ( msg, len, node, 0 );
d335 3
d432 8
d441 2
d466 1
d472 4
d477 5
a481 3
	tw_msg->mistuff[0] = tw_node_num;   /* from node */
	tw_msg->mistuff[1] = node;          /* to node */
	tw_msg->mistuff[2] = 0;             /* ack flag */
d484 1
a484 1

d489 1
a489 1
	if ( node == 128 )
d524 4
d557 4
a560 3
	tw_msg->mistuff[0] = tw_node_num;
	tw_msg->mistuff[1] = 0;
	tw_msg->mistuff[2] = 0;
a605 1

@


1.4
log
@1.  Check for rm_msg NULL in peekmsg() (bug 7).
2.  Add PARANOID code to validate state in setctx().
@
text
@d2 5
a6 1
 * $Log:	machifc.c,v $
d18 1
a18 1
char machifc_id [] = "@@(#)machifc.c	1.36\t9/26/89\t15:36:46\tTIMEWARP";
d20 3
a22 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d28 3
a30 3
	machifc.c contains code that is the machine interface for Time
	Warp.  Most of the code deals with low level message sending
	activities.  Some of it concerns context switching.
d34 4
a37 4
	timrint(gvttimrproc) - arrange for a procedure to be called when the
			timer expires
		Parameters -  int (*gvttimrproc) ()
		Return - Always returns SUCCESS
d39 3
a41 3
	peekmsg() - look at the message in rm_msg
		Parameters - none
		Return - a pointer to the message
d43 3
a45 3
	acceptmsg(tw_msg) - put tw_msg in the rm_buf buffer
		Parameters - Msgh * tw_msg
		Return - Always returns zero
d47 3
a49 3
	denymsg(tw_msg) - return a message to its sender
		Parameters - Msgh * tw_msg
		Return - returns zero, or exits
d51 3
a53 3
	sndmsg(tw_msg,length,node) - put a message into an output queue
		Parameters -  Msgh * tw_msg, Int length, Int node
		Return - SUCCESS or crashes
d55 5
a59 5
	brdcst(tw_msg,length) - send a broadcast message, using the broadcast
			capability, if present; send iteratively to all
			nodes, if not
		Parameters - Msgh * tw_msg, Int length
		Return - SUCCESS or crashes
d61 3
a63 3
	setctx(state,entry_point,stack) - prepare for a context switch
		Parameters - State * state, Byte * entry_point, Byte * stack
		Return - Always returns zero
d65 3
a67 3
	setnull() - clear an object context
		Parameters - none
		Return - Always returns zero
d71 4
a74 4
	timrint() sets a function pointer variable to some value so 
	that some particular function can be called when the main()
	loop has determined that the timer counter has reached a certain
	value. 
d76 1
a76 1
	peekmsg() locks rm_msg and returns a pointer to it.
d78 1
a78 1
	acceptmsg() puts its message into rm_buf, and unlocks rm_msg.
d80 2
a81 2
	denymsg() reverses the sender and receiver of rm_msg, and calls
	send_message() to return it to its sender.  
d83 4
a86 4
	logmsg() finds the message in the ack[] array with the minimum
	send time.  If that time is less than min_msg_time, min_msg_time
	is set to this lower value.  This routine is used in conjunction
	with gvt calculation.
d88 5
a92 5
	minmsg() looks through the pmq[] table's message queues, searching
	for the message with the min rcvtim.  This routine, also, is used
	in conjunction with gvt calculation.  minmsg() looks at the times
	of messages waiting to be sent, logmsg() looks at the times of 
	messages that have been sent, but not yet acked.
d94 6
a99 6
	sndmsg() fills in some fields on header of the message to be sent.
	It calculates the checksum(), if that's being done, and stores it
	in the header.  If we're sending an EMSG to node 128 of a Mark3,
	call stdout_msg() for it.  Whether or not we're on a Mark3, if node 
	is 128 and tw_node_num is 0, call ih_msgproc() and destroy_msg().
	Otherwise, call enq_msg() and send_from_q().  
d101 3
a103 3
	brdcst() first fills in some message fields.  If we don't have
	a low-level broadcasting ability, set the brdcst_flag[] entry
	for each node to 1.  Call send_from_q().  
d105 2
a106 2
	setctx() prepares for a switch of context by setting certain
	pointers, such as object_data.
d108 1
a108 1
	setnull() nulls the object_context pointer.
d124 1
a124 1
    int ( * gvttimrproc ) ();
d128 1
a128 1
    timrproc = gvttimrproc;	/* routine to initiate */
d130 1
a130 1
    timeon ();			/* set the interrupt timer */
d132 1
a132 1
    return ( SUCCESS );
d139 1
a139 1
    int ( * loadtimrproc ) ();
d144 1
a144 1
    timlproc = loadtimrproc;
d146 1
a146 1
    timelon ();
d148 1
a148 1
    return ( SUCCESS );
d158 3
a160 3
    if (rm_msg != NULLMSGH)
    	lock_macro ( rm_msg );
    return ( rm_msg );
d165 1
a165 1
    Msgh * tw_msg;
d169 3
a171 3
    if ( tw_msg != NULL )
    {  /* copy to tw_msg */
	entcpy ( tw_msg, rm_msg, rm_msg->txtlen + sizeof (Msgh) );
d173 2
a174 2
	unlock_macro ( tw_msg );	/* unlock it */
    }
d177 4
a180 4
    if ( rm_msg == (Msgh *) recv.buf )
    {
	give_buf ( &recv );
    }
d184 2
a185 2
    if ( rm_msg != (Msgh *) rm_buf  && rm_msg !=NULL )
	l_destroy ( rm_msg );	/* get rid of message storage */
d188 1
a188 1
    rm_msg = NULL;
d195 1
a195 1
    Msgh * tw_msg;
d197 2
a198 2
    int node, len, res, i;
    Msgh * msg;
d202 5
a206 5
    if ( no_message_sendback )
    {
	_pprintf ( "Denymsg Called\n" );
	tw_exit ( 0 );
    }
d209 5
a213 5
    if ( acks_pending == MAX_ACKS )
    {
	_pprintf ( "Denymsg & MAX_ACKS: %x\n", rm_msg );
	tester ();
    }
d216 1
a216 1
    msg = rm_msg;
d218 1
a218 1
    node = msg->mistuff[0];	/* from node */
d220 3
a222 3
    msg->mistuff[0] = tw_node_num;	/* from node */
    msg->mistuff[1] = node;	/* to node */
    msg->mistuff[2] = 0;	/* Ack flag */
d224 1
a224 1
    len = msg->txtlen + sizeof ( Msgh );
d226 1
a226 1
    unlock_macro ( msg );
d229 1
a229 1
    send_message ( msg, len, node, 0 );
d231 1
a231 3
    for ( ;; )
    {
	for ( i = 0; i < 1000; i++ )
d233 3
a235 1
	    res = send_message ( msg, len, node, 0 );
d237 7
a243 2
	    if ( res != -1 )
		break;
a244 5
	if ( i < 1000 )
	    break;

	_pprintf ( "Denymsg stuck writing to Node %d\n", node );
    }
d247 2
a248 2
    if ( ! ( msg->flags & MOVING ) )
	log_ack_pending ( msg, node );
d251 4
a254 4
    if ( rm_msg == (Msgh *) recv.buf )
    {
	give_buf ( &recv );
    }
d258 2
a259 2
    if ( rm_msg != (Msgh *) rm_buf )
	l_destroy ( rm_msg );
d262 1
a262 1
    rm_msg = NULL;
d270 2
a271 2
    /* find minimum of messages sent but not yet ack'd */
    min_msg_time = butterfly_min ();
d275 1
a275 1
      gvt.simtime);
d279 1
a279 1
    register int i, n;
d283 1
a283 1
    min_msg_time = posinfPlus1;
d285 1
a285 3
    for ( i = 0, n = acks_pending; n > 0; i++ )
    {
	if ( ack[i].busy )
d287 3
a289 1
	    n--;
d291 5
a295 4
	    if ( ltVTime ( ack[i].time, min_msg_time ) )
	    {
		min_msg_time = ack[i].time;
	    }
a296 1
    }
d300 1
a300 1
              min_msg_time.simtime, gvt.simtime );
d317 1
a317 1
    VTime * t;
d319 2
a320 2
    register Msgh * msg;
    VTime min;
d322 1
a322 1
    VTime r_min();
d325 1
a325 1
    int gvtMatch;
d328 1
a328 1
    min = migr_min ();	/* calculate minimum time for migrating objects */
d333 1
a333 1
      min.simtime, gvt.simtime);
d337 6
a342 6
    gvtMatch = 0;
    if ( oldgvt2.simtime != NEGINF  && 
	eqVTime ( min, oldgvt1 ) && 
	eqVTime ( oldgvt1, oldgvt2 ) )
    {
	gvtMatch = 1;
d344 2
a345 2
	_pprintf ( "GVT %f repeats three times, after migr_min() \n",
			min.simtime);
d347 1
a347 1
    }
d350 2
a351 2
    if ( gtVTime ( min, min_msg_time ) )
	min = min_msg_time;	/* minimize on min_msg_time */
d356 1
a356 1
      min.simtime, gvt.simtime);
d360 5
a364 5
    if ( !gvtMatch && oldgvt2.simtime != NEGINF  && 
	eqVTime ( min, oldgvt1 ) &&
	eqVTime ( oldgvt1, oldgvt2 ) )
    {
	gvtMatch = 1;
d366 2
a367 2
	_pprintf ( "GVT %f repeats three times, after min_msg_time check \n",
			min.simtime);
d369 1
a369 1
    }
d372 12
a383 12
    for ( msg = (Msgh *) l_next_macro ( pmq );
	      ! l_ishead_macro ( msg );
	  msg = (Msgh *) l_next_macro ( msg ) )
    {  /* cycle through node's message output queue */
	if ( issys_macro ( msg ) )
	    continue;	/* skip system messages */
	if ( strcmp ( msg->rcver, "$IH") == 0 )
	    continue;  /* skip msgs to the IH */
	if ( ! ( msg->flags & MOVING ) )
	{  /* object is not in process of moving */
	    if ( gtVTime ( min, msg->sndtim ) )
		min = msg->sndtim;	/* minimize on sndtim */
d385 3
a387 2
	    if ( isposi_macro ( msg ) )
		break;	/* break on positive message */
a388 1
    }
d394 1
a394 1
      min.simtime, gvt.simtime);
d397 5
a401 5
    if ( !gvtMatch && oldgvt2.simtime != NEGINF  && 
	eqVTime ( min, oldgvt1 ) && 
	eqVTime ( oldgvt1, oldgvt2 ) )
    {
	gvtMatch = 1;
d403 2
a404 2
	_pprintf ( "GVT %f repeats three times, after pmq check \n",
			min.simtime);
d406 1
a406 1
    }
d409 1
a409 1
    min = r_min ( min );	/* minimize over node's input msg queue */
d413 1
a413 1
      min.simtime, gvt.simtime);
d420 4
a423 4
    if ( !gvtMatch && oldgvt2.simtime != NEGINF  && 
	eqVTime ( min, oldgvt1 ) && 
	eqVTime ( oldgvt1, oldgvt2 ) )
    {
d425 2
a426 2
	_pprintf ( "GVT %f repeats three times, after r_min check \n",
			min.simtime);
d428 1
a428 1
    }
d430 1
a430 1
    *t = min;	/* pass back the minimum time */
d438 3
a440 3
    Msgh * tw_msg;
    Int length;
    Int node;
d445 1
a445 1
    start_timing ( TESTER_TIMING_MODE );
d448 3
a450 3
    tw_msg->mistuff[0] = tw_node_num;	/* from node */
    tw_msg->mistuff[1] = node;		/* to node */
    tw_msg->mistuff[2] = 0;		/* ack flag */
d452 1
a452 1
    tw_msg->txtlen = length - sizeof ( Msgh );
d455 1
a455 1
    tw_msg->checksum = checksum ( tw_msg );
d458 2
a459 2
    if ( node == 128 )
    {
d461 3
a463 3
	if ( tw_msg->mtype == EMSG )
	{  /* event message */
	    stdout_msg ( tw_msg );	/* send to stdout */
d465 10
a474 10
	    goto sndmsg_end;		/* and finish up */
	}
	else				/* not event message */
	if ( tw_msg->mtype == SIM_END_MSG
	&& ( ! no_stdout ) )
	{
	    save_sim_end_msg = tw_msg;	/* the simulation is done */
	    messages_to_send++;
	    goto sndmsg_end;
	}
d476 7
a482 7
	if ( tw_node_num == 0 )
	{  /* if we're on node 0 */
	    if ( rm_msg != NULL )
	    {
		_pprintf ( "rm_msg not Null!\n" );
		tester ();
	    }
d484 1
a484 1
	    rm_msg = tw_msg;
d486 1
a486 1
	    ih_msgproc ( tw_msg );	/* handle the message */
d488 6
a493 1
	    goto sndmsg_end;		/* finish up */
a494 5
	else
	{  /* we're not on node 0 */
	    node = 0;		/* send IH messages to node 0 */
	}
    }
d496 1
a496 1
    enq_msg ( tw_msg );		/* put msg in output queue */
d498 1
a498 1
    send_from_q ();		/* send out messages in queue */
d503 1
a503 1
    stop_timing ();
d506 1
a506 1
    return ( SUCCESS );
d511 2
a512 2
    register Msgh * tw_msg;
    register Int length;
d514 1
a514 1
    register int node;
d519 1
a519 1
    start_timing ( TESTER_TIMING_MODE );
d522 3
a524 3
    tw_msg->mistuff[0] = tw_node_num;
    tw_msg->mistuff[1] = 0;
    tw_msg->mistuff[2] = 0;
d526 1
a526 1
    tw_msg->txtlen = length - sizeof ( Msgh );
d529 1
a529 1
    tw_msg->checksum = checksum ( tw_msg );
d532 5
a536 5
    if ( brdcst_msg != NULL )
    {
	_pprintf ( "brdcst_msg overwrite\n" );
	crash ();
    }
d538 1
a538 1
    brdcst_msg = tw_msg;	/* point to the message */
d541 5
a545 5
    for ( node = 0; node < tw_num_nodes; node++ )
    {
	if ( node != tw_node_num )
	    brdcst_flag[node] = 1;
    }
d548 1
a548 1
    messages_to_send++;
d550 1
a550 1
    send_from_q ();	/* this does the send */
d553 1
a553 1
    stop_timing ();
d556 1
a556 1
    return ( SUCCESS );
d561 3
a563 3
    State * state;
    Byte * entry_point;
    Byte * stack;
d568 1
a568 1
    validState(state - 1);
d571 2
a572 2
    object_data    = (Byte *)state;
    object_context = stack + objstksize;
d574 2
a575 2
    if ( entry_point != NULL )
	* ( (Byte **) (object_context-4) ) = entry_point;
d582 1
a582 1
    object_context = NULL;
@


1.3
log
@A bug fix to make sure IH messages aren't considered in GVT calculation,
plus a number of tests to catch gvt problems.
@
text
@d3 4
d154 2
a155 2
    lock_macro ( rm_msg );

d562 4
@


1.2
log
@comment out GVT repetition warning messages
@
text
@d3 3
d264 6
d289 6
d322 6
d345 6
d370 2
a371 1

d383 6
d402 7
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d314 1
d317 1
d330 1
d333 1
d360 1
d363 1
d375 1
d378 1
@
