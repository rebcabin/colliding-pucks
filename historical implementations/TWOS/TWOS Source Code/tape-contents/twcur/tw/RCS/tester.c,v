head     1.13;
branch   ;
access   ;
symbols  TW2_7:1.13 TW2_6:1.12 TW2_5_1:1.10 TW2_5:1.8 TW2_4_2:1.3 TW2_4_1:1.2 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.13
date     91.12.27.09.18.24;  author pls;  state Rel;
branches ;
next     1.12;

1.12
date     91.11.01.13.51.19;  author reiher;  state Rel;
branches ;
next     1.11;

1.11
date     91.11.01.12.55.33;  author pls;  state Dev;
branches ;
next     1.10;

1.10
date     91.07.17.15.13.14;  author judy;  state Rel;
branches ;
next     1.9;

1.9
date     91.07.09.15.28.16;  author steve;  state Dev;
branches ;
next     1.8;

1.8
date     91.06.03.14.24.01;  author configtw;  state Rel;
branches ;
next     1.7;

1.7
date     91.06.03.12.27.03;  author configtw;  state Dev;
branches ;
next     1.6;

1.6
date     91.04.01.15.47.45;  author reiher;  state Dev;
branches ;
next     1.5;

1.5
date     91.03.26.09.50.01;  author pls;  state Dev;
branches ;
next     1.4;

1.4
date     91.03.25.16.41.58;  author csupport;  state Dev;
branches ;
next     1.3;

1.3
date     90.12.10.10.53.26;  author configtw;  state Rel;
branches ;
next     1.2;

1.2
date     90.08.27.10.45.29;  author configtw;  state Dev;
branches ;
next     1.1;

1.1
date     90.08.07.15.41.18;  author configtw;  state Rel;
branches ;
next     ;


desc
@tester support & misc routines
@


1.13
log
@Fix up TIMING code.
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	tester.c,v $
 * Revision 1.12  91/11/01  13:51:19  reiher
 * Added batch mode support (PLR)
 * 
 * Revision 1.11  91/11/01  12:55:33  pls
 * 1.  Change ifdef's and version id.
 * 2.  Add support code for signal handling (SCR 164).
 * 3.  GVT display now shows sequence 1 and 2.
 * 4.  Change proportional delay routine.
 * 
 * Revision 1.10  91/07/17  15:13:14  judy
 * New copyright notice.
 * 
 * Revision 1.9  91/07/09  15:28:16  steve
 * MicroTime & object_timing_mode support. 2 changed to SIGNAL_THE_CUBE
 * 
 * Revision 1.8  91/06/03  14:24:01  configtw
 * Make network version exit correctly.
 * 
 * Revision 1.7  91/06/03  12:27:03  configtw
 * Tab conversion.
 * 
 * Revision 1.6  91/04/01  15:47:45  reiher
 * Code to support Tapas Som's work
 * 
 * Revision 1.5  91/03/26  09:50:01  pls
 * 1.  Modify hoglog code to refer to hlog.
 * 2.  Remove gvt_position().
 * 
 * Revision 1.4  91/03/25  16:41:58  csupport
 * Implement hoglog.
 *
 * Revision 1.3  90/12/10  10:53:26  configtw
 * use .simtime field as necessary
 * 
 * Revision 1.2  90/08/27  10:45:29  configtw
 * Split cycle time from committed time.
 * 
 * Revision 1.1  90/08/07  15:41:18  configtw
 * Initial revision
 * 
*/
char tester_id [] = "@@(#)tester.c       $Revision: 1.12 $\t$Date: 91/11/01 13:51:19 $\tTIMEWARP";


/*

Purpose:

		tester.c is something of a catchall module.  Any low level function
		that does not belong somewhere else is kept here.  The bulk of the
		routines stored here are small routines that deal with commands
		given to the system in tester mode, such as manually sending
		messages.  But several other miscellaneous functions have found
		their way into this module, as well.

Functions:

		tobjend() - handle the timings for an object's end
				Parameters - none
				Return - Always returns zero

		start_timing(new_timing_mode) - start timing in a new mode, saving
						the previous timing mode's information
				Parameters -  int new_timing_mode
				Return - Always returns zero

		stop_timing() - clean up for the current timing mode, and revert
						to the previous mode
				Parameters - none
				Return - Always returns zero

		tester() - invoke the system testing software
				Parameters - none
				Return - Always returns zero

		go() - set host_input_waiting to 0
				Parameters - none
				Return - Always returns zero

		stop() - exit the simulation
				Parameters - none
				Return - Never returns

		dumpmsgx(msgh) - dump a message
				Parameters - Msgh **msgh
				Return - Always returns zero

		dumpstatex(state) - dump a state
				Parameters - int ** state
				Return - Always returns zero

		manual_lvt() - print the processor's virtual time
				Parameters - none
				Return - Always returns zero

		manual_gvt() - print the gvt
				Parameters - none
				Return - Always returns zero

		gvt_position(row,column) - set the output format for gvt messages
				Parameters -  int * row, int * column
				Return - Always returns zero

		manual_init(f) - call the function provided in the parameter
				Parameters - Byte * (*f)()
				Return - Always returns zero

		manual_event(state,p) - ask for a command until an object ends
				Parameters -  char * state, int (*p) ()
				Return - Always returns zero

		manual_term(state) - do nothing
				Parameters - char * state
				Return - Always returns zero

		manual_objend() - indicate that an object has ended
				Parameters - none
				Return - Always returns zero

		crash() - crash and burn
				Parameters - none
				Return - Never returns

		debug() - do nothing
				Parameters - none
				Return - Always returns zero

Implemenation:

		start_timing() and stop_timing() maintain a stack of timing
		modes.  The system can time various different modes of Time
		Warp operation.  There is a timing mode for the tester, for
		Time Warp, for objects, and for the system.  A call to 
		start_timing() pushes the existing timing mode (if any) onto the
		stack, along with any time that has been accumulated for it,
		and starts in the new mode.  stop_timing() completes the timing
		of the old mode, and restores the topmost timing mode (if any) from
		the stack.

		tester() iteratively prompts for commands.

		clear_screen() does what it says.

		go() sets host_input_waiting to 0, which allows the system to 
		continue without traps to the tester.

		stop() calls tw_exit().

		dumpmsgx() and dumpstatex() call the corresponding functions without
		the x on the ends of their names.  manual_lvt() prints the local
		virtual time, and manual_gvt() prints the global virtual time.
		gvt_position() sets up some variables for the next printout of
		gvt.  manual_init() calls its parameter, with 100 as a parameter.
		manual_event() calls command(), telling it to perform MANUAL_EVENT.
		manual_objend() simply indicates that an object has ended.

		crash() kills the machine by calling a null function.

		debug() does nothing. but you can put a breakpoint in it.
*/

#include <stdio.h>  
#include "twcommon.h"
#include "twsys.h"
#include "tester.h"
#include "machdep.h"

extern FILE * cpulog;
extern int host_input_waiting;
extern int object_ended;
extern Byte * object_context;

#if DLM
extern int batchRun;
#endif DLM
#if TIMING
int * timing_mode_sp = timing_mode_stack;
#endif

#if TIMING
#define OBJEND_TIMING_MODE 10
#endif

extern int      hlog;
extern VTime    hlogVTime;
extern int      maxSlice;
extern Ocb*     maxSliceObj;
extern VTime    maxSliceTime;
extern int      sliceTime;

FUNCTION tobjend ()
{
	extern int flog;

	objectCode = FALSE;		/* no longer executing object code */

#if TIMING
	stop_timing ();
#endif

	if ( prop_delay )
		delay_object ();

#if MICROTIME
	switch ( object_timing_mode )
	{
	case WALLOBJTIME:
		MicroTime ();
		object_end_time = node_cputime;
		break;
	case USEROBJTIME:
		object_end_time = UserDeltaTime(); /* end clock */
		/* object_start_time is still zero */
		break;
	case NOOBJTIME:
	default:
		/* no measure */
		break;
	}
#else
#if MARK3
	mark3time ();
#endif
#if BBN
	butterflytime ();
#endif
	object_end_time = node_cputime;
#endif

	if (hlog)
		{
		sliceTime = object_end_time - object_start_time;
		if ((sliceTime > maxSlice) && (geVTime(gvt,hlogVTime)) &&
			(ltSTime(xqting_ocb->svt, posinf.simtime))) /* skip term */
			{ /* this slice was bigger than max so far */
			maxSlice = sliceTime;
			maxSliceObj = xqting_ocb;
			maxSliceTime = xqting_ocb->svt;
			}
		}

	xqting_ocb->stats.cputime += object_end_time - object_start_time;
	xqting_ocb->cycletime += object_end_time - object_start_time;
	xqting_ocb->stats.comtime += object_end_time - object_start_time;
	xqting_ocb->sb->effectWork += object_end_time - object_start_time;

#if SOM
	/*  Calculate the ept for the state of the event just completing. */

	xqting_ocb->sb->Ept += object_end_time - object_start_time;
	xqting_ocb->work += object_end_time - object_start_time;
#endif SOM

	if ( cpulog )
	{
		register Ocb * o = xqting_ocb;

		if ( gtSTime ( o->svt.simtime, neginfPlus1.simtime ) )
			HOST_fprintf ( cpulog, "E %s %f %d\n", o->name,
				o->svt.simtime, o->stats.cputime );
		else
			o->stats.cputime = 0;
	}

	if ( flog )
		flowlog_entry ();

#if TIMING
	start_timing ( OBJEND_TIMING_MODE );
#endif

	objend ();

#if TIMING
	stop_timing ();
#endif
}       /* tobjend */

#if TIMING
start_timing ( new_timing_mode )

	int new_timing_mode;
{
	if ( timing_mode_sp >= timing_mode_stack + 20 )
	{
		_pprintf ( "Timing Mode Stack Overflow\n" );
		tester();
	}

#if MICROTIME
	timing[timing_mode] += MicroTime ();
#else
#if MARK3
	timing[timing_mode] += mark3time ();
#endif

#if BBN
	end_time = clock ();
	timing[timing_mode] += ( ( end_time - start_time ) *62.5);
	start_time = end_time;
#endif


#if SUN
	end_time = clock ();
	timing[timing_mode] += end_time - start_time;
	start_time = end_time;
#endif
#if TRANSPUTER
	end_time = clock ();
	timing[timing_mode] += end_time - start_time;
	start_time = end_time;
#endif
#endif

	*timing_mode_sp++ = timing_mode;
	timing_mode = new_timing_mode;
}

stop_timing ()
{
	if ( timing_mode_sp <= timing_mode_stack )
	{
		_pprintf ( "Timing Mode Stack Underflow\n" );
		crash ();
	}
#if MICROTIME
	timing[timing_mode] += MicroTime ();
#else
#if MARK3
	timing[timing_mode] += mark3time ();
#endif

#if BBN
	end_time = clock ();
	timing[timing_mode] += ( ( end_time - start_time ) *62.5);
	start_time = end_time;
#endif 

#if SUN
	end_time = clock ();
	timing[timing_mode] += end_time - start_time;
	start_time = end_time;
#endif
#if TRANSPUTER
	end_time = clock ();
	timing[timing_mode] += end_time - start_time;
	start_time = end_time;
#endif
#endif
	timing_mode = *--timing_mode_sp;
}
#endif

tester ()
{

#ifdef DLM

	/* If we're running in batch mode, when tester() is called abandon
			the run so we can go on to the next. */

	if ( batchRun == TRUE)
			tw_exit ( 0 );
#endif DLM


#if MARK3
	send_message ( 0, 0, CP, SIGNAL_THE_CUBE );/* tell CP to signal nodes */
#endif

#if BBN
		interrupt_nodes ();
#endif
#if TRANSPUTER 
	 if ( tw_node_num == 0 ) 
		{
		 close_command_file (); 
		}

	   brdcst_interrupt ();

#else
	close_command_file ();
#endif

	host_input_waiting = 1;

	while ( host_input_waiting )
		command ( "Tester" );
}

ctrlc ()
{
	host_input_waiting = 1;

	object_ended = TRUE;
}

clear_screen ()
{
	printf ( "\f" );
}

go ()
{
	host_input_waiting = 0;
}

stop ()
{
#if SUN
	extern int triedToExitOnce;

	triedToExitOnce = 1;
#endif
	tw_exit ( 0 );
}

dumpmsgx ( msgh )

	Msgh ** msgh;
{

#if TRANSPUTER

	* msgh =  0x80000000 | (int) *msgh ;

#endif

	dumpmsg ( *msgh );
}

dumpstatex ( state )

	State ** state;
{
	dumpstate ( *state );
}

manual_lvt ()
{
	char pvts[12];
	char min_vts[12];
#if DLM
	char local_min_vts[12];
#endif DLM

	ttoc ( pvts, pvt );
	ttoc ( min_vts, min_vt );
#if DLM
	ttoc ( local_min_vts, local_min_vt );
#endif DLM

#if DLM
	_pprintf ( "PVT = %s LOCAL_MIN_VT = %s MIN_VT = %s\n", pvts, 
				local_min_vts, min_vts );
#else
	_pprintf ( "PVT = %s MIN_VT = %s\n", pvts, min_vts );
#endif DLM
}

manual_gvt ()
{
	char gvts[12];

	ttoc ( gvts, gvt );

	_pprintf ( "GVT = %s, %d, %d\n", gvts,gvt.sequence1,gvt.sequence2 );
}

manual_init ( state )

	char * state;
{
}

manual_event ( state )

	char * state;
{
	for ( object_ended = FALSE; object_ended == FALSE; )
	{
#if MARK3
		extern int object_running;

		object_running = 0;
#endif
		command ( "MANUAL_EVENT" );
	}
}

manual_term ( state )

	char * state;
{
}

manual_objend ()
{
	object_ended = TRUE;

	_pprintf ( "Manual Object Ended\n" );
}

crash ()
{
	int (*z)() = 0;

	_pprintf ( "CRASH\n" );

#if MARK3
	debug ();
#endif

#if TRANSPUTER
	tester ();
#endif

	(*z)();
}

#if SUN
debug ()
{
}
#endif

delay_object ()
{
	int elapsed_time, delay_time, end_delay_time;

#if MICROTIME
	MicroTime ();
#else
#if MARK3
	mark3time ();
#endif
#if BBN
	butterflytime ();
#endif 
#endif 
	elapsed_time = node_cputime - object_start_time;

	delay_time = elapsed_time * delay_factor + 0.5;

	end_delay_time = node_cputime + delay_time;

#if MICROTIME
	while ( node_cputime < end_delay_time )
		MicroTime ();
#else
#if MARK3
	while ( node_cputime < end_delay_time )
		mark3time ();

	object_running = 0;
#endif
#if BBN
	while ( node_cputime < end_delay_time )
		butterflytime ();
#endif
#endif

	xqting_ocb->sb->cputime = 0;
}
@


1.12
log
@Added batch mode support (PLR)
@
text
@d7 3
d48 1
a48 1
char tester_id [] = "@@(#)tester.c       $Revision: 1.11 $\t$Date: 91/11/01 12:55:33 $\tTIMEWARP";
d293 1
a293 1
		crash ();
@


1.11
log
@1.  Change ifdef's and version id.
2.  Add support code for signal handling (SCR 164).
3.  GVT display now shows sequence 1 and 2.
4.  Change proportional delay routine.
@
text
@d7 6
d45 1
a45 1
char tester_id [] = "@@(#)tester.c       $Revision$\t$Date$\tTIMEWARP";
d176 3
d360 11
@


1.10
log
@New copyright notice.
@
text
@d7 3
d39 1
a39 1
char tester_id [] = "@@(#)tester.c       1.61\t10/2/89\t16:24:33\tTIMEWARP";
d140 1
a140 1
		
d170 1
a170 1
#ifdef TIMING
d174 1
a174 1
#ifdef TIMING
d189 3
a191 1
#ifdef TIMING
d198 1
a198 1
#ifdef MICROTIME
d215 1
a215 1
#ifdef MARK3
d218 1
a218 1
#ifdef BBN
d223 1
a223 1
	
d241 1
a241 1
#ifdef SOM
d262 1
a262 1
#ifdef TIMING
d268 1
a268 1
#ifdef TIMING
d273 1
a273 1
#ifdef TIMING
d284 1
a284 1
#ifdef MICROTIME
d287 1
a287 1
#ifdef MARK3
d291 1
a291 1
#ifdef BBN
d298 1
a298 1
#ifdef SUN
d303 1
a303 1
#ifdef TRANSPUTER
d321 1
a321 1
#ifdef MICROTIME
d324 1
a324 1
#ifdef MARK3
d328 1
a328 1
#ifdef BBN
d334 1
a334 1
#ifdef SUN
d339 1
a339 1
#ifdef TRANSPUTER
d351 1
a351 1
#ifdef MARK3
d355 1
a355 1
#ifdef BBN
d358 1
a358 1
#ifdef TRANSPUTER 
d395 1
a395 1
#ifdef SUN
d408 1
a408 1
#ifdef TRANSPUTER
d428 1
a428 1
#ifdef DLM
d434 1
a434 1
#ifdef DLM
d438 1
a438 1
#ifdef DLM
d452 1
a452 1
	_pprintf ( "GVT = %s\n", gvts );
d467 1
a467 1
#ifdef MARK3
d495 1
a495 1
#ifdef MARK3
d499 1
a499 1
#ifdef TRANSPUTER
d506 1
a506 1
#ifdef SUN
d515 3
a517 3
 
#ifdef MICROTIME
	xqting_ocb->sb->cputime += MicroTime ();
d519 2
a520 2
#ifdef MARK3
	xqting_ocb->sb->cputime += mark3time ();
d522 2
a523 2
#ifdef BBN
	xqting_ocb->sb->cputime += butterflytime ();
d526 2
a527 2
	elapsed_time = xqting_ocb->sb->cputime;
 
d529 1
a529 1
 
d531 2
a532 2
 
#ifdef MICROTIME
d536 1
a536 1
#ifdef MARK3
d542 1
a542 1
#ifdef BBN
d547 1
@


1.9
log
@MicroTime & object_timing_mode support. 2 changed to SIGNAL_THE_CUBE
@
text
@d1 4
d7 3
a37 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.8
log
@Make network version exit correctly.
@
text
@d3 3
d189 17
d213 1
d275 3
d299 1
d312 3
d335 1
d343 1
a343 1
	send_message ( 0, 0, CP, 2 );       /* tell CP to signal nodes */
d507 3
d516 1
d523 4
d536 1
@


1.7
log
@Tab conversion.
@
text
@d2 4
a5 1
 * $Log:        tester.c,v $
d357 5
@


1.6
log
@Code to support Tapas Som's work
@
text
@d2 4
a5 1
 * $Log:	tester.c,v $
d23 1
a23 1
char tester_id [] = "@@(#)tester.c	1.61\t10/2/89\t16:24:33\tTIMEWARP";
d25 3
a27 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d33 6
a38 6
	tester.c is something of a catchall module.  Any low level function
	that does not belong somewhere else is kept here.  The bulk of the
	routines stored here are small routines that deal with commands
	given to the system in tester mode, such as manually sending
	messages.  But several other miscellaneous functions have found
	their way into this module, as well.
d42 3
a44 3
	tobjend() - handle the timings for an object's end
		Parameters - none
		Return - Always returns zero
d46 4
a49 4
	start_timing(new_timing_mode) - start timing in a new mode, saving
			the previous timing mode's information
		Parameters -  int new_timing_mode
		Return - Always returns zero
d51 4
a54 4
	stop_timing() - clean up for the current timing mode, and revert
			to the previous mode
		Parameters - none
		Return - Always returns zero
d56 3
a58 3
	tester() - invoke the system testing software
		Parameters - none
		Return - Always returns zero
d60 3
a62 3
	go() - set host_input_waiting to 0
		Parameters - none
		Return - Always returns zero
d64 3
a66 3
	stop() - exit the simulation
		Parameters - none
		Return - Never returns
d68 3
a70 3
	dumpmsgx(msgh) - dump a message
		Parameters - Msgh **msgh
		Return - Always returns zero
d72 3
a74 3
	dumpstatex(state) - dump a state
		Parameters - int ** state
		Return - Always returns zero
d76 3
a78 3
	manual_lvt() - print the processor's virtual time
		Parameters - none
		Return - Always returns zero
d80 3
a82 3
	manual_gvt() - print the gvt
		Parameters - none
		Return - Always returns zero
d84 3
a86 3
	gvt_position(row,column) - set the output format for gvt messages
		Parameters -  int * row, int * column
		Return - Always returns zero
d88 3
a90 3
	manual_init(f) - call the function provided in the parameter
		Parameters - Byte * (*f)()
		Return - Always returns zero
d92 3
a94 3
	manual_event(state,p) - ask for a command until an object ends
		Parameters -  char * state, int (*p) ()
		Return - Always returns zero
d96 3
a98 3
	manual_term(state) - do nothing
		Parameters - char * state
		Return - Always returns zero
d100 3
a102 3
	manual_objend() - indicate that an object has ended
		Parameters - none
		Return - Always returns zero
d104 3
a106 3
	crash() - crash and burn
		Parameters - none
		Return - Never returns
d108 3
a110 3
	debug() - do nothing
		Parameters - none
		Return - Always returns zero
d114 9
a122 9
	start_timing() and stop_timing() maintain a stack of timing
	modes.  The system can time various different modes of Time
	Warp operation.  There is a timing mode for the tester, for
	Time Warp, for objects, and for the system.  A call to 
	start_timing() pushes the existing timing mode (if any) onto the
	stack, along with any time that has been accumulated for it,
	and starts in the new mode.  stop_timing() completes the timing
	of the old mode, and restores the topmost timing mode (if any) from
	the stack.
d124 1
a124 1
	tester() iteratively prompts for commands.
d126 4
a129 4
	clear_screen() does what it says.
	
	go() sets host_input_waiting to 0, which allows the system to 
	continue without traps to the tester.
d131 1
a131 1
	stop() calls tw_exit().
d133 7
a139 7
	dumpmsgx() and dumpstatex() call the corresponding functions without
	the x on the ends of their names.  manual_lvt() prints the local
	virtual time, and manual_gvt() prints the global virtual time.
	gvt_position() sets up some variables for the next printout of
	gvt.  manual_init() calls its parameter, with 100 as a parameter.
	manual_event() calls command(), telling it to perform MANUAL_EVENT.
	manual_objend() simply indicates that an object has ended.
d141 1
a141 1
	crash() kills the machine by calling a null function.
d143 1
a143 1
	debug() does nothing. but you can put a breakpoint in it.
d165 6
a170 6
extern int	hlog;
extern VTime	hlogVTime;
extern int	maxSlice;
extern Ocb*	maxSliceObj;
extern VTime	maxSliceTime;
extern int	sliceTime;
d174 1
a174 1
    extern int flog;
d177 1
a177 1
    stop_timing ();
d180 2
a181 2
    if ( prop_delay )
	delay_object ();
d184 1
a184 1
    mark3time ();
d187 1
a187 1
    butterflytime ();
d189 13
a201 13
    object_end_time = node_cputime;
    
    if (hlog)
	{
	sliceTime = object_end_time - object_start_time;
	if ((sliceTime > maxSlice) && (geVTime(gvt,hlogVTime)) &&
	    (ltSTime(xqting_ocb->svt, posinf.simtime))) /* skip term */
	    { /* this slice was bigger than max so far */
	    maxSlice = sliceTime;
	    maxSliceObj = xqting_ocb;
	    maxSliceTime = xqting_ocb->svt;
	    }
	}
d203 4
a206 4
    xqting_ocb->stats.cputime += object_end_time - object_start_time;
    xqting_ocb->cycletime += object_end_time - object_start_time;
    xqting_ocb->stats.comtime += object_end_time - object_start_time;
    xqting_ocb->sb->effectWork += object_end_time - object_start_time;
d209 1
a209 1
    /*  Calculate the ept for the state of the event just completing. */
d211 2
a212 2
    xqting_ocb->sb->Ept += object_end_time - object_start_time;
    xqting_ocb->work += object_end_time - object_start_time;
d215 3
a217 3
    if ( cpulog )
    {
	register Ocb * o = xqting_ocb;
d219 6
a224 6
	if ( gtSTime ( o->svt.simtime, neginfPlus1.simtime ) )
	    HOST_fprintf ( cpulog, "E %s %f %d\n", o->name,
		o->svt.simtime, o->stats.cputime );
	else
	    o->stats.cputime = 0;
    }
d226 2
a227 2
    if ( flog )
	flowlog_entry ();
d230 1
a230 1
    start_timing ( OBJEND_TIMING_MODE );
d233 1
a233 1
    objend ();
d236 1
a236 1
    stop_timing ();
d238 1
a238 1
}	/* tobjend */
d243 1
a243 1
    int new_timing_mode;
d245 5
a249 5
    if ( timing_mode_sp >= timing_mode_stack + 20 )
    {
	_pprintf ( "Timing Mode Stack Overflow\n" );
	crash ();
    }
d252 1
a252 1
    timing[timing_mode] += mark3time ();
d256 3
a258 3
    end_time = clock ();
    timing[timing_mode] += ( ( end_time - start_time ) *62.5);
    start_time = end_time;
d263 3
a265 3
    end_time = clock ();
    timing[timing_mode] += end_time - start_time;
    start_time = end_time;
d268 3
a270 3
    end_time = clock ();
    timing[timing_mode] += end_time - start_time;
    start_time = end_time;
d273 2
a274 2
    *timing_mode_sp++ = timing_mode;
    timing_mode = new_timing_mode;
d279 5
a283 5
    if ( timing_mode_sp <= timing_mode_stack )
    {
	_pprintf ( "Timing Mode Stack Underflow\n" );
	crash ();
    }
d285 1
a285 1
    timing[timing_mode] += mark3time ();
d289 3
a291 3
    end_time = clock ();
    timing[timing_mode] += ( ( end_time - start_time ) *62.5);
    start_time = end_time;
d295 3
a297 3
    end_time = clock ();
    timing[timing_mode] += end_time - start_time;
    start_time = end_time;
d300 3
a302 3
    end_time = clock ();
    timing[timing_mode] += end_time - start_time;
    start_time = end_time;
d304 1
a304 1
    timing_mode = *--timing_mode_sp;
d311 1
a311 1
    send_message ( 0, 0, CP, 2 );	/* tell CP to signal nodes */
d315 1
a315 1
        interrupt_nodes ();
d318 4
a321 4
     if ( tw_node_num == 0 ) 
	{
	 close_command_file (); 
	}
d323 1
a323 1
       brdcst_interrupt ();
d326 1
a326 1
    close_command_file ();
d329 1
a329 1
    host_input_waiting = 1;
d331 2
a332 2
    while ( host_input_waiting )
	command ( "Tester" );
d337 1
a337 1
    host_input_waiting = 1;
d339 1
a339 1
    object_ended = TRUE;
d344 1
a344 1
    printf ( "\f" );
d349 1
a349 1
    host_input_waiting = 0;
d354 1
a354 1
    tw_exit ( 0 );
d359 1
a359 1
    Msgh ** msgh;
d364 1
a364 1
    * msgh =  0x80000000 | (int) *msgh ;
d368 1
a368 1
    dumpmsg ( *msgh );
d373 1
a373 1
    State ** state;
d375 1
a375 1
    dumpstate ( *state );
d380 2
a381 2
    char pvts[12];
    char min_vts[12];
d383 1
a383 1
    char local_min_vts[12];
d386 2
a387 2
    ttoc ( pvts, pvt );
    ttoc ( min_vts, min_vt );
d389 1
a389 1
    ttoc ( local_min_vts, local_min_vt );
d393 2
a394 2
    _pprintf ( "PVT = %s LOCAL_MIN_VT = %s MIN_VT = %s\n", pvts, 
		local_min_vts, min_vts );
d396 1
a396 1
    _pprintf ( "PVT = %s MIN_VT = %s\n", pvts, min_vts );
d402 1
a402 1
    char gvts[12];
d404 1
a404 1
    ttoc ( gvts, gvt );
d406 1
a406 1
    _pprintf ( "GVT = %s\n", gvts );
d411 1
a411 1
    char * state;
d417 1
a417 1
    char * state;
d419 2
a420 2
    for ( object_ended = FALSE; object_ended == FALSE; )
    {
d422 1
a422 1
	extern int object_running;
d424 1
a424 1
	object_running = 0;
d426 2
a427 2
	command ( "MANUAL_EVENT" );
    }
d432 1
a432 1
    char * state;
d438 1
a438 1
    object_ended = TRUE;
d440 1
a440 1
    _pprintf ( "Manual Object Ended\n" );
d445 1
a445 1
    int (*z)() = 0;
d447 1
a447 1
    _pprintf ( "CRASH\n" );
d450 1
a450 1
    debug ();
d454 1
a454 1
    tester ();
d457 1
a457 1
    (*z)();
d468 1
a468 1
    int elapsed_time, delay_time, end_delay_time;
d471 1
a471 1
    xqting_ocb->sb->cputime += mark3time ();
d474 1
a474 1
    xqting_ocb->sb->cputime += butterflytime ();
d476 1
a476 1
    elapsed_time = xqting_ocb->sb->cputime;
d478 1
a478 1
    delay_time = elapsed_time * delay_factor + 0.5;
d480 1
a480 1
    end_delay_time = node_cputime + delay_time;
d483 2
a484 2
    while ( node_cputime < end_delay_time )
        mark3time ();
d486 1
a486 1
    object_running = 0;
d489 2
a490 2
    while ( node_cputime < end_delay_time )
        butterflytime ();
d492 1
a492 1
    xqting_ocb->sb->cputime = 0;
@


1.5
log
@1.  Modify hoglog code to refer to hlog.
2.  Remove gvt_position().
@
text
@d3 4
d204 7
@


1.4
log
@Implement hoglog.
@
text
@d3 3
d158 2
a159 1
#if HOGLOG
a163 1
#endif
d184 2
a185 1
#if HOGLOG
d187 2
a188 1
	if ((sliceTime > maxSlice) && (gvt.simtime >= (STime)0))
d194 1
a194 1
#endif
a393 10

gvt_position ( row, column )

    int * row;
    int * column;
{
    gvtrow = *row;
    gvtcol = *column;
}

@


1.3
log
@use .simtime field as necessary
@
text
@d3 3
d155 7
d180 10
d219 1
a219 1
}
@


1.2
log
@Split cycle time from committed time.
@
text
@d3 3
d180 1
a180 1
	if ( gtSTime ( o->svt.simtime, neginfPlus1 ) )
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d169 2
a170 1
    xqting_ocb->stats.cycletime += object_end_time - object_start_time;
@
