head     1.17;
branch   ;
access   ;
symbols  TW2_7:1.17 TW2_6:1.15 TW2_5_1:1.11 TW2_5:1.10 TW2_4_2:1.5 TW2_4_1:1.2 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.17
date     91.12.27.10.45.04;  author pls;  state Rel;
branches ;
next     1.16;

1.16
date     91.12.27.08.39.16;  author reiher;  state Dev;
branches ;
next     1.15;

1.15
date     91.11.06.11.08.16;  author configtw;  state Rel;
branches ;
next     1.14;

1.14
date     91.11.04.09.34.08;  author pls;  state Dev;
branches ;
next     1.13;

1.13
date     91.11.01.09.28.10;  author reiher;  state Dev;
branches ;
next     1.12;

1.12
date     91.08.08.15.17.49;  author reiher;  state Dev;
branches ;
next     1.11;

1.11
date     91.07.17.15.07.15;  author judy;  state Rel;
branches ;
next     1.10;

1.10
date     91.06.04.13.44.41;  author configtw;  state Rel;
branches ;
next     1.9;

1.9
date     91.06.03.12.23.36;  author configtw;  state Dev;
branches ;
next     1.8;

1.8
date     91.05.31.12.42.48;  author pls;  state Dev;
branches ;
next     1.7;

1.7
date     91.04.01.15.33.58;  author reiher;  state Dev;
branches ;
next     1.6;

1.6
date     91.03.26.14.17.50;  author configtw;  state Dev;
branches ;
next     1.5;

1.5
date     90.12.10.10.39.23;  author configtw;  state Rel;
branches ;
next     1.4;

1.4
date     90.11.27.09.43.11;  author csupport;  state Dev;
branches ;
next     1.3;

1.3
date     90.11.27.09.23.35;  author csupport;  state Dev;
branches ;
next     1.2;

1.2
date     90.08.09.15.05.30;  author steve;  state Exp;
branches ;
next     1.1;

1.1
date     90.08.07.15.37.54;  author configtw;  state Rel;
branches ;
next     ;


desc
@debugging support routines
@


1.17
log
@1.  Use l_size macro.
2.  Add support for variable length address table (SCR 214).
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	buglib2.c,v $
 * Revision 1.16  91/12/27  08:39:16  reiher
 * Changed showocb to show how many events throttling permits
 * 
 * Revision 1.15  91/11/06  11:08:16  configtw
 * Fix merge error.
 * 
 * Revision 1.14  91/11/04  09:34:08  pls
 * Add sequence times to gvt printouts.
 * 
 * Revision 1.13  91/11/01  09:28:10  reiher
 * Added debugging info for critical path mechanism
 * 
 * Revision 1.12  91/08/08  15:17:49  reiher
 * Fixed showHomeNode() so it would actually print the home node number, not
 * just return it.
 * 
 * Revision 1.11  91/07/17  15:07:15  judy
 * New copyright notice.
 * 
 * Revision 1.10  91/06/04  13:44:41  configtw
 * Don't count system message with gid.num 0 as bad.
 * 
 * Revision 1.9  91/06/03  12:23:36  configtw
 * Tab conversion.
 * 
 * Revision 1.8  91/05/31  12:42:48  pls
 * 1.  Keep tester from bombing when bad msg is entered (bug 6).
 * 2.  Add tester routine to dump list headers.
 * 3.  Add validState() for PARANOID testing.
 * 
 * Revision 1.7  91/04/01  15:33:58  reiher
 * Added a number of new routines for dynamic load management data
 * gathering.  Also added output lines to some existing routines.  Some code
 * is conditionally compiled to support Tapas Som's work.
 * 
 * Revision 1.6  91/03/26  14:17:50  configtw
 * Enhance operation of dm() (from Steve).
 * 
 * Revision 1.5  90/12/10  10:39:23  configtw
 * use .simtime field as necessary
 * 
 * Revision 1.4  90/11/27  09:43:11  csupport
 * have dumpstateAddrTablex() call dumpstateAddrTable(), not dumpstate()
 * 
 * Revision 1.3  90/11/27  09:23:35  csupport
 * 1.  fix bug in showschedq to handle deferred segments
 * 2.  add code to handle staddrt tester command
 * 
 * Revision 1.2  90/08/09  15:05:30  steve
 * dumpstate now prints ocb field
 * 
 * Revision 1.1  90/08/07  15:37:54  configtw
 * Initial revision
 * 
*/
char buglib2_id [] = "@@(#)buglib2.c     1.67\t10/23/89\t11:02:54\tTIMEWARP";


/*

Purpose:

		This module contains routines that support debugging and other
		informatory output from the system.

Functions:

		get_enum(type,symbolic_constant) - convert a numeric condition
				code into a string
				Parameters - Char *type, int symbolic constant
				Return - a pointer to the string

		dumparray(u,n) - print an array, both in alpha and hex
				Parameters - char *u, int n
				Return -  Always returns zero

		mem_used_in_queues() - calculate and print the memory used in queues
				Parameters - none
				Return - Always returns zero

		showschedq() - print out a scheduler queue, in short form
				Parameters - none
				Return - Always returns zero

		showsq(o) - shwo an object's state queue
				Parameters - Ocb o
				Return - Always returns zero

		returnoqmem(o) - calculate the amount of memory in an object's output
				queue
				Parameters - Ocb *o
				Return - the amount of memory

		returniqmem(o) - calculate the amount of memory in an object's input
				queue
				Parameters - Ocb *o
				Return - the amount of memory

		returnsqmem(o) - calculate the amount of memory in an object's state
				queue
				Parameters - Ocb *o
				Return - the amount of memory

		countoqmem(o) - print the amount of memory in an object's output
				queue
				Parameters - Ocb *o
				Return - Always returns zero

		countiqmem(o) - print the amount of memory in an object's input
				queue
				Parameters - Ocb *o
				Return - Always returns zero

		countsqmem(o) - print the amount of memory in an object's state
				queue
				Parameters - Ocb *o
				Return - Always returns zero

		showiq(o) - print out an object's input queue
				Parameters - Ocb *o
				Return - Always returns zero

		showoq(o) - print out an object's output queue
				Parameters - Ocb *o
				Return - Always returns zero

		dumpmsg(m) - print out a message
				Parameters - Msgh *m
				Return - Always returns zero

		showmsg_head() - print a message heading
				Parameters - none
				Return - Always returns zero

		showmsg(m) - print a message in abbreviated form
				Parameters - Msgh *m
				Return - Always returns zero

		show_state_head() - print out a state heading
				Parameters - none
				Return - Always returns zero

		showstate(s) - print out a state in abbreviated form
				Parameters - State *s
				Return - Always returns zero

		dumpstate(s) - print out a state in long form
				Parameters - State *s
				Return - Always returns zero

		ttoc(string,time) - convert a virtual time to a user-readable string
				Parameters - char *string, VTime time
				Return - Always returns zero

		showocb_head() - print out an ocb heading
				Parameters - none
				Return - Always returns zero

		showocb(o) - print out an ocb
				Parameters - Ocb *o
				Return - Always returns zero

		general_ocb_by_name(name) - find an object's location from its name
				Parameters - char *name
				Return - a pointer to its location, or NULL if it
						doesn't exist, or isn't on this node

		show_iq_by_name(name) - show the input queue of the named object
				Parameters - char *name
				Return - Always returns zero

		show_oq_by_name(name) - show the output queue of the named object
				Parameters - char *name
				Return - Always returns zero

		show_sq_by_name(name) - show the state queue of the named object
				Parameters - char *name
				Return - Always returns zero

		dump_ocb_by_name(name) - dump the ocb of the named object
				Parameters - char *name
				Return - Always returns zero

		dumpocb(o) - make a complete dump of an ocb
				Parameters - Ocb *o
				Return - Always returns zero

		dprintf(s,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) - 
				do a formatted print of the data provided
				Parameters - Char *s, Long a1 through a15
				Return - Always returns zero

		drawline() - print out a line of underscores
				Parameters - none
				Return - Always returns zero

Implementation:

		While buglib2.c contains a lot of routines, there is little
		code of much interest here.  Most of it is rather repetitive
		output formatting, or slightly differing interfaces for
		accessing the same data.  

		A couple of routines are worth noting.
		get_enum() is worthy of mention because
		it provides a method of converting condition codes to 
		strings that is used for several different types of data
		structures.  The static array "list" (a real loser of a
		variable name) contains the data that get_enum() needs to 
		translate the name of the type of the condition code field
		and a specific integer condition code type to a short string
		suitable for output.  This interface is used for the run status
		of objects; for their error status, if any; for their edge
		status; for the status of messages; and for message types.

		dumparray() is a generalized array dumper that puts its output
		in a format similar to the well-known od output format, except
		that dumparray() uses hex.

		These aside, there is little in this code that is tricky,
		interesting, important, or otherwise worthy of mention. 

*/


#include "twcommon.h"
#include "twsys.h"
#include "tester.h"

struct enum_dat
{
	char            * typefield;
	char            * constant_name;
	int               constant_value;
}
	list[] =
{
	{              "runstat", "READY", READY                    },
	{              "runstat", "BLKINF", BLKINF                  },
	{               "runstat", "BLKPKT", BLKPKT                 },
	{               "runstat", "GOFWD", GOFWD                   },
	{               "runstat", "ARCP", ARCP                     },
	{               "runstat", "ARLBK", ARLBK                   },
	{               "runstat", "STDOUT", ITS_STDOUT             },
	{               "runstat", "BLKSTA", BLKSTATE               },
	{               "runstat", "BLKPHA", BLKPHASE               },

	{               "centry", "INIT", INIT                      },
	{               "centry", "EVENT", EVENT                    },
	{               "centry", "TERM", TERM                      },
	{               "centry", "CREATE", DCRT                    },
	{               "centry", "DESTR", DDES                     },

	{               "mtype", "CMSG", CMSG                       },
	{               "mtype", "EMSG", EMSG                       },
	{               "mtype", "TMSG", TMSG                       },
	{               "mtype", "DYNCR", DYNCRMSG                  },
	{               "mtype", "DYNDS", DYNDSMSG                  },
	{               "mtype", "GVTSYS", GVTSYS                   },
	{               "mtype", "COMMAND", COMMAND                 },
	{               "mtype", "CRT_ACK", CRT_ACK                 },

	{               "node", "BCAST", BCAST                      },

	{               "control", "EDGE", EDGE                     },
	{               "control", "NON-EDGE", NONEDGE              },

	{               NULL, NULL, 0                               }
};

get_enum (type, symbolic_constant, p)

	Char           *type;
	int             symbolic_constant;
	char           *p;
{
	struct enum_dat *l; 
	int             n;

	if (type == NULL)
	{
		strcpy (p, " **> ERROR <**");
		return;
	}

	n = 0;

	for (l = list; l->typefield[0] != '\0'; l++)
	{
		if (strcmp (l->typefield, type) == SUCCESS)
		{
			n++;
			if (l->constant_value == symbolic_constant)
			{
				strcpy (p, l->constant_name);
				return;
			}
		}
		else
		if (n > 0)
			break;
	}

	itoa (symbolic_constant, p);
}

dumparray (u, n)
	char           *u;
	int             n;
{
	char            s[80];
	char            t[10],
					c;
	int             i,
					j;

	s[78] = '\n';
	s[79] = '\0';

#define clrs    {int i; for(i=0; i<78; i++) s[i] = ' ';}

	for (i = 0; i < n;)
	{
		clrs

		sprintf (t, "%3.3x:", i % 0x1000);

		s[0] = toupper (t[0]);
		s[1] = toupper (t[1]);
		s[2] = toupper (t[2]);
		s[3] = t[3];

		for (j = 0; j < 16 && i < n; j++, i++)
		{
			sprintf (t, "%2x ", 0377 & (c = 0377 & u[i]));
			s[5 + 3 * j] = toupper (t[0]);
			s[5 + 3 * j + 1] = toupper (t[1]);
			s[5 + 52 + j] = c < 32 || c > 127 ? '.' : c;
		}
		dprintf ("%s", s);
	}
}

#define OVERHEAD (sizeof(List_hdr)+sizeof(Mem_hdr))

extern List_hdr * free_pool;
extern int free_pool_size;

extern List_hdr * msg_free_pool;
extern int msg_free_pool_size;

mem_used_in_queues ()
{
	Ocb            *o;
	Long            count = OVERHEAD;
	List_hdr * free;

	for (o = fstocb_macro; o; o = nxtocb_macro (o))
	{
		count += sizeof(Ocb) + OVERHEAD;
		if ( o->sb != NULL )
		{
			count += l_size (o->sb) + OVERHEAD;
			count += l_size (o->stk) + OVERHEAD;
		}
		count += (long) returniqmem (o);
		count += (long) returnoqmem (o);
		count += (long) returnsqmem (o);
	}
	_pprintf ("Total memory used in queues = %ld bytes\n", count);

	if ( free_pool != NULL )
	{
		count = OVERHEAD;

		for ( free = l_next_macro ( free_pool ); free != free_pool;
			  free = l_next_macro ( free ) )
		{
			count += (free-1)->size + OVERHEAD;
		}

		_pprintf ( "Free pool size %d # of bytes %d\n", free_pool_size, count );
	}

	if ( msg_free_pool != NULL )
	{
		count = OVERHEAD;

		for ( free = l_next_macro ( msg_free_pool ); free != msg_free_pool;
			  free = l_next_macro ( free ) )
		{
			count += (free-1)->size + OVERHEAD;
		}

		_pprintf ( "Mesg pool size %d # of bytes %d\n", msg_free_pool_size, count );
	}
}

showschedq ()
{
	Ocb            *o;

	showocb_head ();
	for (o = fstocb_macro; o; o = nxtocb_macro (o))
		showocb (o);
}

showdeadq ()
{
	deadOcb            *o;

   printf("Name              phBegin                 phEnd\n");
   for (o = fstDocb_macro; o; o = nxtDocb_macro (o))
	   printf("%s      %f      %f\n",o->name,o->phaseBegin.simtime,
			  o->phaseEnd.simtime);

}

showsq (o)
	Ocb            *o;
{
	State          *s;

	showstate_head ();
	for (s = fststate_macro (o); s; s = nxtstate_macro (s))
	{
		showstate (s);
	}
}

returnoqmem (o)
	Ocb            *o;
{
	Msgh           *m;
	int             b;

	b = OVERHEAD;
	for (m = fstomsg_macro (o); m; m = nxtomsg_macro (m))
		b += l_size (m) + OVERHEAD;
	return b;
}


returniqmem (o)
	Ocb            *o;
{
	Msgh           *m;
	int             b;

	b = OVERHEAD;
	for (m = fstimsg_macro (o); m; m = nxtimsg_macro (m))
		b += l_size (m) + OVERHEAD;
	return b;
}


returnsqmem (o)
	Ocb            *o;
{
	State          *m;
	int             b;

	b = OVERHEAD;
	for (m = fststate_macro (o); m; m = nxtstate_macro (m))
	{
		b += sizeof (State) + o->pvz_len + 12 + OVERHEAD;

		b += dynamic_mem (m);
	}
	return b;
}

dynamic_mem (m)

	State          *m;
{
	int             b, i;

	if ( m->address_table == NULL )
		return 0;

	b = l_size(m->address_table) + OVERHEAD;

	for ( i = 0; i < l_size(m->address_table) / sizeof(Address); i++ )
	{
		Address addr = m->address_table[i];

		if ( (addr != NULL) & (addr != DEFERRED) )
		{
			b += l_size (addr) + OVERHEAD;
		}
	}

	return b;
}

showiq (o)
	Ocb            *o;
{
	Msgh           *m;

	showmsg_head ();
	for (m = fstimsg_macro (o); m; m = nxtimsg_macro (m))
	{
		showmsg (m);
	}
}

showoq (o)
	Ocb            *o;
{
	Msgh           *m;

	showmsg_head ();
	for (m = fstomsg_macro (o); m; m = nxtomsg_macro (m))
	{
		showmsg (m);
	}
}

dumpmsg (m)
	Msgh           *m;
{
	char           c[20];
	char            time[12];

    if ((m->gid.node >= tw_num_nodes) ||
        ((!(m->flags & SYSMSG)) && (m->gid.num == 0)))
		{
		dprintf("Bad message\n");
		return;
		}
	dprintf (" ****** MESSAGE *********[ %lx ]**********************\n", m);
	dprintf ("Sender:      %-20s\n", m->snder);
	ttoc (time, m->sndtim);
	dprintf ("Sendtime:    %-10s,%d,%d\n", time,m->sndtim.sequence1,m->sndtim.sequence2);
	dprintf ("Receiver:    %-20s\n", m->rcver);
	ttoc (time, m->rcvtim);
	dprintf ("Rcvtime:     %-10s\n", time);
	dprintf ("Selector:    %20d\n", m->selector);
	dprintf ("- Gid.Node:  %20d\n", m->gid.node);
	dprintf ("  Gid.Num:   %20d\n", m->gid.num);
	dprintf ("Bits (hex):  %20x\n", m->flags);
	get_enum ("mtype", m->mtype, c);
	dprintf ("Mtype:       %-20s\n", c);
	dprintf ("Txtlen:      %20d\n", m->txtlen);
#ifdef SOM
	dprintf ("Ept:    %20d\n", m->Ept);
#endif SOM
	dprintf ("\n");

/* Messages can be truncated in the same way as states, but there's no spare
	bit in their flag field to indicate that we did it.  Until we expand
	the flag field, we'll have to live with junk being printed when 
	dumpmsg() is done on a truncated message. */

/*
	if ( BITTEST ( m->flags, MSGTRUNC ) )
	{
		dprintf ("\nMESSAGE TRUNCATED\n");
		drawline ();
		return;
	}
*/

	dumparray ((Char *) (m + 1), m->txtlen);

	drawline ();
}

showmsg_head ()
{
	dprintf ( "\n" );
	dprintf (
"Message  Sender           Sndtim Receiver         Rcvtim --GID--  B Mtype\n" );
}

showmsg (m)
	Msgh           *m;
{
	char            mtype[20];
	char            sndtim[12];
	char            rcvtim[12];

	if (m == NULL)
		return;
/*
xx--Message  Sender           Sndtim Receiver         Rcvtim --GID--  B Mtype
xx--mmmmmmmm ssssssssssssssss tttttt rrrrrrrrrrrrrrrr tttttt gg nnnn bb ttttt
*/
	ttoc (sndtim, m->sndtim);
	ttoc (rcvtim, m->rcvtim);
	get_enum ("mtype", m->mtype, mtype);
	dprintf ( "%-8x %-16s %6s %-16s %6s %2d %4d %2x %-5s\n",
		m, m->snder, sndtim, m->rcver, rcvtim, m->gid.node, m->gid.num,
		m->flags, mtype );
}

showstate_head ()
{
	dprintf ( "\n" );
	dprintf (" Address  sndtim   Serror\n");
}

showstate (s)
	State          *s;
{
	char            sndtim[12];
	char * serror = "no err";

	if ( s->serror != NOERR )
		serror = s->serror;
/*
xx--mmmmmmmm tttttt tttttttttt
*/
	ttoc ( sndtim, s->sndtim );
	dprintf ( "%8x  %6s   %-10s  otype = %x, stype = %d, flag = %d, resEv = %d\n",
		s, sndtim, serror, s->otype->type, s->stype, s->sflag, s->resultingEvents );
}


dumpstate (s)
	State          *s;
{
	char            time[12];
	char * serror = "no error";
	Ocb       * o;

	if ( s->serror != NOERR )
		serror = s->serror;

	dprintf (" ******  STATE  *********[ %lx ]**********************\n", s);
	ttoc (time, s->sndtim);
	dprintf ("Sendtime:    %-20s, %d, %d\n", time,s->sndtim.sequence1,
		s->sndtim.sequence2);
	dprintf ("Serror:      %-20s\n", serror);
	dprintf ("Stype:       %d\n", s->stype);
	dprintf ("Ocb:         %x\n", s->ocb);
	o = (Ocb *) s->ocb;
	dprintf ("Object: %-20s\n",o->name);
#ifdef SOM
	dprintf("Ept:     %d\n",s->Ept);
	dprintf("Prev Ept:        %d\n",s->previousEpt);
	dprintf("Result Evnts:	%d\n",s->resultingEvents );
#endif SOM

	dprintf ("\n");

	if ( BITTEST ( s->sflag, STATETRUNC) )
	{
		dprintf("\nSTATE TRUNCATED\n");
		drawline ();
		return;
	}

	dumparray ((Char *) (s + 1), l_size(s) - sizeof(State));

	drawline ();

	if ( s->address_table != NULL )
	{
		register Address a;
		register int i;

		for ( i = 0; i < l_size(s->address_table) / sizeof(Address); i++ )
		{
			if ( ( a = s->address_table[i] ) )
			{
				if ( a == (Address)-1 )
					dprintf ("DEFERRED\n");
				else
					dumparray ( a, l_size(a) );
				drawline ();
			}
		}
	}
}


dumpstateAddrTablex (state)
	State ** state;
{
	dumpstateAddrTable ( *state );
}

dumpstateAddrTable (s)
	State *s;
{
	char            time[12];

	ttoc (time, s->sndtim);

	printf("dumping address table for object %s, time %f\n", ((Ocb *) s->ocb)->name,
				time);

	if ( s->address_table != NULL )
	{
		register Address a;
		register int i;

		dprintf("Max_Addresses is %d\n", Max_Addresses );
		dprintf("Entry  Size    Address\n");

		for ( i = 0; i < l_size(s->address_table) / sizeof(Address); i++ )
		{
			if ( ( a = s->address_table[i] ) )
			{
				if ( a == (Address)-1 )
					dprintf ("DEFERRED\n");
				else
					dprintf("%d %d      %x\n",i,l_size(a), a);
			}
		}
	}
	else
	{
		dprintf("no address table for state\n");
	}

}

dump_state_hdr ( state_ptr )
State   * state_ptr;

{

  dprintf ("st %f: node %d: seg# %d: #segs %d: pkt# %d: #pkts %d Tpkts %d\n",
			state_ptr->sndtim.simtime,
			state_ptr->segno,
			state_ptr->no_segs,
			state_ptr->pktno,
			state_ptr->no_pkts,
			state_ptr->tot_pkts
		  );

}
/*PJH#1 */

dump_state_migr_hdr (migr_hdr )
State_Migr_Hdr *migr_hdr;

{
	Ocb *o;

	o = (Ocb *) migr_hdr->state->ocb;

   _pprintf ("name %s: dt %f: node %d: ack %d: done %d: migr_flags %d\n",
			 o->name,
			 migr_hdr->time_to_deliver.simtime,
			 migr_hdr->to_node,
			 migr_hdr->waiting_for_ack,
			 migr_hdr->waiting_for_done,
			 migr_hdr->migr_flags
			);
}


ttoc ( string, time )           /* time to character */

	char * string;
	VTime time;
{
	if ( eqSTime ( time.simtime, posinf.simtime ) )
		strcpy ( string, "+inf  " );
	else
	if ( eqSTime ( time.simtime, posinfPlus1.simtime ) )
		strcpy ( string, "+inf+1" );
	else
	if ( eqSTime ( time.simtime, neginf.simtime ) )
		strcpy ( string, "-inf  " );
	else
	if ( eqSTime ( time.simtime, neginfPlus1.simtime ) )
		strcpy ( string, "-inf+1" );
	else
		sprintf ( string, "%.2f", time.simtime );
}

ttoc1 (string, time)            /* time to character */
	char           *string;
	VTime           time;
{
	if (time.simtime == POSINF)
		strcpy (string, "posInf");
	else
	if (time.simtime == POSINF+1)
		strcpy (string, "posInf");
	else
	if (time.simtime == NEGINF)
		strcpy (string, "negInf");
	else
	if (time.simtime == NEGINF+1)
		strcpy (string, "negInf");
	else
		sprintf (string, "%.2f", time.simtime);
}

showocb_head ()
{
	dprintf ( "\n" );
	dprintf (
"Name          Phase   Limit  Ocb Ptr   Svt    IQ mem OQ mem SQ mem entry rstat EvPerm\n" );
}

ashowocb (o)
	Ocb *o;
{

	  showocb (*o);
}

showtypes ()
{
	int i;

	dprintf("State hdr is %d bytes\n",sizeof ( State ));
	dprintf("Type       	size		type area pointer\n");
	for ( i = 0; i < MAXNTYP; i++)
	{  
	  if ( type_table[i].type != NULL)
	  {
		  dprintf("%s   	%d		%x\n", type_table[i].type, type_table[i].statesize,type_table[i].typeArea);
	  }
	}  
}

showocb (o)
	Ocb            *o;
{
	char phase[12];
	char limit[12];
	char            svt[12];
	int             iqmem;
	int             oqmem;
	int             sqmem;
	char            centry[20];
	char            runstat[20];
/*
Name          Phase   Limit  Ocb Ptr   Svt    IQ mem OQ mem SQ mem entry rstat
nnnnnnnnnnnn ppppppp lllllll oooooooo sssssss iiiiii oooooo ssssss ccccc rrrrrr
*/
	ttoc (phase, o->phase_begin );
	ttoc (limit, o->phase_limit );
	ttoc (svt, o->svt);
	iqmem = returniqmem (o);
	oqmem = returnoqmem (o);
	sqmem = returnsqmem (o);
	get_enum ("centry", o->centry, centry);
	get_enum ("runstat", o->runstat, runstat);
	dprintf ( "%-12s %7s %7s %8x %7s %6d %6d %6d %5s %-6s %5d\n",
		o->name, phase, limit, o, svt, iqmem, oqmem, sqmem,
		centry, runstat, o->eventsPermitted );
}

Ocb            *general_ocb_by_name (name)
	char           *name;
{
	Ocb            *o;
	Objloc         *location;
	char phase_name[20];
	STime phase_time = NEGINF+1;

	sscanf ( name, "%s %lf", phase_name, &phase_time );

	if ((location = GetLocation(phase_name,newVTime(phase_time,0,0))) == 
				(Objloc *) NULL || location->node == -1)
	{
		if (name_hash_function(phase_name,HOME_NODE) != miparm.me)
				dprintf ("%s not found; try on node %d\n", phase_name,
						name_hash_function(phase_name,HOME_NODE));
		else
				dprintf ("%s does not exist\n",phase_name);
		return NULL;
	}
	if ((o = location->po) == NULL)
	{
		dprintf ("%s is on node %d\n", phase_name, location->node);
		return NULL;
	}
	return o;
}

Ocb * general_ocb_by_phase ( name, ptime )

	char        *name;
	STime       ptime;
{
	Ocb         *o;
	Objloc      *location;
	VTime       vtime;

	vtime = newVTime ( ptime, 0, 0 );

	if ( (location = GetLocation ( name, vtime ) ) == NULL
	||    location->node == -1 )
	{
		if ( name_hash_function ( name, HOME_NODE ) != miparm.me )
			dprintf ( "%s not found; try on node %d\n", name,
				name_hash_function ( name, HOME_NODE ) );
		else
			dprintf ( "%s does not exist\n", name );

		return ( NULL );
	}

	if ( (o = location->po) == NULL )
	{
		dprintf ( "%s at %f is on node %d\n", name, vtime.simtime,
				location->node);

		return ( NULL );
	}

	return ( o );
}

dm ( msg )

	Msgh ** msg;
{
	Ocb * o;

	if ( ( o = general_ocb_by_phase ((*msg)->rcver, (*msg)->rcvtim) ) != NULL )
	{
		if ( o->typepointer->displayMsg )
		{
			o->typepointer->displayMsg ( (*msg)->selector, (*msg) + 1 );
		}
		else
			dumpmsg ( *msg );
	}
	else
		dumpmsg ( *msg );
}

dst ( state )

	State ** state;
{
	Typtbl * type = (*state)->otype;

	int offset = type - type_table;

	if ( offset < 0 || offset >= MAXNTYP )
		return;

	if ( (*state)->otype->displayState )
	{
		(*state)->otype->displayState ( (*state) + 1 );
	}
	else
		dumpstate ( *state );
}

show_iq_by_name ( name )

	char * name;
{
	Ocb * o;

	if ( ( o = general_ocb_by_name ( name ) ) != NULL )
	{
		showiq ( o );
	}
}

show_iq_by_phase ( name, ptime )

	char * name;
	STime * ptime;
{
	Ocb * o;
	VTime vtime;

	vtime = newVTime ( *ptime, 0, 0 );

	if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
	{
		showiq ( o );
	}
}

show_oq_by_name ( name )

	char * name;
{
	Ocb * o;

	if ( ( o = general_ocb_by_name ( name ) ) != NULL )
	{
		showoq ( o );
	}
}

show_oq_by_phase ( name, ptime )

	char * name;
	STime * ptime;
{
	Ocb * o;
	VTime vtime;

	vtime = newVTime ( *ptime, 0, 0 );

	if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
	{
		showoq ( o );
	}
}

show_sq_by_name ( name )

	char * name;
{
	Ocb * o;

	if ( ( o = general_ocb_by_name ( name ) ) != NULL )
	{
		showsq ( o );
	}
}

show_sq_by_phase ( name, ptime )

	char * name;
	STime * ptime;
{
	Ocb * o;
	VTime vtime;

	vtime = newVTime ( *ptime, 0, 0 );

	if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
	{
		showsq ( o );
	}
}

dump_ocb_by_name ( name )

	char * name;
{
	Ocb * o;

	if ( ( o = general_ocb_by_name ( name ) ) != NULL )
	{
		dumpocb ( o );
	}
}

dump_ocb_by_phase ( name, ptime )

	char * name;
	STime * ptime;
{
	Ocb * o;
	VTime vtime;

	vtime = newVTime ( *ptime, 0, 0 );

	if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
	{
		dumpocb ( o );
	}
}


show_miq_by_name ( name )

	char * name;
{
	Ocb * ocb;

	if ( sendOcbQ )
	for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
		  ocb = nxtocb_macro ( ocb ) )
	{
		if ( namecmp ( name, ocb->name ) == 0 )
		{
			dprintf ( "Object %s - \n", ocb->name );
			showiq ( ocb );
		}
	}
}

show_moq_by_name ( name )

	char * name;
{
	Ocb * ocb;

	if ( sendOcbQ )
	for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
		  ocb = nxtocb_macro ( ocb ) )
	{
		if ( namecmp ( name, ocb->name ) == 0 )
		{
			dprintf ( "Object %s - \n", ocb->name );
			showoq ( ocb );
		}
	}
}

show_msq_by_name ( name )

	char * name;
{
	Ocb * ocb;

	if ( sendOcbQ )
	for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
		  ocb = nxtocb_macro ( ocb ) )
	{
		if ( namecmp ( name, ocb->name ) == 0 )
		{    
			dprintf ( "Object %s - \n", ocb->name );
			showsq ( ocb );
		}
	}
}

/* Added function to dump ocbs while in the migration queue. PLRBUG */

show_mocb_by_name ( name )

	char * name;
{
	Ocb * ocb;

	if ( sendOcbQ )
	for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
		  ocb = nxtocb_macro ( ocb ) )
	{
		if ( namecmp ( name, ocb->name ) == 0 )
		{    
			dprintf ( "Object %s - \n", ocb->name );
			dumpocb ( ocb );
		}
	}
}

dumpocb ( o )

	Ocb * o;
{
	char phase[12];
	char phase_end[12];
	char phase_limit[12];
	char svt[12];
	char c[20];

	ttoc (phase, o->phase_begin );
	ttoc (phase_end, o->phase_end );
	ttoc (phase_limit, o->phase_limit );
	ttoc (svt, o->svt);
	dprintf (" ****** OCB     *********[ %lx ]**********************\n", o);
	dprintf ("Name:        %-20s\n", o->name);
	dprintf ("Phase Begin: %20s\n", phase);
	dprintf ("Phase End:   %20s\n", phase_end);
	dprintf ("Phase Limit: %20s\n", phase_limit);
	dprintf ("Svt:         %20s,%d,%d\n",svt,o->svt.sequence1,o->svt.sequence2);
	dprintf ("Sb           %20x\n", o->sb);
	dprintf ("Cs:          %20x\n", o->cs);
	dprintf ("Ecount:      %20d\n", o->ecount);
	dprintf ("Ci:          %20x\n", o->ci);
	dprintf ("Co:          %20x\n", o->co);
	dprintf ("Sqh:         %20x\n", o->sqh);
	dprintf ("Oqh:         %20x\n", o->oqh);
	dprintf ("Iqh:         %20x\n", o->iqh);
	get_enum ("centry", o->centry, c);
	dprintf ("Centry:      %-20s\n", c);
	get_enum ("runstat", o->runstat, c);
	dprintf ("Runstat:     %-20s\n", c);
	get_enum ("control", o->control, c);
	dprintf ("Control:     %-20s\n", c);
	dprintf ("Type:   %-20s\n",o->typepointer->type );
	dprintf ("Rstate: %20x\n",o->rstate);
	if ( o->migrStatus != 0 )
	{
		dprintf ( "Migr Stat: %20x",o->migrStatus );
		dprintf ( " imsgs %d, omsgs %d states %d\n",o->num_imsgs, o->num_omsgs,
					o->num_states );
	}
	dprintf ("\n");

	drawline ();
}


dprintf (s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)
	Char *s;
	Long a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15;
{
#ifdef MARK3
#define printf _pprintf
#endif


#ifdef TRANSPUTER
#define printf _pprintf
#endif

	printf (s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

drawline ()
{
	dprintf (
			 "--------------------------------------------------------------------------------\n");
}

/* Print a load array gathered for dynamic load management. */

extern int migrPerInt;

showLoadArray ( loadArray )

	int loadArray[];
{
	int i,entries, entriesPerLine;


	entriesPerLine = 0;

	_pprintf ( "        node    util    node    util    node    util    node    util\n");
	for ( i = 0; i < tw_num_nodes; i++ )
	{
		dprintf ( "     %d:     %d", i, loadArray[i] );
		entriesPerLine++;

		if ( entriesPerLine > 3)
		{
			dprintf ( "\n" );
			entriesPerLine = 0;
		}
	}

	if (entriesPerLine != 0)
		dprintf ( "\n");
}

showHomeNode ( name )

char * name;
{
	int HomeNode;

	HomeNode = name_hash_function(name,HOME_NODE);

	dprintf ( "	Object:	%s		Home Node: %d\n", name, HomeNode );

	return ( HomeNode );
}

showListHdr ( listElement )
	List_hdr ** listElement;
{
	List_hdr          *l;

	l = *listElement;

   dprintf("prev:       %x\n", l->prev );
   dprintf("next:       %x\n", l->next );
   dprintf("size:       %d\n", l->size );
}

#if PARANOID

validState ( state )

	State       *state;

{
	int         i;
	List_hdr    *l;

	l = (List_hdr*)state - 1;
	if ((l->next->prev != l) || (l->size == 0))
		{       /* bad state header */
		_pprintf("Invalid state header: %x\n",state);
		tester();
		}
	if (state->address_table == NULL)
		return;
	l = (List_hdr*)(state->address_table) - 1;
	if ((l->next->prev != l) || (l->size == 0))
		{       /* bad address table header */
		_pprintf("Invalid address table header: %x\n",state->address_table);
		tester();
		}
	for (i = 0; i < l_size(state->address_table / sizeof(Address)); i++)
		{       /* loop through address table */
		if (state->address_table[i] == NULL)
			continue;
		if (state->address_table[i] == DEFERRED)
			continue;
		l = (List_hdr*)(state->address_table[i]) -1;
		if ((l->next->prev != l) || (l->size == 0))
			{   /* bad segment header */
			_pprintf("Invalid segment header: %x\n",state->address_table[i]);
			tester();
			}
		}
}  /* validState */

#endif
@


1.16
log
@Changed showocb to show how many events throttling permits
@
text
@d7 3
d369 2
a370 2
			count += (((List_hdr *)o->sb)-1)->size + OVERHEAD;
			count += (((List_hdr *)o->stk)-1)->size + OVERHEAD;
d445 1
a445 1
		b += (((List_hdr *)m)-1)->size + OVERHEAD;
d458 1
a458 1
		b += (((List_hdr *)m)-1)->size + OVERHEAD;
d488 1
a488 1
	b = Max_Addresses * sizeof(Address) + OVERHEAD;
d490 1
a490 1
	for ( i = 0; i < Max_Addresses; i++ )
d496 1
a496 1
			b += (((List_hdr *)addr)-1)->size + OVERHEAD;
d662 1
a662 1
	dumparray ((Char *) (s + 1), (((List_hdr *)s)-1)->size - sizeof(State));
d671 1
a671 1
		for ( i = 0; i < Max_Addresses; i++ )
d678 1
a678 1
					dumparray ( a, (((List_hdr *)a)-1)->size );
d710 1
a710 1
		for ( i = 0; i < Max_Addresses; i++ )
d717 1
a717 2
					dprintf("%d %d      %x\n",i,(((List_hdr *) a) -1)->size,
						a);
d1296 1
a1296 1
	for (i = 0; i < Max_Addresses; i++)
@


1.15
log
@Fix merge error.
@
text
@d7 3
d805 1
a805 1
"Name          Phase   Limit  Ocb Ptr   Svt    IQ mem OQ mem SQ mem entry rstat\n" );
d853 1
a853 1
	dprintf ( "%-12s %7s %7s %8x %7s %6d %6d %6d %5s %-6s\n",
d855 1
a855 1
		centry, runstat );
@


1.14
log
@Add sequence times to gvt printouts.
@
text
@d7 3
d635 1
@


1.13
log
@Added debugging info for critical path mechanism
@
text
@d7 3
d533 1
a533 1
	dprintf ("Sendtime:    %-10s\n", time);
d631 1
a631 1
	dprintf ("Sendtime:    %-20s\n", time);
d1157 1
a1157 1
	dprintf ("Svt:         %20s\n", svt);
d1262 1
a1262 1
	
@


1.12
log
@Fixed showHomeNode() so it would actually print the home node number, not
just return it.
@
text
@d7 4
d546 14
d603 2
a604 1
	char * serror = "no error";
d611 2
a612 2
	dprintf ( "%8x  %6s   %-10s  object type = %s, state flag = %d\n",
		s, sndtim, serror, s->otype->type, s->stype );
d637 1
d642 7
d810 1
a810 1
	dprintf("Type       size\n");
d815 1
a815 1
		  dprintf("%s   %d\n",type_table[i].type, type_table[i].statesize);
d1172 5
a1176 1
	  dprintf ( "Migr Stat: %20x\n",o->migrStatus );
@


1.11
log
@New copyright notice.
@
text
@d7 3
d1211 2
@


1.10
log
@Don't count system message with gid.num 0 as bad.
@
text
@d1 4
d7 3
a44 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.9
log
@Tab conversion.
@
text
@d2 4
a5 1
 * $Log:        buglib2.c,v $
d510 2
a511 1
	if ((m->gid.node >= tw_num_nodes) || (m->gid.num == 0))
@


1.8
log
@1.  Keep tester from bombing when bad msg is entered (bug 6).
2.  Add tester routine to dump list headers.
3.  Add validState() for PARANOID testing.
@
text
@d2 6
a7 1
 * $Log:	buglib2.c,v $
d33 1
a33 1
char buglib2_id [] = "@@(#)buglib2.c	1.67\t10/23/89\t11:02:54\tTIMEWARP";
d35 3
a37 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d43 2
a44 2
	This module contains routines that support debugging and other
	informatory output from the system.
d48 4
a51 4
	get_enum(type,symbolic_constant) - convert a numeric condition
		code into a string
		Parameters - Char *type, int symbolic constant
		Return - a pointer to the string
d53 3
a55 3
	dumparray(u,n) - print an array, both in alpha and hex
		Parameters - char *u, int n
		Return -  Always returns zero
d57 3
a59 3
	mem_used_in_queues() - calculate and print the memory used in queues
		Parameters - none
		Return - Always returns zero
d61 3
a63 3
	showschedq() - print out a scheduler queue, in short form
		Parameters - none
		Return - Always returns zero
d65 3
a67 3
	showsq(o) - shwo an object's state queue
		Parameters - Ocb o
		Return - Always returns zero
d69 4
a72 4
	returnoqmem(o) - calculate the amount of memory in an object's output
		queue
		Parameters - Ocb *o
		Return - the amount of memory
d74 4
a77 4
	returniqmem(o) - calculate the amount of memory in an object's input
		queue
		Parameters - Ocb *o
		Return - the amount of memory
d79 4
a82 4
	returnsqmem(o) - calculate the amount of memory in an object's state
		queue
		Parameters - Ocb *o
		Return - the amount of memory
d84 4
a87 4
	countoqmem(o) - print the amount of memory in an object's output
		queue
		Parameters - Ocb *o
		Return - Always returns zero
d89 4
a92 4
	countiqmem(o) - print the amount of memory in an object's input
		queue
		Parameters - Ocb *o
		Return - Always returns zero
d94 4
a97 4
	countsqmem(o) - print the amount of memory in an object's state
		queue
		Parameters - Ocb *o
		Return - Always returns zero
d99 3
a101 3
	showiq(o) - print out an object's input queue
		Parameters - Ocb *o
		Return - Always returns zero
d103 3
a105 3
	showoq(o) - print out an object's output queue
		Parameters - Ocb *o
		Return - Always returns zero
d107 3
a109 3
	dumpmsg(m) - print out a message
		Parameters - Msgh *m
		Return - Always returns zero
d111 3
a113 3
	showmsg_head() - print a message heading
		Parameters - none
		Return - Always returns zero
d115 3
a117 3
	showmsg(m) - print a message in abbreviated form
		Parameters - Msgh *m
		Return - Always returns zero
d119 3
a121 3
	show_state_head() - print out a state heading
		Parameters - none
		Return - Always returns zero
d123 3
a125 3
	showstate(s) - print out a state in abbreviated form
		Parameters - State *s
		Return - Always returns zero
d127 3
a129 3
	dumpstate(s) - print out a state in long form
		Parameters - State *s
		Return - Always returns zero
d131 3
a133 3
	ttoc(string,time) - convert a virtual time to a user-readable string
		Parameters - char *string, VTime time
		Return - Always returns zero
d135 3
a137 3
	showocb_head() - print out an ocb heading
		Parameters - none
		Return - Always returns zero
d139 3
a141 3
	showocb(o) - print out an ocb
		Parameters - Ocb *o
		Return - Always returns zero
d143 4
a146 4
	general_ocb_by_name(name) - find an object's location from its name
		Parameters - char *name
		Return - a pointer to its location, or NULL if it
			doesn't exist, or isn't on this node
d148 3
a150 3
	show_iq_by_name(name) - show the input queue of the named object
		Parameters - char *name
		Return - Always returns zero
d152 3
a154 3
	show_oq_by_name(name) - show the output queue of the named object
		Parameters - char *name
		Return - Always returns zero
d156 3
a158 3
	show_sq_by_name(name) - show the state queue of the named object
		Parameters - char *name
		Return - Always returns zero
d160 3
a162 3
	dump_ocb_by_name(name) - dump the ocb of the named object
		Parameters - char *name
		Return - Always returns zero
d164 3
a166 3
	dumpocb(o) - make a complete dump of an ocb
		Parameters - Ocb *o
		Return - Always returns zero
d168 4
a171 4
	dprintf(s,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) - 
		do a formatted print of the data provided
		Parameters - Char *s, Long a1 through a15
		Return - Always returns zero
d173 3
a175 3
	drawline() - print out a line of underscores
		Parameters - none
		Return - Always returns zero
d179 4
a182 4
	While buglib2.c contains a lot of routines, there is little
	code of much interest here.  Most of it is rather repetitive
	output formatting, or slightly differing interfaces for
	accessing the same data.  
d184 11
a194 11
	A couple of routines are worth noting.
	get_enum() is worthy of mention because
	it provides a method of converting condition codes to 
	strings that is used for several different types of data
	structures.  The static array "list" (a real loser of a
	variable name) contains the data that get_enum() needs to 
	translate the name of the type of the condition code field
	and a specific integer condition code type to a short string
	suitable for output.  This interface is used for the run status
	of objects; for their error status, if any; for their edge
	status; for the status of messages; and for message types.
d196 3
a198 3
	dumparray() is a generalized array dumper that puts its output
	in a format similar to the well-known od output format, except
	that dumparray() uses hex.
d200 2
a201 2
	These aside, there is little in this code that is tricky,
	interesting, important, or otherwise worthy of mention. 
d212 3
a214 3
    char            * typefield;
    char            * constant_name;
    int 	      constant_value;
d216 1
a216 1
    list[] =
d218 9
a226 9
    {              "runstat", "READY", READY   			},
    {              "runstat", "BLKINF", BLKINF   		},
    {               "runstat", "BLKPKT", BLKPKT   		},
    {	            "runstat", "GOFWD", GOFWD   		},
    {               "runstat", "ARCP", ARCP   			},
    {               "runstat", "ARLBK", ARLBK   		},
    {               "runstat", "STDOUT", ITS_STDOUT   		},
    {               "runstat", "BLKSTA", BLKSTATE   		},
    {               "runstat", "BLKPHA", BLKPHASE   		},
d228 5
a232 5
    {               "centry", "INIT", INIT   			},
    {               "centry", "EVENT", EVENT   			},
    {	            "centry", "TERM", TERM   			},
    {		    "centry", "CREATE", DCRT			},
    {		    "centry", "DESTR", DDES			},
d234 8
a241 8
    {	            "mtype", "CMSG", CMSG   			},
    {               "mtype", "EMSG", EMSG   			},
    {	            "mtype", "TMSG", TMSG   			},
    {		    "mtype", "DYNCR", DYNCRMSG			},
    {		    "mtype", "DYNDS", DYNDSMSG			},
    {               "mtype", "GVTSYS", GVTSYS   		},
    {               "mtype", "COMMAND", COMMAND   		},
    {               "mtype", "CRT_ACK", CRT_ACK   		},
d243 1
a243 1
    {               "node", "BCAST", BCAST   			},
d245 2
a246 2
    {               "control", "EDGE", EDGE 			},
    {               "control", "NON-EDGE", NONEDGE 		},
d248 1
a248 1
    {               NULL, NULL, 0				}
d253 3
a255 3
    Char           *type;
    int             symbolic_constant;
    char           *p;
d257 2
a258 2
    struct enum_dat *l; 
    int             n;
d260 5
a264 5
    if (type == NULL)
    {
	strcpy (p, " **> ERROR <**");
	return;
    }
d266 1
a266 1
    n = 0;
d268 1
a268 3
    for (l = list; l->typefield[0] != '\0'; l++)
    {
	if (strcmp (l->typefield, type) == SUCCESS)
d270 12
a281 6
	    n++;
	    if (l->constant_value == symbolic_constant)
	    {
		strcpy (p, l->constant_name);
		return;
	    }
a282 4
	else
	if (n > 0)
	    break;
    }
d284 1
a284 1
    itoa (symbolic_constant, p);
d288 2
a289 2
    char           *u;
    int             n;
d291 5
a295 5
    char            s[80];
    char            t[10],
                    c;
    int             i,
                    j;
d297 2
a298 2
    s[78] = '\n';
    s[79] = '\0';
d302 3
a304 3
    for (i = 0; i < n;)
    {
	clrs
d306 1
a306 1
	sprintf (t, "%3.3x:", i % 0x1000);
d308 4
a311 4
	s[0] = toupper (t[0]);
	s[1] = toupper (t[1]);
	s[2] = toupper (t[2]);
	s[3] = t[3];
d313 8
a320 6
	for (j = 0; j < 16 && i < n; j++, i++)
	{
	    sprintf (t, "%2x ", 0377 & (c = 0377 & u[i]));
	    s[5 + 3 * j] = toupper (t[0]);
	    s[5 + 3 * j + 1] = toupper (t[1]);
	    s[5 + 52 + j] = c < 32 || c > 127 ? '.' : c;
a321 2
	dprintf ("%s", s);
    }
d334 3
a336 3
    Ocb            *o;
    Long            count = OVERHEAD;
    List_hdr * free;
d338 1
a338 4
    for (o = fstocb_macro; o; o = nxtocb_macro (o))
    {
	count += sizeof(Ocb) + OVERHEAD;
	if ( o->sb != NULL )
d340 9
a348 2
	    count += (((List_hdr *)o->sb)-1)->size + OVERHEAD;
	    count += (((List_hdr *)o->stk)-1)->size + OVERHEAD;
d350 1
a350 5
	count += (long) returniqmem (o);
	count += (long) returnoqmem (o);
	count += (long) returnsqmem (o);
    }
    _pprintf ("Total memory used in queues = %ld bytes\n", count);
d352 3
a354 3
    if ( free_pool != NULL )
    {
	count = OVERHEAD;
d356 7
a362 4
	for ( free = l_next_macro ( free_pool ); free != free_pool;
	      free = l_next_macro ( free ) )
	{
	    count += (free-1)->size + OVERHEAD;
d365 3
a367 2
	_pprintf ( "Free pool size %d # of bytes %d\n", free_pool_size, count );
    }
d369 5
a373 3
    if ( msg_free_pool != NULL )
    {
	count = OVERHEAD;
d375 1
a375 4
	for ( free = l_next_macro ( msg_free_pool ); free != msg_free_pool;
	      free = l_next_macro ( free ) )
	{
	    count += (free-1)->size + OVERHEAD;
a376 3

	_pprintf ( "Mesg pool size %d # of bytes %d\n", msg_free_pool_size, count );
    }
d381 1
a381 1
    Ocb            *o;
d383 3
a385 3
    showocb_head ();
    for (o = fstocb_macro; o; o = nxtocb_macro (o))
	showocb (o);
d390 1
a390 1
    deadOcb            *o;
d394 2
a395 2
       printf("%s      %f      %f\n",o->name,o->phaseBegin.simtime,
              o->phaseEnd.simtime);
d400 1
a400 1
    Ocb            *o;
d402 1
a402 1
    State          *s;
d404 5
a408 5
    showstate_head ();
    for (s = fststate_macro (o); s; s = nxtstate_macro (s))
    {
	showstate (s);
    }
d412 1
a412 1
    Ocb            *o;
d414 2
a415 2
    Msgh           *m;
    int             b;
d417 4
a420 4
    b = OVERHEAD;
    for (m = fstomsg_macro (o); m; m = nxtomsg_macro (m))
	b += (((List_hdr *)m)-1)->size + OVERHEAD;
    return b;
d425 1
a425 1
    Ocb            *o;
d427 2
a428 2
    Msgh           *m;
    int             b;
d430 4
a433 4
    b = OVERHEAD;
    for (m = fstimsg_macro (o); m; m = nxtimsg_macro (m))
	b += (((List_hdr *)m)-1)->size + OVERHEAD;
    return b;
d438 1
a438 1
    Ocb            *o;
d440 2
a441 2
    State          *m;
    int             b;
d443 4
a446 4
    b = OVERHEAD;
    for (m = fststate_macro (o); m; m = nxtstate_macro (m))
    {
	b += sizeof (State) + o->pvz_len + 12 + OVERHEAD;
d448 3
a450 3
	b += dynamic_mem (m);
    }
    return b;
d455 1
a455 1
    State          *m;
d457 1
a457 1
    int             b, i;
d459 2
a460 2
    if ( m->address_table == NULL )
	return 0;
d462 1
a462 1
    b = Max_Addresses * sizeof(Address) + OVERHEAD;
d464 3
a466 3
    for ( i = 0; i < Max_Addresses; i++ )
    {
	Address addr = m->address_table[i];
d468 4
a471 3
	if ( (addr != NULL) & (addr != DEFERRED) )
	{
	    b += (((List_hdr *)addr)-1)->size + OVERHEAD;
a472 1
    }
d474 1
a474 1
    return b;
d478 1
a478 1
    Ocb            *o;
d480 1
a480 1
    Msgh           *m;
d482 5
a486 5
    showmsg_head ();
    for (m = fstimsg_macro (o); m; m = nxtimsg_macro (m))
    {
	showmsg (m);
    }
d490 1
a490 1
    Ocb            *o;
d492 1
a492 1
    Msgh           *m;
d494 5
a498 5
    showmsg_head ();
    for (m = fstomsg_macro (o); m; m = nxtomsg_macro (m))
    {
	showmsg (m);
    }
d502 1
a502 1
    Msgh           *m;
d504 2
a505 2
    char           c[20];
    char            time[12];
d507 19
a525 19
    if ((m->gid.node >= tw_num_nodes) || (m->gid.num == 0))
	{
	dprintf("Bad message\n");
	return;
	}
    dprintf (" ****** MESSAGE *********[ %lx ]**********************\n", m);
    dprintf ("Sender:      %-20s\n", m->snder);
    ttoc (time, m->sndtim);
    dprintf ("Sendtime:    %-10s\n", time);
    dprintf ("Receiver:    %-20s\n", m->rcver);
    ttoc (time, m->rcvtim);
    dprintf ("Rcvtime:     %-10s\n", time);
    dprintf ("Selector:    %20d\n", m->selector);
    dprintf ("- Gid.Node:  %20d\n", m->gid.node);
    dprintf ("  Gid.Num:   %20d\n", m->gid.num);
    dprintf ("Bits (hex):  %20x\n", m->flags);
    get_enum ("mtype", m->mtype, c);
    dprintf ("Mtype:       %-20s\n", c);
    dprintf ("Txtlen:      %20d\n", m->txtlen);
d527 1
a527 1
    dprintf ("Ept:    %20d\n", m->Ept);
d529 1
a529 1
    dprintf ("\n");
d531 1
a531 1
    dumparray ((Char *) (m + 1), m->txtlen);
d533 1
a533 1
    drawline ();
d538 2
a539 2
    dprintf ( "\n" );
    dprintf (
d544 1
a544 1
    Msgh           *m;
d546 3
a548 3
    char            mtype[20];
    char            sndtim[12];
    char            rcvtim[12];
d550 2
a551 2
    if (m == NULL)
	return;
d556 6
a561 6
    ttoc (sndtim, m->sndtim);
    ttoc (rcvtim, m->rcvtim);
    get_enum ("mtype", m->mtype, mtype);
    dprintf ( "%-8x %-16s %6s %-16s %6s %2d %4d %2x %-5s\n",
	m, m->snder, sndtim, m->rcver, rcvtim, m->gid.node, m->gid.num,
	m->flags, mtype );
d566 2
a567 2
    dprintf ( "\n" );
    dprintf (" Address  sndtim   Serror\n");
d571 1
a571 1
    State          *s;
d573 4
a576 4
    char	    sndtim[12];
    char * serror = "no error";
    if ( s->serror != NOERR )
	serror = s->serror;
d580 3
a582 3
    ttoc ( sndtim, s->sndtim );
    dprintf ( "%8x  %6s   %-10s  object type = %s, state flag = %d\n",
	s, sndtim, serror, s->otype->type, s->stype );
d587 1
a587 1
    State          *s;
d589 3
a591 3
    char            time[12];
    char * serror = "no error";
    Ocb       * o;
d593 2
a594 2
    if ( s->serror != NOERR )
	serror = s->serror;
d596 8
a603 8
    dprintf (" ******  STATE  *********[ %lx ]**********************\n", s);
    ttoc (time, s->sndtim);
    dprintf ("Sendtime:    %-20s\n", time);
    dprintf ("Serror:      %-20s\n", serror);
    dprintf ("Stype:       %d\n", s->stype);
    dprintf ("Ocb:         %x\n", s->ocb);
    o = (Ocb *) s->ocb;
    dprintf ("Object: %-20s\n",o->name);
d605 2
a606 2
    dprintf("Ept:     %d\n",s->Ept);
    dprintf("Prev Ept:        %d\n",s->previousEpt);
d609 1
a609 1
    dprintf ("\n");
d611 1
a611 1
    dumparray ((Char *) (s + 1), (((List_hdr *)s)-1)->size - sizeof(State));
d613 1
a613 1
    drawline ();
d615 4
a618 4
    if ( s->address_table != NULL )
    {
	register Address a;
	register int i;
d620 11
a630 10
	for ( i = 0; i < Max_Addresses; i++ )
	{
	    if ( ( a = s->address_table[i] ) )
	    {
		if ( a == (Address)-1 )
		    dprintf ("DEFERRED\n");
		else
		    dumparray ( a, (((List_hdr *)a)-1)->size );
		drawline ();
	    }
a631 1
    }
d636 1
a636 1
    State ** state;
d638 1
a638 1
    dumpstateAddrTable ( *state );
d642 1
a642 1
    State *s;
d644 1
a644 1
    char            time[12];
d646 1
a646 1
    ttoc (time, s->sndtim);
d648 2
a649 2
    printf("dumping address table for object %s, time %f\n", ((Ocb *) s->ocb)->name,
		time);
d651 4
a654 4
    if ( s->address_table != NULL )
    {
	register Address a;
	register int i;
d656 2
a657 2
	dprintf("Max_Addresses is %d\n", Max_Addresses );
    	dprintf("Entry	Size	Address\n");
d659 13
a671 1
	for ( i = 0; i < Max_Addresses; i++ )
d673 1
a673 8
	    if ( ( a = s->address_table[i] ) )
	    {
		if ( a == (Address)-1 )
		    dprintf ("DEFERRED\n");
		else
		    dprintf("%d	%d	%x\n",i,(((List_hdr *) a) -1)->size,
			a);
	    }
a674 5
    }
    else
    {
	dprintf("no address table for state\n");
    }
d679 1
a679 1
State	* state_ptr;
d684 7
a690 7
	    state_ptr->sndtim.simtime,
	    state_ptr->segno,
	    state_ptr->no_segs,
	    state_ptr->pktno,
	    state_ptr->no_pkts,
	    state_ptr->tot_pkts
	  );
d693 1
a693 1
/*PJH#1	*/
d699 1
a699 1
    Ocb *o;
d701 1
a701 1
    o = (Ocb *) migr_hdr->state->ocb;
d704 7
a710 7
	     o->name,
	     migr_hdr->time_to_deliver.simtime,
	     migr_hdr->to_node,
	     migr_hdr->waiting_for_ack,
	     migr_hdr->waiting_for_done,
	     migr_hdr->migr_flags
	    );
d714 1
a714 1
ttoc ( string, time )		/* time to character */
d716 2
a717 2
    char * string;
    VTime time;
d719 13
a731 13
    if ( eqSTime ( time.simtime, posinf.simtime ) )
	strcpy ( string, "+inf  " );
    else
    if ( eqSTime ( time.simtime, posinfPlus1.simtime ) )
	strcpy ( string, "+inf+1" );
    else
    if ( eqSTime ( time.simtime, neginf.simtime ) )
	strcpy ( string, "-inf  " );
    else
    if ( eqSTime ( time.simtime, neginfPlus1.simtime ) )
	strcpy ( string, "-inf+1" );
    else
	sprintf ( string, "%.2f", time.simtime );
d734 3
a736 3
ttoc1 (string, time)		/* time to character */
    char           *string;
    VTime           time;
d738 13
a750 13
    if (time.simtime == POSINF)
	strcpy (string, "posInf");
    else
    if (time.simtime == POSINF+1)
	strcpy (string, "posInf");
    else
    if (time.simtime == NEGINF)
	strcpy (string, "negInf");
    else
    if (time.simtime == NEGINF+1)
	strcpy (string, "negInf");
    else
	sprintf (string, "%.2f", time.simtime);
d755 2
a756 2
    dprintf ( "\n" );
    dprintf (
d761 1
a761 1
    Ocb *o;
d764 1
a764 1
      showocb (*o);
d769 1
a769 1
    int i;
d771 9
a779 9
    dprintf("State hdr is %d bytes\n",sizeof ( State ));
    dprintf("Type	size\n");
    for ( i = 0; i < MAXNTYP; i++)
    {  
      if ( type_table[i].type != NULL)
      {
          dprintf("%s	%d\n",type_table[i].type, type_table[i].statesize);
      }
    }  
d783 1
a783 1
    Ocb            *o;
d785 8
a792 8
    char phase[12];
    char limit[12];
    char            svt[12];
    int             iqmem;
    int             oqmem;
    int             sqmem;
    char            centry[20];
    char            runstat[20];
d797 11
a807 11
    ttoc (phase, o->phase_begin );
    ttoc (limit, o->phase_limit );
    ttoc (svt, o->svt);
    iqmem = returniqmem (o);
    oqmem = returnoqmem (o);
    sqmem = returnsqmem (o);
    get_enum ("centry", o->centry, centry);
    get_enum ("runstat", o->runstat, runstat);
    dprintf ( "%-12s %7s %7s %8x %7s %6d %6d %6d %5s %-6s\n",
	o->name, phase, limit, o, svt, iqmem, oqmem, sqmem,
	centry, runstat );
d811 1
a811 1
    char           *name;
d813 4
a816 4
    Ocb            *o;
    Objloc	   *location;
    char phase_name[20];
    STime phase_time = NEGINF+1;
d818 1
a818 1
    sscanf ( name, "%s %lf", phase_name, &phase_time );
d820 16
a835 16
    if ((location = GetLocation(phase_name,newVTime(phase_time,0,0))) == 
		(Objloc *) NULL || location->node == -1)
    {
	if (name_hash_function(phase_name,HOME_NODE) != miparm.me)
		dprintf ("%s not found; try on node %d\n", phase_name,
			name_hash_function(phase_name,HOME_NODE));
	else
		dprintf ("%s does not exist\n",phase_name);
	return NULL;
    }
    if ((o = location->po) == NULL)
    {
	dprintf ("%s is on node %d\n", phase_name, location->node);
	return NULL;
    }
    return o;
d840 2
a841 2
    char	*name;
    STime	ptime;
d843 3
a845 3
    Ocb		*o;
    Objloc	*location;
    VTime	vtime;
d847 1
a847 1
    vtime = newVTime ( ptime, 0, 0 );
d849 8
a856 8
    if ( (location = GetLocation ( name, vtime ) ) == NULL
    ||    location->node == -1 )
    {
	if ( name_hash_function ( name, HOME_NODE ) != miparm.me )
	    dprintf ( "%s not found; try on node %d\n", name,
		name_hash_function ( name, HOME_NODE ) );
	else
	    dprintf ( "%s does not exist\n", name );
d858 2
a859 2
	return ( NULL );
    }
d861 4
a864 4
    if ( (o = location->po) == NULL )
    {
	dprintf ( "%s at %f is on node %d\n", name, vtime.simtime,
		location->node);
d866 2
a867 2
	return ( NULL );
    }
d869 1
a869 1
    return ( o );
d874 1
a874 1
    Msgh ** msg;
d876 1
a876 1
    Ocb * o;
d878 1
a878 3
    if ( ( o = general_ocb_by_phase ((*msg)->rcver, (*msg)->rcvtim) ) != NULL )
    {
	if ( o->typepointer->displayMsg )
d880 6
a885 1
	    o->typepointer->displayMsg ( (*msg)->selector, (*msg) + 1 );
d888 1
a888 4
	    dumpmsg ( *msg );
    }
    else
	dumpmsg ( *msg );
d893 1
a893 1
    State ** state;
d895 1
a895 1
    Typtbl * type = (*state)->otype;
d897 1
a897 1
    int offset = type - type_table;
d899 2
a900 2
    if ( offset < 0 || offset >= MAXNTYP )
	return;
d902 6
a907 6
    if ( (*state)->otype->displayState )
    {
	(*state)->otype->displayState ( (*state) + 1 );
    }
    else
	dumpstate ( *state );
d912 1
a912 1
    char * name;
d914 1
a914 1
    Ocb * o;
d916 4
a919 4
    if ( ( o = general_ocb_by_name ( name ) ) != NULL )
    {
	showiq ( o );
    }
d924 2
a925 2
    char * name;
    STime * ptime;
d927 2
a928 2
    Ocb * o;
    VTime vtime;
d930 1
a930 1
    vtime = newVTime ( *ptime, 0, 0 );
d932 4
a935 4
    if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
    {
	showiq ( o );
    }
d940 1
a940 1
    char * name;
d942 1
a942 1
    Ocb * o;
d944 4
a947 4
    if ( ( o = general_ocb_by_name ( name ) ) != NULL )
    {
	showoq ( o );
    }
d952 2
a953 2
    char * name;
    STime * ptime;
d955 2
a956 2
    Ocb * o;
    VTime vtime;
d958 1
a958 1
    vtime = newVTime ( *ptime, 0, 0 );
d960 4
a963 4
    if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
    {
	showoq ( o );
    }
d968 1
a968 1
    char * name;
d970 1
a970 1
    Ocb * o;
d972 4
a975 4
    if ( ( o = general_ocb_by_name ( name ) ) != NULL )
    {
	showsq ( o );
    }
d980 2
a981 2
    char * name;
    STime * ptime;
d983 2
a984 2
    Ocb * o;
    VTime vtime;
d986 1
a986 1
    vtime = newVTime ( *ptime, 0, 0 );
d988 4
a991 4
    if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
    {
	showsq ( o );
    }
d996 1
a996 1
    char * name;
d998 1
a998 1
    Ocb * o;
d1000 4
a1003 4
    if ( ( o = general_ocb_by_name ( name ) ) != NULL )
    {
	dumpocb ( o );
    }
d1008 2
a1009 2
    char * name;
    STime * ptime;
d1011 2
a1012 2
    Ocb * o;
    VTime vtime;
d1014 1
a1014 1
    vtime = newVTime ( *ptime, 0, 0 );
d1016 4
a1019 4
    if ( ( o = general_ocb_by_phase ( name, vtime ) ) != NULL )
    {
	dumpocb ( o );
    }
d1025 1
a1025 1
    char * name;
d1027 1
a1027 1
    Ocb * ocb;
d1029 3
a1031 5
    if ( sendOcbQ )
    for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
          ocb = nxtocb_macro ( ocb ) )
    {
	if ( namecmp ( name, ocb->name ) == 0 )
d1033 5
a1037 2
	    dprintf ( "Object %s - \n", ocb->name );
	    showiq ( ocb );
a1038 1
    }
d1043 1
a1043 1
    char * name;
d1045 1
a1045 1
    Ocb * ocb;
d1047 3
a1049 5
    if ( sendOcbQ )
    for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
          ocb = nxtocb_macro ( ocb ) )
    {
	if ( namecmp ( name, ocb->name ) == 0 )
d1051 5
a1055 2
	    dprintf ( "Object %s - \n", ocb->name );
	    showoq ( ocb );
a1056 1
    }
d1061 1
a1061 1
    char * name;
d1063 1
a1063 1
    Ocb * ocb;
d1065 9
a1073 8
    if ( sendOcbQ )
    for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
          ocb = nxtocb_macro ( ocb ) )
    {
	if ( namecmp ( name, ocb->name ) == 0 )
	{    
	    dprintf ( "Object %s - \n", ocb->name );
	    showsq ( ocb );
a1074 1
    }
d1081 1
a1081 1
    char * name;
d1083 1
a1083 1
    Ocb * ocb;
d1085 9
a1093 8
    if ( sendOcbQ )
    for ( ocb = nxtocb_macro ( sendOcbQ ); ocb != NULL;
          ocb = nxtocb_macro ( ocb ) )
    {
	if ( namecmp ( name, ocb->name ) == 0 )
	{    
	    dprintf ( "Object %s - \n", ocb->name );
	    dumpocb ( ocb );
a1094 1
    }
d1099 1
a1099 1
    Ocb * o;
d1101 5
a1105 5
    char phase[12];
    char phase_end[12];
    char phase_limit[12];
    char svt[12];
    char c[20];
d1107 29
a1135 29
    ttoc (phase, o->phase_begin );
    ttoc (phase_end, o->phase_end );
    ttoc (phase_limit, o->phase_limit );
    ttoc (svt, o->svt);
    dprintf (" ****** OCB     *********[ %lx ]**********************\n", o);
    dprintf ("Name:        %-20s\n", o->name);
    dprintf ("Phase Begin: %20s\n", phase);
    dprintf ("Phase End:   %20s\n", phase_end);
    dprintf ("Phase Limit: %20s\n", phase_limit);
    dprintf ("Svt:         %20s\n", svt);
    dprintf ("Sb           %20x\n", o->sb);
    dprintf ("Cs:          %20x\n", o->cs);
    dprintf ("Ecount:      %20d\n", o->ecount);
    dprintf ("Ci:          %20x\n", o->ci);
    dprintf ("Co:          %20x\n", o->co);
    dprintf ("Sqh:         %20x\n", o->sqh);
    dprintf ("Oqh:         %20x\n", o->oqh);
    dprintf ("Iqh:         %20x\n", o->iqh);
    get_enum ("centry", o->centry, c);
    dprintf ("Centry:      %-20s\n", c);
    get_enum ("runstat", o->runstat, c);
    dprintf ("Runstat:     %-20s\n", c);
    get_enum ("control", o->control, c);
    dprintf ("Control:     %-20s\n", c);
    dprintf ("Type:   %-20s\n",o->typepointer->type );
    dprintf ("Rstate: %20x\n",o->rstate);
    if ( o->migrStatus != 0 )
      dprintf ( "Migr Stat: %20x\n",o->migrStatus );
    dprintf ("\n");
d1137 1
a1137 1
    drawline ();
d1142 2
a1143 2
    Char *s;
    Long a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15;
d1154 1
a1154 1
    printf (s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
d1159 2
a1160 2
    dprintf (
	     "--------------------------------------------------------------------------------\n");
d1169 1
a1169 1
    int loadArray[];
d1171 1
a1171 1
    int i,entries, entriesPerLine;
d1174 1
a1174 1
    entriesPerLine = 0;
d1176 5
a1180 5
    _pprintf ( "	node	util	node	util	node	util	node	util\n");
    for ( i = 0; i < tw_num_nodes; i++ )
    {
	dprintf ( "	%d:	%d", i, loadArray[i] );
	entriesPerLine++;
d1182 5
a1186 4
	if ( entriesPerLine > 3)
	{
	    dprintf ( "\n" );
	    entriesPerLine = 0;
a1187 1
    }
d1189 2
a1190 2
    if (entriesPerLine != 0)
	dprintf ( "\n");
d1197 1
a1197 1
    int HomeNode;
d1199 1
a1199 1
    HomeNode = name_hash_function(name,HOME_NODE);
d1201 1
a1201 1
    return ( HomeNode );
d1205 1
a1205 1
    List_hdr ** listElement;
d1207 1
a1207 1
    List_hdr          *l;
d1209 1
a1209 1
    l = *listElement;
d1211 3
a1213 3
   dprintf("prev:	%x\n", l->prev );
   dprintf("next:	%x\n", l->next );
   dprintf("size:	%d\n", l->size );
d1215 1
a1215 1
    
d1220 1
a1220 1
    State	*state;
d1223 2
a1224 2
    int		i;
    List_hdr	*l;
d1226 27
a1252 27
    l = (List_hdr*)state - 1;
    if ((l->next->prev != l) || (l->size == 0))
	{	/* bad state header */
	_pprintf("Invalid state header: %x\n",state);
	tester();
	}
    if (state->address_table == NULL)
	return;
    l = (List_hdr*)(state->address_table) - 1;
    if ((l->next->prev != l) || (l->size == 0))
	{	/* bad address table header */
	_pprintf("Invalid address table header: %x\n",state->address_table);
	tester();
	}
    for (i = 0; i < Max_Addresses; i++)
	{	/* loop through address table */
	if (state->address_table[i] == NULL)
	    continue;
	if (state->address_table[i] == DEFERRED)
	    continue;
	l = (List_hdr*)(state->address_table[i]) -1;
    	if ((l->next->prev != l) || (l->size == 0))
	    {	/* bad segment header */
	    _pprintf("Invalid segment header: %x\n",state->address_table[i]);
	    tester();
	    }
	}
@


1.7
log
@Added a number of new routines for dynamic load management data
gathering.  Also added output lines to some existing routines.  Some code
is conditionally compiled to support Tapas Som's work.
@
text
@d3 5
d502 5
d694 6
a699 1
   dprintf ("dt %f: node %d: ack %d: done %d: migr_flags %d\n",
d766 2
d772 1
a772 1
          dprintf("%s %d\n",type_table[i].type, type_table[i].statesize);
d1198 53
@


1.6
log
@Enhance operation of dm() (from Steve).
@
text
@d3 3
d380 1
a380 1
    Ocb            *o;
d382 5
a386 3
    showocb_head ();
    for (o = fstdead_macro; o; o = nxtocb_macro (o))
	showocb (o);
d511 3
d576 2
d587 7
d740 20
a999 1
extern Ocb *sendOcbQ;
d1109 4
@


1.5
log
@use .simtime field as necessary
@
text
@d3 3
d828 2
@


1.4
log
@have dumpstateAddrTablex() call dumpstateAddrTable(), not dumpstate()
@
text
@d3 3
d429 1
a429 1
 
d436 1
a436 1
 
d440 1
a440 1
 
d443 1
a443 1
 
d445 1
a445 1
 
d449 1
a449 1
 
d455 1
a455 1
 
d647 1
a647 1
  
a671 1
	      
d673 1
d679 1
a679 1
    if ( eqSTime ( time, posinf ) )
d682 1
a682 1
    if ( eqSTime ( time, posinfPlus1 ) )
d685 1
a685 1
    if ( eqSTime ( time, neginf ) )
d688 1
a688 1
    if ( eqSTime ( time, neginfPlus1 ) )
d784 1
a784 1
 
d786 1
a786 1
 
d921 1
a921 1
 
d949 1
a949 1
 
d959 1
a959 1
 
d965 1
a965 1
 
d983 1
a983 1
 
d1001 1
a1001 1
 
d1097 1
a1097 1
 
@


1.3
log
@1.  fix bug in showschedq to handle deferred segments
2.  add code to handle staddrt tester command
@
text
@d3 4
d600 1
a600 1
    dumpstate ( *state );
@


1.2
log
@dumpstate now prints ocb field
@
text
@d3 3
d443 1
a443 1
	if ( addr != NULL )
d590 44
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d563 1
@
