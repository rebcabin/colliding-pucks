head     1.7;
branch   ;
access   ;
symbols  TW2_7:1.7 TW2_6:1.6 TW2_5_1:1.5 TW2_5:1.3 TW2_4_2:1.1 TW2_4_1:1.1 TW2_4:1.1;
locks    ; strict;
comment  @ * @;


1.7
date     91.12.27.09.07.28;  author pls;  state Rel;
branches ;
next     1.6;

1.6
date     91.11.06.11.11.08;  author configtw;  state Rel;
branches ;
next     1.5;

1.5
date     91.07.17.15.09.28;  author judy;  state Rel;
branches ;
next     1.4;

1.4
date     91.07.09.14.04.24;  author steve;  state Dev;
branches ;
next     1.3;

1.3
date     91.06.03.12.24.42;  author configtw;  state Rel;
branches ;
next     1.2;

1.2
date     91.04.01.15.39.15;  author reiher;  state Dev;
branches ;
next     1.1;

1.1
date     90.08.07.15.40.01;  author configtw;  state Rel;
branches ;
next     ;


desc
@machine dependent stuff
@


1.7
log
@Fix up TIMING code.
@
text
@/*      Copyright (C) 1989, 1991, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */

/*
 * $Log:	machdep.c,v $
 * Revision 1.6  91/11/06  11:11:08  configtw
 * Do casting.
 * 
 * Revision 1.5  91/07/17  15:09:28  judy
 * New copyright notice.
 * 
 * Revision 1.4  91/07/09  14:04:24  steve
 * 1. Added signal driven socket support.
 * 2. combined the Sun and BBN read_the_mail routines.
 * 3. removed mistuff and changed 128 to IH_NODE
 * 
 * Revision 1.3  91/06/03  12:24:42  configtw
 * Tab conversion.
 *
 * Revision 1.2  91/04/01  15:39:15  reiher
 * Bug fix to not consider IH messages in gvt calculation.
 * 
 * Revision 1.1  90/08/07  15:40:01  configtw
 * Initial revision
 * 
*/
char machdep_id [] = "@@(#)machdep.c     1.58\t10/2/89\t14:45:42\tTIMEWARP";


/*

Purpose:

		machdep.c is meant to contain as much of Time Warp's machine
		dependent code as possible.  Some machine dependent code must
		be kept elsewhere, because it is intimately related to higher
		level functions.  The smaller pieces of code that have little
		to do with anything else are kept here.

		machdep.c is a temporary arrangement. In the future, we expect to
		replace it with a separate file for each type of machine supported.
		For instance, there would be a sun.c, a mark3.c, and a butterfly.c.
		These modules would contain only the code needed for that particular
		machine.

Functions:

		check_mercury_queue() -  look for a message in the mercury queue
						more important than what we're doing
				Parameters - none
				Return - TRUE or FALSE

		ioint(ptr1,ptr2) - check whether we want to switch context on
						an interrupt
				Parameters - MSG_STR_PTR ptr1, int * ptr2
				Return - 0 if the message is to be processed, 1 if the
						message has been cleared
				[Sun version has no parameters]

		read_the_mail() - examine incoming messages
				Parameters - none
				Return - Always returns zero

		print_acks() - print the contents of the acks table
				Parameters - none
				Return - Always returns zero

		ioint_rcvack(msg,node) - remove an ack from the acks table because of
						an interrupt
				Parameters - Ack_msg  *msg, Int node
				Return - 0 if failure, 1 if successful

		_pprintf(form,arg1,arg2, . . . , arg15) - printf to stdout with node 
						number added to the front
				Parameters -  char * form, int * arg1, int * arg2, . . . ,
								int * arg15
				Return - Always returns zero

		check_for_keyin() - on a Sun, check if there's any keyboard input
				Parameters - none
				Return - Always returns zero

Implementation:

		check_mercury_queue() calls cnt_msgs() to determine how many
		messages are queued.  For each, call peek_msg().  If the message
		came from the CP, or was an ack, or it was a system message, or
		its receive time is not greater than the simulation time of the
		currently executing object go to the end of the routine.  Otherwise,
		look at the next message.  If the end of the routine is reached
		by normal loop termination, we didn't find an earlier message, 
		and FALSE is returned.  If one of the earlier mentioned tests
		succeeded, we found a message that needs immediate processing,
		so we return TRUE.  (Essentially, this routine checks to see
		if an incoming message is of sufficient importance to interrupt
		the executing object.)

		ioint() deals with interrupts.  If the type of the interrupt is
		unknown, or is from the CP, just increment a counter.  If the
		interrupting message is an ack, call ioint_rcvack().  If it's
		any other type of message, check to see if it should preempt
		the object, calling switch_preempt() if it should.  ioint() is
		called by the assembly language routine that performs switching
		functions.  switch_preempt() is also in that assembly language
		code.  If the object is preempted, the system will return to
		the main loop, where it will check for mercury messages and
		process the interrupting one.  If we're not on a Mark3, then
		all that ioint() does is call check_for_keyin().

		read_the_mail() looks at incoming messages.  It calls get_msg()
		to retrieve one.  If it came from the CP, essentially throw it
		away, possibly after storing some information it contained.
		If it came from elsewhere, copy the message to rm_buf.  If it's
		an ack, call rcv_ack() and get another message.  Otherwise, 
		store a pointer to the message in rm_msg.  If the message didn't
		come from this node, call send_ack() to acknowledge it.  When the
		top of the main Time Warp loop is reached, the message just put
		into rm_msg will be handled fully.

		The Sun version is a little different, mostly in the way it
		gets the messages.  It reads them off a socket, rather than
		calling get_msg().  Otherwise, it is similar to the Mark3 version.

		dump_socket() is a Sun routine to print the contents of a socket
		when something has gone wrong.  It is diagnostic in purpose.

		ioint_rcvack() removes an ack's entry from the table of outstanding
		acknowledgements when an interrupt mandates it.

		_pprintf() is like printf(), but first prints the number of the
		node executing it, providing some idea of where the diagnostic
		message being printed came from.

		check_for_keyin() reads a control channel attached to the keyboard.
		It is only used on the Mark3.

*/


#include <stdio.h>
#include "twcommon.h"
#include "twsys.h"
#include "tester.h"
#include "machdep.h"

extern int host_input_waiting;
extern char standalone;
extern char buff[], *bp;

#ifdef MARK3
extern int peek_limit;

int check_mercury_queue ()
{
	static int nmsg;
	register int iret, i, n;
	register Msgh * pbuf;

	cnt_msgs ( &nmsg );

	if ( nmsg )
	{
		n = nmsg; if ( n > peek_limit ) n = peek_limit;

		for ( i = 0; i < n; i++ )
		{
peek_again:
			recv.source = ANY;
			iret = peek_msg ( &recv );
			if ( iret == OK )
			{
				if ( recv.source == CP )
				{
					get_mercury_msg ();
					goto peek_again;
				}
				if ( recv.mlen == sizeof ( Ack_msg ) )
				{
					get_mercury_msg ();
					goto peek_again;
				}

				pbuf = (Msgh *) recv.buf;

				if ( issys_macro ( pbuf ) )
				{
					get_mercury_msg ();
					break;
				}

				if ( leVTime ( pbuf->rcvtim, xqting_ocb->svt ) )
				{
/*
					if ( ( xqting_ocb->svt.simtime - pbuf->rcvtim.simtime )
								>= 100 )
						_pprintf
						( "Msg for %s at %f beats Exec of %s at %f\n",
							pbuf->rcver, pbuf->rcvtim.simtime,
							xqting_ocb->name, xqting_ocb->svt.simtime );
*/
					get_mercury_msg ();
					break;
				}
			}
			else
				break;
		}
	}
}
#endif

#ifdef MARK3
int interrupt_disable;
extern int object_running;
extern int mlog;

#undef COMMAND
#include <sys/mercsys.h>
#include <sigmsg.h>
 
int ioint_spurious;
int ioint_multi_cnt;
 
update_arrival ( new_q )
 
	register QMSG_PTR new_q;
{
	register QMSG_PTR arrival_q;
 
	if ( ( arrival_q = lock_queue() ) != 0 )
	{
		addQ ( arrival_q, new_q );
		ARRIVAL_QUEUE = arrival_q;
	}
	else
		ARRIVAL_QUEUE = new_q;
}

ioint ()
{
	MSG_STR_PTR ptr1;
	Msgh * msg;
 
	register QMSG_PTR new_q, qptr, nptr;
 
	ioint_cnt++;
 
	if ( ( new_q = get_arrival() ) == 0 )
	{
		ioint_spurious++;
		return;         /* paranoid test for spurious interrupt */
	}
 
	for ( qptr = new_q, nptr = NULL; nptr != new_q ; qptr = nptr )
	{
		if ( new_q == NULL )
			new_q = qptr;
 
		nptr = (QMSG_PTR) qptr->next;
 
		ptr1 = &(qptr->msg);
 
		if ( ptr1->type < 0 )
		{
			ioint_merc_cnt++;
			continue;
		}
 
		if ( ptr1->source == CP )
		{
			ioint_cp_cnt++;
			continue;
		}
 
		if ( tw_node_num >= tw_num_nodes
		||  ptr1->source < node_offset || ptr1->source > node_limit )
		{
			if ( new_q == qptr )
			{
				if ( nptr == new_q )
					nptr = NULL;
				new_q = NULL;
			}
			give_buf ( &(qptr->msg) );
			qptr = delete_msg ( qptr );
			if ( qptr != NULL )
			{
				ioint_multi_cnt++;
			}
			continue;
		}    
 
		msg = (Msgh *)(ptr1->buf);
 
		if ( mlog )
		{
			if ( ptr1->mlen >= sizeof(Msgh) )
			{
				mark3time ();
				msg->msgtimet = node_cputime;
			}
		}   
 
		if ( object_running == 0 || interrupt_disable )
		{   
			continue;
		}   
 
		if ( ptr1->mlen == sizeof ( Ack_msg ) )
		{   
			register int ok;
			ioint_ack_cnt++;
			ioint_rcvack ( ptr1->buf, ptr1->source );
			if ( new_q == qptr )
			{
				if ( nptr == new_q )
					nptr = NULL;
				new_q = NULL;
			}
			give_buf ( &(qptr->msg) );
			qptr = delete_msg ( qptr );
			if ( qptr != NULL )
			{
				ioint_multi_cnt++;
			}
			continue;
		}
 
		if ( issys_macro ( msg ) )
		{
			ioint_twsys_cnt++;
			goto preempt_object;
		}
 
		ioint_msg_cnt++;
 
		if ( isreverse_macro ( msg ) )
		{
			if ( leVTime ( msg->sndtim, xqting_ocb->svt ) )
			{
				ioint_rcvtim_cnt++;
				goto preempt_object;
			}
		}
		else
		{
			if ( leVTime ( msg->rcvtim, xqting_ocb->svt ) )
			{
				ioint_rcvtim_cnt++;
				goto preempt_object;
			}
		}
 
preempt_object:
		;               /* cubix is no longer reentrant! */
#if 0 
		xqting_ocb->sb->cputime += mark3time ();

		object_end_time = node_cputime;
		xqting_ocb->stats.cputime += object_end_time - object_start_time;
		xqting_ocb->stats.cycletime += object_end_time - object_start_time;
		xqting_ocb->sb->effectWork += object_end_time - object_start_time;
 
		switch_preempt ();
 
#ifdef TIMING
		if ( object_running == 0 )
			stop_timing ();
#endif
#endif
	}
	 
	if ( new_q )
		update_arrival ( new_q );
}
#endif


#ifdef SUN

ioint ()
{
	extern int maybe_socket_io;

	maybe_socket_io = 1;
}
#endif


#if BBN || SUN
#if BBN
extern VTime stdout_ok_time;
#endif

extern Msgh * rmq;
int messages_received;
#if SUN
int recv_q_limit = 5;
#endif
#if BBN
int recv_q_limit = 10;
#endif

FUNCTION read_the_mail ( check_only )

	int check_only;
{
	int node;

	MSG_STRUCT  input_msg_struct;
	Msgh * q_msg, * r_deq();

	extern int mlog;

  Debug

#ifdef TIMING
	start_timing ( SYSTEM_TIMING_MODE );
#endif

get_again:

	input_msg_struct.buf = (int *)rm_buf;
	input_msg_struct.source = ANY;
	input_msg_struct.type = ANY;

	while (
#if SUN
		maybe_socket_io &&
#endif
		(messages_received < recv_q_limit) && get_msg ( & input_msg_struct ) )
	{  
		if ( input_msg_struct.source  == CP )
		{
#if BBN
			if ( input_msg_struct.mlen == 0 )
				stdout_acks_pending--;
			else
			if ( input_msg_struct.mlen == sizeof(stdout_ok_time) )
				stdout_ok_time = * (VTime *)input_msg_struct.buf ;
			else
#endif
				_pprintf ( "Rec'd Len %d from CP\n", input_msg_struct.mlen );
			goto  get_again;
		}

		if ( rm_msg != NULL )
			_pprintf ( "rm_msg overwrite\n" );

		rm_msg = (Msgh *)input_msg_struct.buf;

		if ( mlog )
		{
#ifdef MICROTIME
			MicroTime();
#else
			butterflytime ();
#endif
			rm_msg->msgtimet = node_cputime;
		}

#ifdef PARANOID
#if BBN
		node = input_msg_struct.source - node_offset;
#endif
#if SUN
		node = input_msg_struct.source;
#endif

		rcvmsg ( rm_msg, node );

		if (rm_msg->low.from_node != node)
		{
			_pprintf("Bad Message in read_the_mail, input_msg_struct addr %x\n",
				&input_msg_struct);
			showmsg(rm_msg);
			tester();
		}
#endif

#ifdef CHECKSUM
		if ( checksum ( rm_msg ) != (Msgh *)rm_msg->checksum )
		{
			_pprintf ( "Checksum Error\n" );
			showmsg ( rm_msg );
			tester ();
		}
#endif 
		q_msg = (Msgh *)l_create ( msgdefsize );

		if ( q_msg != NULL )
		{
			r_enq ( rm_buf );
			rm_buf = (char *)q_msg;
			input_msg_struct.buf = (int *)rm_buf;
			rm_msg = NULL;
		}
		else
		{
			break;
		}
	}

	if ( rm_msg == NULL )
	{
		if ( check_only )
		{
			rm_msg = (Msgh *)l_next_macro ( rmq );

			if ( l_ishead_macro ( rm_msg ) )
				rm_msg = NULL;
			else
			if ( issys_macro ( rm_msg ) )
				rm_msg = r_deq ();
			else
			if ( leVTime ( rm_msg->rcvtim, xqting_ocb->svt ) )
				rm_msg = r_deq ();
			else
				rm_msg = NULL;
		}
		else
			rm_msg = r_deq ();
	}
#ifdef TIMING
	stop_timing ();
#endif
}

r_enq ( msg )

	Msgh * msg;
{
	register Msgh * next, * prev;

	if ( issys_macro ( msg ) )
	{
		for ( next = rmq, prev = (Msgh *) l_next_macro ( next );
								! l_ishead_macro ( prev );
			  next = prev, prev = (Msgh *) l_next_macro ( next ) )
		{
			if ( ! issys_macro ( prev ) )
				break;
		}
	}
	else
	if ( isanti_macro ( msg ) )
	{
		for ( next = rmq, prev = (Msgh *) l_next_macro ( next );
								! l_ishead_macro ( prev );
			  next = prev, prev = (Msgh *) l_next_macro ( next ) )
		{
			if ( issys_macro ( prev ) )
				continue;

			if ( isposi_macro ( prev ) )
				break;


			if ( ltVTime ( msg->sndtim, prev->sndtim ) )
				break;
/*
			if ( ltVTime ( msg->rcvtim, prev->rcvtim ) )
				break;
*/
		}
	}
	else
	{
		for ( next = (Msgh *) l_prev_macro ( rmq );
				   ! l_ishead_macro ( next );
			  next = (Msgh *) l_prev_macro ( next ) )
		{
			if ( issys_macro ( next ) )
				break;

			if ( geVTime ( msg->sndtim, next->sndtim ) )
				break;
/*
			if ( geVTime ( msg->rcvtim, next->rcvtim ) )
				break;
*/
		}
	}
 
	l_insert ( next, msg );

	messages_received++;
}

Msgh * r_deq ()
{
	Msgh * msg;

	msg = (Msgh *)l_next_macro ( rmq );

	if ( l_ishead_macro ( msg ) )
		msg = NULL;
	else
	{
		l_remove ( msg );
		messages_received--;
	}

	return ( msg );
}

VTime r_min ( min )

	VTime min;
{
	register Msgh * msg;

	for ( msg = (Msgh *) l_next_macro ( rmq );
			  ! l_ishead_macro ( msg );
		  msg = (Msgh *) l_next_macro ( msg ) )
	{
		if ( issys_macro ( msg ) )
			continue;
		  
		if ( ! ( msg->flags & MOVING ) )
		{
			if ( gtVTime ( min, msg->sndtim ) &&
			  strcmp ( msg->rcver, "$IH") != 0  )
				min = msg->sndtim;
		}
	}

	return ( min );
}
#endif
 

#ifdef TRANSPUTER

#include "kmsgh.h"

FUNCTION read_the_mail ()

{
	int good_enough_msg;
	int retval, len, rtn_src, rtn_type;
	int node;

	len = msgdefsize;   /* this is size of rm_buf */

	good_enough_msg = FALSE;

	while ( ! good_enough_msg )
	{
		retval = xrecv ( rm_buf, len, ANY_SRC, /* TYPE */ 0, & rtn_src, & rtn_type );

		if ( retval != -1 )
		{
			node = rtn_src;

			if ( ((LowLevelMsgH *)rm_buf)->type == ACK_MSG )      /* ACK */
			{
				rcvack ( rm_buf, node );
			}

			else        /* not an ACK, a reg. msg */
			{
				good_enough_msg = TRUE;

				if ( rm_msg != NULL )
				{
					_pprintf 
					( "read_the_mail:  R M _ M S G  O V E R W R I T E  O F :\n" );
					dumpmsg ( rm_msg );
					_pprintf ( "read_the_mail:  O V E R W R I T I N G   M S G :\n" );
					dumpmsg ( rm_msg );
				}

				rm_msg = rm_buf;

#ifdef PARANOID
				rcvmsg ( rm_msg, node );
#endif 

				if ( ( node != tw_node_num )  &&  ( ! issys_macro ( rm_msg ) ) )
				{
					sndack ( rm_msg, node );
				}
			}
		}

		else    /* since there is no msg to be had, that will have to be good enough. */
		{
			good_enough_msg = TRUE;
		}
	}
}

#endif  /* TRANSPUTER */


#ifdef MARK3
extern VTime stdout_ok_time;

FUNCTION read_the_mail ()
{
	int iret;
 
  Debug

get_again:

	cnt_msgs ( &iret );
	if ( iret == 0 )
		return;

#ifdef TIMING
	start_timing ( SYSTEM_TIMING_MODE );
#endif

	recv.source = ANY;
	iret = peek_msg ( &recv );

#ifdef TIMING
	stop_timing ();
#endif
 
	if ( iret == OK )
	{
		get_mercury_msg ();

		if ( rm_msg == NULL )
			goto get_again;
	}
}

get_mercury_msg ()
{
	int node;

		LEDS ( 1 );

		unlink_msg ( &recv );

		if ( recv.source == CP )
		{
			if ( recv.mlen == 0 )
				stdout_acks_pending--;
			else
			if ( recv.mlen == sizeof(stdout_ok_time) )
				stdout_ok_time = * (VTime *) recv.buf;
			else
				_pprintf ( "Received Type %d from CP\n", recv.mlen );

#ifdef TIMING
	start_timing ( SYSTEM_TIMING_MODE );
#endif
			give_buf ( &recv );

#ifdef TIMING
	stop_timing ();
#endif
			return;
		} 

		node = recv.source - node_offset;

		if ( ((LowLevelMsgH *)recv.buf)->type == ACK_MSG )       /* ACK */
		{
			rcvack ( recv.buf, node );
#ifdef TIMING
			start_timing ( SYSTEM_TIMING_MODE );
#endif
			give_buf ( &recv );
#ifdef TIMING
			stop_timing ();
#endif
			return;
		}

		if ( rm_msg != NULL )
			_pprintf ( "rm_msg overwrite\n" );

		rm_msg = (Msgh *) recv.buf;

#ifdef PARANOID
		rcvmsg ( rm_msg, node );
#endif 
#ifdef CHECKSUM
		if ( checksum ( rm_msg ) != (Msgh *)rm_msg->checksum )
		{
			_pprintf ( "Checksum Error\n" );
			showmsg ( rm_msg );
			tester ();
		}
#endif
		if ( node != tw_node_num
		&&  ! ( rm_msg->flags & ( SYSMSG | MOVING ) ) )
		{
			sndack ( rm_msg, node );
		}
}
#endif


#ifdef SUN
dump_socket ( node )

	int node;
{
	int i, j, k;
	unsigned char buff[2];

	if ( node > MAX_NODES )             /* if it's a pointer */
		node = * (int *)node;           /* make it the node number */

	printf ( "socket %d\n", node );
	for ( ;; )
	{
		printf ( "\n" );
		for ( i = 0; i < 8; i++ )
		{
			for ( j = 0; j < 4; j++ )
			{
				k = read ( msg_ichan[node], buff, 1 );
				if ( k == -1 )
				{
					printf ( "\n" );
					return;
				}
				printf ( "%.2x", buff[0] );
			}
			printf ( " " );
		}
	}
}

#endif

#ifdef MARK3
ioint_rcvack ( msg, node )
 
	Ack_msg * msg;
	Int node;
{
	register int i;
 
	if ( msg->low.to_node == IH_NODE )
		msg->low.to_node = 0;

	if ( msg->low.from_node != tw_node_num
	||   msg->low.to_node != node )
	{
		return 0;       /* error */
	}
 
	for ( i = 0; i < MAX_ACKS; i++ )
	{
		if ( ack[i].busy
		&&   ack[i].node == node
		&&   ack[i].num  == msg->num )
			break;
	}
 
	if ( i < MAX_ACKS )
	{
		ack[i].busy = FALSE;
		acks_pending--;
	}
	else
	{
		return 0;       /* error */
	}
 
	return 1;   /* ok */
}
#endif

#ifndef TRANSPUTER

/* The following comment is necessary to suppress lint warnings about 
		variable arguments in _pprintf() calls.  Please don't delete. */
/*VARARGS*/
_pprintf ( form, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
				arg11, arg12, arg13, arg14, arg15 )

	char * form;
	int *arg1, *arg2, *arg3, *arg4, *arg5, *arg6, *arg7, *arg8, *arg9, *arg10,
		*arg11, *arg12, *arg13, *arg14, *arg15;
{
#ifdef MARK3_OR_BBN
	static char buff[256];

	sprintf ( buff, "%d--", tw_node_num + node_offset );
	sprintf ( buff + strlen ( buff ),
				form, arg1, arg2, arg3, arg4, arg5,
				arg6, arg7, arg8, arg9, arg10,
				arg11, arg12, arg13, arg14, arg15 );

	printf ( "%s", buff );
#endif

#ifdef SUN
	int count ;
	static char buff[256];
	int len;

	if ( standalone )
	{
		printf ( form, arg1, arg2, arg3, arg4, arg5, 
						arg6, arg7, arg8, arg9, arg10,
						arg11, arg12, arg13, arg14, arg15 );
		fflush ( stdout );
	}
	else
	{
		sprintf ( buff, form, arg1, arg2, arg3, arg4, arg5, 
						arg6, arg7, arg8, arg9, arg10,
						arg11, arg12, arg13, arg14, arg15 );

		len = strlen ( buff );

/*
		if ( buff[len-1] != '\n' )
		{
			buff[len++] = '\\';
			buff[len++] = '\n';
			buff[len] = 0;
		}
*/
		string_to_cp_w ( buff );
/*
		count = 0;
		while ( write ( ctl_ochan, buff, len ) == -1 )
		{
			if (count ++ == 10000)
			{
				printf ("Trying to do _pprintf to host...\n");
				count = 0;
			}
		}
*/
	}
#endif
}

#endif  /* not TRANSPUTER */

#if 0
check_for_keyin ()
{
	int stat;
printf ( "check for keyin called\n" );
tester();

#ifdef TIMING
	start_timing ( SYSTEM_TIMING_MODE );
#endif
	stat = read ( ctl_ichan, buff, 80 );

	if ( stat > 0 )
	{
		buff[stat] = 0;

		bp = buff;

		host_input_waiting = 1;
	}
#ifdef TIMING
	stop_timing ();
#endif
}
#endif

#ifdef TRANSPUTER

entcpy ( dest, src, numbytes )

char    * dest;
char    * src;
int     numbytes;

{
	memcpy ( dest, src, numbytes );
}


clear ( ptr, numbytes )

char    * ptr;
int     numbytes;

{
	bzero ( ptr, numbytes );
}


/*---------------------------------------------------------------------*/

_pprintf ( form, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
				arg11, arg12, arg13, arg14, arg15 )

	char * form;
	int *arg1, *arg2, *arg3, *arg4, *arg5, *arg6, *arg7, *arg8, *arg9, *arg10,
		*arg11, *arg12, *arg13, *arg14, *arg15;
{

	kprintf 
	( 
		form, 
		arg1,  arg2,  arg3,  arg4,  arg5, 
		arg6,  arg7,  arg8,  arg9,  arg10, 
		arg11, arg12, arg13, arg14, arg15 
	);

}

#endif  /* TRANSPUTER */

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
@


1.6
log
@Do casting.
@
text
@d7 3
a417 2
get_again:

d422 2
a433 3
#ifdef TIMING
	stop_timing ();
#endif
d525 3
@


1.5
log
@New copyright notice.
@
text
@d7 3
d421 1
a421 1
	input_msg_struct.buf = rm_buf;
d451 1
a451 1
		rm_msg = input_msg_struct.buf;
d490 1
a490 1
		q_msg = l_create ( msgdefsize );
d495 2
a496 2
			rm_buf = q_msg;
			input_msg_struct.buf = rm_buf;
d509 1
a509 1
			rm_msg = l_next_macro ( rmq );
d592 1
a592 1
	msg = l_next_macro ( rmq );
@


1.4
log
@1. Added signal driven socket support.
2. combined the Sun and BBN read_the_mail routines.
3. removed mistuff and changed 128 to IH_NODE
@
text
@d1 4
d6 6
a11 1
 * $Log:        machdep.c,v $
a23 3
/*      Copyright (C) 1989, California Institute of Technology.
		U. S. Government Sponsorship under NASA Contract NAS7-918
		is acknowledged.        */
@


1.3
log
@Tab conversion.
@
text
@d3 3
d372 3
a374 2
	if ( host_input_waiting == 0 )
		check_for_keyin ();
d379 2
a380 1
#ifdef BBN
d382 1
d386 6
a391 1
extern int max_neg_acks;
d416 5
a420 1
	while ( messages_received < max_neg_acks && get_msg ( & input_msg_struct ) )
d427 1
d434 1
a438 2
		node = input_msg_struct.source - node_offset;

d446 3
d450 1
d455 6
d464 1
a464 1
		if (rm_msg->mistuff[0] != node)
d645 1
a645 1
			if ( ((Ack_msg *)rm_buf)->ack_flag != 0 )       /* ACK */
d752 1
a752 1
		if ( ((Ack_msg *)recv.buf)->ack_flag != 0 )       /* ACK */
a788 5
#ifdef SUN
FUNCTION read_the_mail ()
{
	register int cc, n, node;
	static int last_node = 0;
a789 94
  Debug

	for ( node = last_node + 1; ; node++ )
	{
		if ( node == tw_num_nodes )
			node = 0;

		if ( node == tw_node_num )
			goto check_for_exit;

read_ack:

#ifdef TIMING
	start_timing ( SYSTEM_TIMING_MODE );
#endif
		cc = read ( msg_ichan[node], rm_buf, 8 );

		if ( cc > 0 )
		{
			while ( cc < 8 )
			{
				while ((n=read(msg_ichan[node], rm_buf+cc, 8-cc ) ) == -1 )
					;
				cc += n;
			}

			if ( ((Ack_msg *)rm_buf)->ack_flag != 0 )   /* ACK */
			{
#ifdef TIMING
	stop_timing ();
#endif
				rcvack ( (Ack_msg *) rm_buf, node );

				goto read_ack;
			}

#ifdef PARANOID
			rcvmsg ( (Msgh *) rm_buf, node );
#endif
			while ( cc < sizeof(Msgh) )
			{
				while ((n=read(msg_ichan[node], rm_buf+cc, sizeof(Msgh)-cc))== -1)
					;
				cc += n;
			}

			cc = 0;
			while ( cc < ((Msgh *)rm_buf)->txtlen )
			{
				while ( ( n = read ( msg_ichan[node],
						rm_buf + sizeof(Msgh) + cc,
						((Msgh *)rm_buf)->txtlen - cc) ) == -1 )
					;
				cc += n;
			}

#ifdef TIMING
	stop_timing ();
#endif
			if ( rm_msg != NULL )
				_pprintf ( "rm_msg overwrite\n" );

			rm_msg = (Msgh *) rm_buf;

#ifdef CHECKSUM
			if ( checksum ( rm_msg ) != (Msgh *)rm_msg->checksum )
			{
				_pprintf ( "Checksum Error\n" );
				showmsg ( rm_msg );
				tester ();
			}
#endif
			if ( node != tw_node_num
			&&  ! ( rm_msg->flags & ( SYSMSG | MOVING ) ) )
			{
				sndack ( rm_msg, node );
			}

			last_node = node;

			return;
		}
#ifdef TIMING
	stop_timing ();
#endif

check_for_exit:
		if ( node == last_node )
			break;
	}
}
#endif


d832 2
a833 2
	if ( msg->to_node == 128 )
		msg->to_node = 0;
d835 2
a836 2
	if ( msg->from_node != tw_node_num
	||   msg->to_node != node )
d907 1
d914 3
a916 1

d926 1
d933 1
a933 1
#ifdef SUN
d937 2
@


1.2
log
@Bug fix to not consider IH messages in gvt calculation.
@
text
@d2 4
a5 1
 * $Log:	machdep.c,v $
d10 1
a10 1
char machdep_id [] = "@@(#)machdep.c	1.58\t10/2/89\t14:45:42\tTIMEWARP";
d12 3
a14 3
/*	Copyright (C) 1989, California Institute of Technology.
	U. S. Government Sponsorship under NASA Contract NAS7-918
	is acknowledged.	*/
d20 5
a24 5
	machdep.c is meant to contain as much of Time Warp's machine
	dependent code as possible.  Some machine dependent code must
	be kept elsewhere, because it is intimately related to higher
	level functions.  The smaller pieces of code that have little
	to do with anything else are kept here.
d26 5
a30 5
	machdep.c is a temporary arrangement. In the future, we expect to
	replace it with a separate file for each type of machine supported.
	For instance, there would be a sun.c, a mark3.c, and a butterfly.c.
	These modules would contain only the code needed for that particular
	machine.
d34 4
a37 4
	check_mercury_queue() -  look for a message in the mercury queue
			more important than what we're doing
		Parameters - none
		Return - TRUE or FALSE
d39 6
a44 6
	ioint(ptr1,ptr2) - check whether we want to switch context on
			an interrupt
		Parameters - MSG_STR_PTR ptr1, int * ptr2
		Return - 0 if the message is to be processed, 1 if the
			message has been cleared
		[Sun version has no parameters]
d46 3
a48 3
	read_the_mail() - examine incoming messages
		Parameters - none
		Return - Always returns zero
d50 3
a52 3
	print_acks() - print the contents of the acks table
		Parameters - none
		Return - Always returns zero
d54 4
a57 4
	ioint_rcvack(msg,node) - remove an ack from the acks table because of
			an interrupt
		Parameters - Ack_msg  *msg, Int node
		Return - 0 if failure, 1 if successful
d59 5
a63 5
	_pprintf(form,arg1,arg2, . . . , arg15) - printf to stdout with node 
			number added to the front
		Parameters -  char * form, int * arg1, int * arg2, . . . ,
				int * arg15
		Return - Always returns zero
d65 3
a67 3
	check_for_keyin() - on a Sun, check if there's any keyboard input
		Parameters - none
		Return - Always returns zero
d71 12
a82 12
	check_mercury_queue() calls cnt_msgs() to determine how many
	messages are queued.  For each, call peek_msg().  If the message
	came from the CP, or was an ack, or it was a system message, or
	its receive time is not greater than the simulation time of the
	currently executing object go to the end of the routine.  Otherwise,
	look at the next message.  If the end of the routine is reached
	by normal loop termination, we didn't find an earlier message, 
	and FALSE is returned.  If one of the earlier mentioned tests
	succeeded, we found a message that needs immediate processing,
	so we return TRUE.  (Essentially, this routine checks to see
	if an incoming message is of sufficient importance to interrupt
	the executing object.)
d84 11
a94 11
	ioint() deals with interrupts.  If the type of the interrupt is
	unknown, or is from the CP, just increment a counter.  If the
	interrupting message is an ack, call ioint_rcvack().  If it's
	any other type of message, check to see if it should preempt
	the object, calling switch_preempt() if it should.  ioint() is
	called by the assembly language routine that performs switching
	functions.  switch_preempt() is also in that assembly language
	code.  If the object is preempted, the system will return to
	the main loop, where it will check for mercury messages and
	process the interrupting one.  If we're not on a Mark3, then
	all that ioint() does is call check_for_keyin().
d96 9
a104 9
	read_the_mail() looks at incoming messages.  It calls get_msg()
	to retrieve one.  If it came from the CP, essentially throw it
	away, possibly after storing some information it contained.
	If it came from elsewhere, copy the message to rm_buf.  If it's
	an ack, call rcv_ack() and get another message.  Otherwise, 
	store a pointer to the message in rm_msg.  If the message didn't
	come from this node, call send_ack() to acknowledge it.  When the
	top of the main Time Warp loop is reached, the message just put
	into rm_msg will be handled fully.
d106 3
a108 3
	The Sun version is a little different, mostly in the way it
	gets the messages.  It reads them off a socket, rather than
	calling get_msg().  Otherwise, it is similar to the Mark3 version.
d110 2
a111 2
	dump_socket() is a Sun routine to print the contents of a socket
	when something has gone wrong.  It is diagnostic in purpose.
d113 2
a114 2
	ioint_rcvack() removes an ack's entry from the table of outstanding
	acknowledgements when an interrupt mandates it.
d116 3
a118 3
	_pprintf() is like printf(), but first prints the number of the
	node executing it, providing some idea of where the diagnostic
	message being printed came from.
d120 2
a121 2
	check_for_keyin() reads a control channel attached to the keyboard.
	It is only used on the Mark3.
d141 3
a143 3
    static int nmsg;
    register int iret, i, n;
    register Msgh * pbuf;
d145 1
a145 1
    cnt_msgs ( &nmsg );
d147 3
a149 3
    if ( nmsg )
    {
	n = nmsg; if ( n > peek_limit ) n = peek_limit;
d151 2
a152 2
	for ( i = 0; i < n; i++ )
	{
d154 14
a167 14
	    recv.source = ANY;
	    iret = peek_msg ( &recv );
	    if ( iret == OK )
	    {
		if ( recv.source == CP )
		{
		    get_mercury_msg ();
		    goto peek_again;
		}
		if ( recv.mlen == sizeof ( Ack_msg ) )
		{
		    get_mercury_msg ();
		    goto peek_again;
		}
d169 1
a169 1
		pbuf = (Msgh *) recv.buf;
d171 5
a175 5
		if ( issys_macro ( pbuf ) )
		{
		    get_mercury_msg ();
		    break;
		}
d177 2
a178 2
		if ( leVTime ( pbuf->rcvtim, xqting_ocb->svt ) )
		{
d180 6
a185 6
		    if ( ( xqting_ocb->svt.simtime - pbuf->rcvtim.simtime )
				>= 100 )
			_pprintf
			( "Msg for %s at %f beats Exec of %s at %f\n",
			    pbuf->rcver, pbuf->rcvtim.simtime,
			    xqting_ocb->name, xqting_ocb->svt.simtime );
d187 6
a192 2
		    get_mercury_msg ();
		    break;
a193 3
	    }
	    else
		break;
a194 1
    }
d212 1
a212 1
    register QMSG_PTR new_q;
d214 1
a214 1
    register QMSG_PTR arrival_q;
d216 7
a222 7
    if ( ( arrival_q = lock_queue() ) != 0 )
    {
	addQ ( arrival_q, new_q );
	ARRIVAL_QUEUE = arrival_q;
    }
    else
	ARRIVAL_QUEUE = new_q;
d227 2
a228 2
    MSG_STR_PTR ptr1;
    Msgh * msg;
d230 1
a230 1
    register QMSG_PTR new_q, qptr, nptr;
d232 1
a232 1
    ioint_cnt++;
d234 5
a238 5
    if ( ( new_q = get_arrival() ) == 0 )
    {
	ioint_spurious++;
	return;		/* paranoid test for spurious interrupt */
    }
d240 4
a243 4
    for ( qptr = new_q, nptr = NULL; nptr != new_q ; qptr = nptr )
    {
	if ( new_q == NULL )
	    new_q = qptr;
d245 1
a245 1
	nptr = (QMSG_PTR) qptr->next;
d247 1
a247 1
	ptr1 = &(qptr->msg);
d249 5
a253 5
	if ( ptr1->type < 0 )
	{
	    ioint_merc_cnt++;
	    continue;
	}
d255 5
a259 5
	if ( ptr1->source == CP )
	{
	    ioint_cp_cnt++;
	    continue;
	}
d261 17
a277 17
	if ( tw_node_num >= tw_num_nodes
	||  ptr1->source < node_offset || ptr1->source > node_limit )
	{
	    if ( new_q == qptr )
	    {
		if ( nptr == new_q )
		    nptr = NULL;
		new_q = NULL;
	    }
	    give_buf ( &(qptr->msg) );
	    qptr = delete_msg ( qptr );
	    if ( qptr != NULL )
	    {
		ioint_multi_cnt++;
	    }
	    continue;
	}    
d279 1
a279 1
	msg = (Msgh *)(ptr1->buf);
d281 8
a288 8
	if ( mlog )
	{
	    if ( ptr1->mlen >= sizeof(Msgh) )
	    {
		mark3time ();
		msg->msgtimet = node_cputime;
	    }
	}   
d290 4
a293 4
	if ( object_running == 0 || interrupt_disable )
	{   
	    continue;
	}   
d295 19
a313 19
	if ( ptr1->mlen == sizeof ( Ack_msg ) )
	{   
	    register int ok;
	    ioint_ack_cnt++;
	    ioint_rcvack ( ptr1->buf, ptr1->source );
	    if ( new_q == qptr )
	    {
		if ( nptr == new_q )
		    nptr = NULL;
		new_q = NULL;
	    }
	    give_buf ( &(qptr->msg) );
	    qptr = delete_msg ( qptr );
	    if ( qptr != NULL )
	    {
		ioint_multi_cnt++;
	    }
	    continue;
	}
d315 5
a319 5
	if ( issys_macro ( msg ) )
	{
	    ioint_twsys_cnt++;
	    goto preempt_object;
	}
d321 1
a321 1
	ioint_msg_cnt++;
d323 16
a338 16
	if ( isreverse_macro ( msg ) )
	{
	    if ( leVTime ( msg->sndtim, xqting_ocb->svt ) )
	    {
		ioint_rcvtim_cnt++;
		goto preempt_object;
	    }
	}
	else
	{
	    if ( leVTime ( msg->rcvtim, xqting_ocb->svt ) )
	    {
		ioint_rcvtim_cnt++;
		goto preempt_object;
	    }
	}
d341 1
a341 1
	;		/* cubix is no longer reentrant! */
d343 1
a343 1
	xqting_ocb->sb->cputime += mark3time ();
d345 4
a348 4
	object_end_time = node_cputime;
	xqting_ocb->stats.cputime += object_end_time - object_start_time;
        xqting_ocb->stats.cycletime += object_end_time - object_start_time;
        xqting_ocb->sb->effectWork += object_end_time - object_start_time;
d350 1
a350 1
	switch_preempt ();
d353 2
a354 2
	if ( object_running == 0 )
	    stop_timing ();
d357 4
a360 4
    }
     
    if ( new_q )
	update_arrival ( new_q );
d369 2
a370 2
    if ( host_input_waiting == 0 )
	check_for_keyin ();
d384 1
a384 1
    int check_only;
d386 1
a386 1
    int node;
d388 2
a389 2
    MSG_STRUCT  input_msg_struct;
    Msgh * q_msg, * r_deq();
d391 1
a391 1
    extern int mlog;
d398 1
a398 1
    start_timing ( SYSTEM_TIMING_MODE );
d401 3
a403 3
    input_msg_struct.buf = rm_buf;
    input_msg_struct.source = ANY;
    input_msg_struct.type = ANY;
d405 2
a406 2
    while ( messages_received < max_neg_acks && get_msg ( & input_msg_struct ) )
    {  
d408 1
a408 1
    stop_timing ();
d410 11
a420 11
	if ( input_msg_struct.source  == CP )
	{
	    if ( input_msg_struct.mlen == 0 )
		stdout_acks_pending--;
	    else
	    if ( input_msg_struct.mlen == sizeof(stdout_ok_time) )
		stdout_ok_time = * (VTime *)input_msg_struct.buf ;
	    else
		_pprintf ( "Rec'd Len %d from CP\n", input_msg_struct.mlen );
	    goto  get_again;
	}
d422 1
a422 1
	node = input_msg_struct.source - node_offset;
d424 2
a425 2
	if ( rm_msg != NULL )
	    _pprintf ( "rm_msg overwrite\n" );
d427 1
a427 1
	rm_msg = input_msg_struct.buf;
d429 5
a433 5
	if ( mlog )
	{
	    butterflytime ();
	    rm_msg->msgtimet = node_cputime;
	}
d437 1
a437 1
	rcvmsg ( rm_msg, node );
d439 7
a445 7
	if (rm_msg->mistuff[0] != node)
	{
	    _pprintf("Bad Message in read_the_mail, input_msg_struct addr %x\n",
		&input_msg_struct);
	    showmsg(rm_msg);
	    tester();
	}
d449 6
a454 6
	if ( checksum ( rm_msg ) != (Msgh *)rm_msg->checksum )
	{
	    _pprintf ( "Checksum Error\n" );
	    showmsg ( rm_msg );
	    tester ();
	}
d456 1
a456 1
	q_msg = l_create ( msgdefsize );
d458 11
a468 6
	if ( q_msg != NULL )
	{
	    r_enq ( rm_buf );
	    rm_buf = q_msg;
	    input_msg_struct.buf = rm_buf;
	    rm_msg = NULL;
a469 5
	else
	{
	    break;
	}
    }
d471 1
a471 3
    if ( rm_msg == NULL )
    {
	if ( check_only )
d473 3
a475 1
	    rm_msg = l_next_macro ( rmq );
d477 13
a489 10
	    if ( l_ishead_macro ( rm_msg ) )
		rm_msg = NULL;
	    else
	    if ( issys_macro ( rm_msg ) )
		rm_msg = r_deq ();
	    else
	    if ( leVTime ( rm_msg->rcvtim, xqting_ocb->svt ) )
		rm_msg = r_deq ();
	    else
		rm_msg = NULL;
a490 3
	else
	    rm_msg = r_deq ();
    }
d495 1
a495 1
    Msgh * msg;
d497 1
a497 1
    register Msgh * next, * prev;
d499 1
a499 5
    if ( issys_macro ( msg ) )
    {
	for ( next = rmq, prev = (Msgh *) l_next_macro ( next );
				! l_ishead_macro ( prev );
	      next = prev, prev = (Msgh *) l_next_macro ( next ) )
d501 7
a507 2
	    if ( ! issys_macro ( prev ) )
		break;
d509 2
a510 7
    }
    else
    if ( isanti_macro ( msg ) )
    {
	for ( next = rmq, prev = (Msgh *) l_next_macro ( next );
				! l_ishead_macro ( prev );
	      next = prev, prev = (Msgh *) l_next_macro ( next ) )
d512 6
a517 2
	    if ( issys_macro ( prev ) )
		continue;
d519 2
a520 2
	    if ( isposi_macro ( prev ) )
		break;
d523 2
a524 2
	    if ( ltVTime ( msg->sndtim, prev->sndtim ) )
		break;
d526 2
a527 2
	    if ( ltVTime ( msg->rcvtim, prev->rcvtim ) )
		break;
d529 1
d531 1
a531 6
    }
    else
    {
	for ( next = (Msgh *) l_prev_macro ( rmq );
		   ! l_ishead_macro ( next );
	      next = (Msgh *) l_prev_macro ( next ) )
d533 6
a538 2
	    if ( issys_macro ( next ) )
		break;
d540 2
a541 2
	    if ( geVTime ( msg->sndtim, next->sndtim ) )
		break;
d543 2
a544 2
	    if ( geVTime ( msg->rcvtim, next->rcvtim ) )
		break;
d546 1
a547 1
    }
d549 1
a549 1
    l_insert ( next, msg );
d551 1
a551 1
    messages_received++;
d556 1
a556 1
    Msgh * msg;
d558 1
a558 1
    msg = l_next_macro ( rmq );
d560 7
a566 7
    if ( l_ishead_macro ( msg ) )
	msg = NULL;
    else
    {
	l_remove ( msg );
	messages_received--;
    }
d568 1
a568 1
    return ( msg );
d573 1
a573 1
    VTime min;
d575 1
a575 1
    register Msgh * msg;
d577 14
a590 14
    for ( msg = (Msgh *) l_next_macro ( rmq );
              ! l_ishead_macro ( msg );
          msg = (Msgh *) l_next_macro ( msg ) )
    {
        if ( issys_macro ( msg ) )
            continue;
          
        if ( ! ( msg->flags & MOVING ) )
        {
            if ( gtVTime ( min, msg->sndtim ) &&
              strcmp ( msg->rcver, "$IH") != 0  )
                min = msg->sndtim;
        }
    }
d592 1
a592 1
    return ( min );
d604 3
a606 3
    int good_enough_msg;
    int	retval, len, rtn_src, rtn_type;
    int node;
d608 1
a608 1
    len = msgdefsize;	/* this is size of rm_buf */
d610 1
a610 1
    good_enough_msg = FALSE;
d612 1
a612 5
    while ( ! good_enough_msg )
    {
	retval = xrecv ( rm_buf, len, ANY_SRC, /* TYPE */ 0, & rtn_src, & rtn_type );

	if ( retval != -1 )
d614 1
a614 1
	    node = rtn_src;
d616 3
a618 4
	    if ( ((Ack_msg *)rm_buf)->ack_flag != 0 )       /* ACK */
	    {
		rcvack ( rm_buf, node );
	    }
d620 4
a623 3
	    else 	/* not an ACK, a reg. msg */
	    {
		good_enough_msg = TRUE;
d625 3
a627 8
		if ( rm_msg != NULL )
		{
		    _pprintf 
		    ( "read_the_mail:  R M _ M S G  O V E R W R I T E  O F :\n" );
		    dumpmsg ( rm_msg );
		    _pprintf ( "read_the_mail:  O V E R W R I T I N G   M S G :\n" );
		    dumpmsg ( rm_msg );
		}
d629 8
a636 1
		rm_msg = rm_buf;
d638 2
d641 1
a641 1
		rcvmsg ( rm_msg, node );
d644 8
a651 1
		if ( ( node != tw_node_num )  &&  ( ! issys_macro ( rm_msg ) ) )
d653 1
a653 1
		    sndack ( rm_msg, node );
a654 1
	    }
a655 6

	else	/* since there is no msg to be had, that will have to be good enough. */
	{
	    good_enough_msg = TRUE;
	}
    }
d658 1
a658 1
#endif	/* TRANSPUTER */
d666 1
a666 1
    int iret;
d672 3
a674 3
    cnt_msgs ( &iret );
    if ( iret == 0 )
	return;
d677 1
a677 1
    start_timing ( SYSTEM_TIMING_MODE );
d680 2
a681 2
    recv.source = ANY;
    iret = peek_msg ( &recv );
d684 1
a684 1
    stop_timing ();
d687 3
a689 3
    if ( iret == OK )
    {
	get_mercury_msg ();
d691 3
a693 3
	if ( rm_msg == NULL )
	    goto get_again;
    }
d698 1
a698 1
    int node;
d700 1
a700 1
        LEDS ( 1 );
d702 1
a702 1
	unlink_msg ( &recv );
d704 9
a712 9
	if ( recv.source == CP )
	{
	    if ( recv.mlen == 0 )
		stdout_acks_pending--;
	    else
	    if ( recv.mlen == sizeof(stdout_ok_time) )
		stdout_ok_time = * (VTime *) recv.buf;
	    else
		_pprintf ( "Received Type %d from CP\n", recv.mlen );
d715 1
a715 1
    start_timing ( SYSTEM_TIMING_MODE );
d717 1
a717 1
            give_buf ( &recv );
d720 1
a720 1
    stop_timing ();
d722 2
a723 2
	    return;
	} 
d725 1
a725 1
        node = recv.source - node_offset;
d727 3
a729 3
        if ( ((Ack_msg *)recv.buf)->ack_flag != 0 )       /* ACK */
        {
            rcvack ( recv.buf, node );
d731 1
a731 1
	    start_timing ( SYSTEM_TIMING_MODE );
d733 1
a733 1
	    give_buf ( &recv );
d735 1
a735 1
	    stop_timing ();
d737 2
a738 2
	    return;
        }
d740 2
a741 2
	if ( rm_msg != NULL )
	    _pprintf ( "rm_msg overwrite\n" );
d743 1
a743 1
        rm_msg = (Msgh *) recv.buf;
d746 1
a746 1
        rcvmsg ( rm_msg, node );
d749 6
a754 6
	if ( checksum ( rm_msg ) != (Msgh *)rm_msg->checksum )
	{
	    _pprintf ( "Checksum Error\n" );
	    showmsg ( rm_msg );
	    tester ();
	}
d756 5
a760 5
        if ( node != tw_node_num
        &&  ! ( rm_msg->flags & ( SYSMSG | MOVING ) ) )
        {
            sndack ( rm_msg, node );
        }
d767 2
a768 2
    register int cc, n, node;
    static int last_node = 0;
d772 4
a775 4
    for ( node = last_node + 1; ; node++ )
    {
	if ( node == tw_num_nodes )
	    node = 0;
d777 2
a778 2
	if ( node == tw_node_num )
	    goto check_for_exit;
d783 1
a783 1
    start_timing ( SYSTEM_TIMING_MODE );
d785 1
a785 1
	cc = read ( msg_ichan[node], rm_buf, 8 );
d787 8
a794 8
	if ( cc > 0 )
	{
	    while ( cc < 8 )
	    {
		while ((n=read(msg_ichan[node], rm_buf+cc, 8-cc ) ) == -1 )
		    ;
		cc += n;
	    }
d796 2
a797 2
	    if ( ((Ack_msg *)rm_buf)->ack_flag != 0 )	/* ACK */
	    {
d799 1
a799 1
    stop_timing ();
d801 1
a801 1
		rcvack ( (Ack_msg *) rm_buf, node );
d803 2
a804 2
		goto read_ack;
	    }
d807 1
a807 1
	    rcvmsg ( (Msgh *) rm_buf, node );
d809 6
a814 6
	    while ( cc < sizeof(Msgh) )
	    {
		while ((n=read(msg_ichan[node], rm_buf+cc, sizeof(Msgh)-cc))== -1)
		    ;
		cc += n;
	    }
d816 9
a824 9
	    cc = 0;
	    while ( cc < ((Msgh *)rm_buf)->txtlen )
	    {
		while ( ( n = read ( msg_ichan[node],
			rm_buf + sizeof(Msgh) + cc,
			((Msgh *)rm_buf)->txtlen - cc) ) == -1 )
		    ;
		cc += n;
	    }
d827 1
a827 1
    stop_timing ();
d829 2
a830 2
	    if ( rm_msg != NULL )
		_pprintf ( "rm_msg overwrite\n" );
d832 1
a832 1
	    rm_msg = (Msgh *) rm_buf;
d835 6
a840 6
	    if ( checksum ( rm_msg ) != (Msgh *)rm_msg->checksum )
	    {
		_pprintf ( "Checksum Error\n" );
		showmsg ( rm_msg );
		tester ();
	    }
d842 5
a846 5
	    if ( node != tw_node_num
	    &&  ! ( rm_msg->flags & ( SYSMSG | MOVING ) ) )
	    {
		sndack ( rm_msg, node );
	    }
d848 1
a848 1
	    last_node = node;
d850 2
a851 2
	    return;
	}
d853 1
a853 1
    stop_timing ();
d857 3
a859 3
	if ( node == last_node )
	    break;
    }
d867 1
a867 1
    int node;
d869 2
a870 2
    int i, j, k;
    unsigned char buff[2];
d872 2
a873 2
    if ( node > MAX_NODES )		/* if it's a pointer */
	node = * (int *)node;		/* make it the node number */
d875 2
a876 5
    printf ( "socket %d\n", node );
    for ( ;; )
    {
	printf ( "\n" );
	for ( i = 0; i < 8; i++ )
d878 2
a879 4
	    for ( j = 0; j < 4; j++ )
	    {
		k = read ( msg_ichan[node], buff, 1 );
		if ( k == -1 )
d881 11
a891 2
		    printf ( "\n" );
		    return;
a892 3
		printf ( "%.2x", buff[0] );
	    }
	    printf ( " " );
a893 1
    }
d901 2
a902 2
    Ack_msg * msg;
    Int node;
d904 1
a904 1
    register int i;
d906 2
a907 2
    if ( msg->to_node == 128 )
	msg->to_node = 0;
d909 5
a913 5
    if ( msg->from_node != tw_node_num
    ||   msg->to_node != node )
    {
	return 0;       /* error */
    }
d915 7
a921 7
    for ( i = 0; i < MAX_ACKS; i++ )
    {
	if ( ack[i].busy
	&&   ack[i].node == node
	&&   ack[i].num  == msg->num )
	    break;
    }
d923 9
a931 9
    if ( i < MAX_ACKS )
    {
	ack[i].busy = FALSE;
	acks_pending--;
    }
    else
    {
	return 0;       /* error */
    }
d933 1
a933 1
    return 1;   /* ok */
d940 1
a940 1
	variable arguments in _pprintf() calls.  Please don't delete. */
d943 1
a943 1
		arg11, arg12, arg13, arg14, arg15 )
d945 3
a947 3
    char * form;
    int *arg1, *arg2, *arg3, *arg4, *arg5, *arg6, *arg7, *arg8, *arg9, *arg10,
	*arg11, *arg12, *arg13, *arg14, *arg15;
d950 1
a950 1
    static char buff[256];
d952 5
a956 5
    sprintf ( buff, "%d--", tw_node_num + node_offset );
    sprintf ( buff + strlen ( buff ),
		form, arg1, arg2, arg3, arg4, arg5,
                arg6, arg7, arg8, arg9, arg10,
		arg11, arg12, arg13, arg14, arg15 );
d958 1
a958 1
    printf ( "%s", buff );
d962 3
a964 3
    int count ;
    static char buff[256];
    int len;
d966 1
a966 16
    if ( standalone )
    {
	printf ( form, arg1, arg2, arg3, arg4, arg5, 
			arg6, arg7, arg8, arg9, arg10,
			arg11, arg12, arg13, arg14, arg15 );
	fflush ( stdout );
    }
    else
    {
	sprintf ( buff, form, arg1, arg2, arg3, arg4, arg5, 
			arg6, arg7, arg8, arg9, arg10,
			arg11, arg12, arg13, arg14, arg15 );

	len = strlen ( buff );

	if ( buff[len-1] != '\n' )
d968 4
a971 3
	    buff[len++] = '\\';
	    buff[len++] = '\n';
	    buff[len] = 0;
d973 5
d979 9
a987 6
        count = 0;
	while ( write ( ctl_ochan, buff, len ) == -1 )
	{
	    if (count ++ == 10000)
	    {
		printf ("Trying to do _pprintf to host...\n");
d989 8
a996 1
	    }
a997 1
    }
d1001 1
a1001 1
#endif	/* not TRANSPUTER */
d1006 1
a1006 1
    int stat;
d1009 1
a1009 1
    start_timing ( SYSTEM_TIMING_MODE );
d1011 1
a1011 1
    stat = read ( ctl_ichan, buff, 80 );
d1013 3
a1015 3
    if ( stat > 0 )
    {
	buff[stat] = 0;
d1017 1
a1017 1
	bp = buff;
d1019 2
a1020 2
	host_input_waiting = 1;
    }
d1022 1
a1022 1
    stop_timing ();
d1031 3
a1033 3
char	* dest;
char	* src;
int	numbytes;
d1036 1
a1036 1
    memcpy ( dest, src, numbytes );
d1042 2
a1043 2
char	* ptr;
int	numbytes;
d1046 1
a1046 1
    bzero ( ptr, numbytes );
d1053 1
a1053 1
		arg11, arg12, arg13, arg14, arg15 )
d1055 3
a1057 3
    char * form;
    int *arg1, *arg2, *arg3, *arg4, *arg5, *arg6, *arg7, *arg8, *arg9, *arg10,
	*arg11, *arg12, *arg13, *arg14, *arg15;
d1060 7
a1066 7
    kprintf 
    ( 
	form, 
	arg1,  arg2,  arg3,  arg4,  arg5, 
	arg6,  arg7,  arg8,  arg9,  arg10, 
	arg11, arg12, arg13, arg14, arg15 
    );
d1070 1
a1070 1
#endif	/* TRANSPUTER */
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
d583 2
a584 1
            if ( gtVTime ( min, msg->sndtim ) )
@
